<html dir="rtl">

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>TOC_fa</title>
 
<style>
<!--
* { margin:0;}
    .P48 { color:#00000a; font-size:12pt; text-align:left ! important; font-family:Liberation Serif; writing-mode:lr-tb; }
    .T7 { color:#333333; font-family:arial; font-size:12pt; font-weight:bold; }
    .P15 { color:#00000a; font-size:10pt; text-align:left ! important; font-family:arial; writing-mode:lr-tb; margin-left:0.1866in; margin-right:0in; text-indent:0in; }
    .T34 { color:#000000; font-family:arial; font-size:8pt; font-style:italic; font-weight:bold; }
    .T32 { color:#000000; font-family:arial; font-size:8pt; font-weight:normal; }
    ._5f_OOoComputerComment { color:#4c4c4c; font-family:Courier New; }
    .T39 { font-size:8pt; font-weight:normal; }
    ._5f_OOoComputerIdent { color:#008000; font-family:Courier New; }
    .T38 { font-size:8pt; font-weight:normal; }
    ._5f_OOoComputerSpecial { color:#000000; font-family:Courier New; }
    ._5f_OOoComputerNumber { color:#ff3200; font-family:Courier New; }
    ._5f_OOoComputerLiteral { color:#ff0000; font-family:Courier New; }
    ._5f_OOoComputerKeyWord { color:#000080; font-family:Courier New; }
    .P19 { color:#00000a; font-size:12pt; text-align:left ! important; font-family:Liberation Serif; writing-mode:lr-tb; margin-left:0.1866in; margin-right:0in; text-indent:0in; }
    .T17 { font-family:arial; font-size:8pt; }
    .P17 { color:#00000a; font-size:10pt; text-align:left ! important; font-family:arial; writing-mode:lr-tb; margin-left:0.1866in; margin-right:0in; text-indent:0in; }
    .T51 { font-size:8pt; font-weight:normal; }
    .T28 { color:#000000; font-family:arial; font-size:8pt; font-weight:normal; }
    .T53 { font-size:8pt; font-weight:normal; }
-->
</style>
 
</head>

<body background="x3.jpeg">

<table border="0" width="100%" cellspacing="0" cellpadding="0">
	<tr>
		<td>
		<table border="0" cellPadding="0" width="100%" id="table4" dir="ltr">
			<tr>
				<td vAlign="top" width="100" align="right"><font face="Arial">
				<img border="0" src="xCover_A_bypassingAVSv2.PNG" width="127" height="194"></font></td>
				<td width="2"></td>
				<td vAlign="top" align="left">
				<table border="0" cellSpacing="4" cellPadding="0" width="100%" id="table5">
					<tr>
						<td vAlign="top" colSpan="2" align="left"><b>
						<font face="Arial">Bypassing Anti Viruses by C# 
						Programming v2.0</font></b></td>
					</tr>
					<tr>
						<td vAlign="top" align="left"><b>
						<font face="Arial" size="2">
						<span class="b24-bookauthor">by&nbsp;Damon Mohammadbagher</span></font></b></td>
						<td vAlign="top" align="right"><font face="Arial">
						<span class="b24-bookisbn">&nbsp;</span></font></td>
					</tr>
					<tr>
						<td vAlign="top" colSpan="2" align="left">
						<font face="Arial" size="2">
						<span class="b24-bookcwdate"><b>© 2023 ,</b> </span><b>
						Language: Persian Edition</b></font></td>
					</tr>
					<tr>
						<td vAlign="top" colSpan="2" align="left">
						<p class="b24-bookeditorial"><b>
						<font face="Arial" color="#FF6600" size="2">as Pentester in this 
						book i want to share some of codes for bypassing AVs 
						which </font></b>
						<p class="b24-bookeditorial"><b>
						<font face="Arial" color="#FF6600" size="2">originally made by myself or made by others.</font></b></td>
					</tr>
				</table>
		<table border="0" cellSpacing="0" cellPadding="2" width="462" xmlns:dc="http://purl.org/dc/elements/1.0/" id="table7">
			<tr class="b24-toctitle">
				<td dir="ltr" align="left">&nbsp;</td>
			</tr>
			<tr class="b24-toctitle">
				<td dir="ltr" align="left">&nbsp;</td>
			</tr>
		</table>
				</td>
			</tr>
		</table>
		<p align="center"><font face="Arial"><b>Table of 
				Contents </b></font></p>
		<table class="b24-tocmenu" border="0" cellSpacing="2" cellPadding="0" xmlns:dc="http://purl.org/dc/elements/1.0/" id="table6">
		</table>
		</td>
	</tr>
</table>
<table border="0" width="100%" id="table1" cellspacing="0" cellpadding="0" style="border-left-width: 0px; border-right-width: 0px; border-bottom-width: 0px">
	<tr>
		<td>
		&nbsp;</td>
	</tr>
	<tr>
		<td>
		&nbsp;</td>
	</tr>
	<tr>
		<td>
		<table id="table9" cellSpacing="0" cellPadding="0" width="100%" border="0">
			<tr>
				<td vAlign="top" height="518">
				<table id="table8" cellSpacing="0" cellPadding="7" width="90%" border="0" xmlns:dc="http://purl.org/dc/elements/1.0/">
					<tr>
						<td vAlign="center" width="1%" rowSpan="2">&nbsp;</td>
						<td class="b24-toc1" vAlign="top" noWrap width="9%" rowSpan="2">
						<b><font face="Arial" color="#666633" size="2">
						<span style="TEXT-DECORATION: none">Chapter 1</span></font></b></td>
						<td align="middle" width="1%" rowSpan="2">
						<font face="Arial" size="2">-</font></td>
						<td style="BORDER-TOP: 1px solid" width="61%">
						<p dir="ltr" align="right"><b>
						<font face="Tahoma" size="2">Encryption &amp; Decryption for 
						Payloads</font></b></td>
					</tr>
					<tr>
						<td style="BORDER-BOTTOM: 1px solid" width="61%">
						<ul>
							<li><b style="MARGIN: 0px">
							<font style="MARGIN: 0px" face="Tahoma" color="#000080" size="2">
							<a href="mk:@MSITStore:J:/Contents/Bypassing%20AVs%20by%20Csharp%20Programming%20v2.chm::/Chapter%201/Chapter1.htm">
							<font color="#000080">
							<span style="TEXT-DECORATION: none">1.1 Simple 
							Method for Execute Native Code in Memory via API 
							Programming</span></font></a></font></b><font face="Tahoma" size="2">
							</font>
							<ul>
								<li><b><span lang="fa">
								<font face="Tahoma" size="2">در این بخش اول از 
								فصل 1 شما با روش استفاده از توابع </font></span>
								<font face="Tahoma" size="2">API<span lang="fa"> 
								در ویندوز بصورت مقدماتی آشنا می شوید که چگونه می 
								توانید در سی شارپ توابع </span>API<span lang="fa"> 
								را </span>Call<span lang="fa"> کنید و روش معرفی 
								توابع در </span>Csharp<span lang="fa"> و همچنین 
								موارد </span>Cast<span lang="fa"> کردن </span>
								Argument <span lang="fa">های توابع ویندوز از 
								محیط </span>Unmanaged<span lang="fa"> به محیط
								</span>Managed <span lang="fa">در سی شارپ</span>.</font></b></li>
							</ul>
							</li>
							<li><b><font face="Tahoma" color="#000080" size="2">
							<span style="TEXT-DECORATION: none">
							<font color="#000080">
							<a href="mk:@MSITStore:J:/Contents/Bypassing%20AVs%20by%20Csharp%20Programming%20v2.chm::/Chapter%201/Chapter1.2.htm">
							<span style="TEXT-DECORATION: none">
							<font color="#000080">1.2 Encryption and Decryption 
							for payloads via RC4</font></span></a></font></span></font></b><font face="Tahoma" size="2">
							</font>
							<ul>
								<li><b><font face="Tahoma" size="2">
								<span lang="fa">در بخش 2 از فصل 1 ما بر روی روش
								</span>Encryption<span lang="fa"> برای </span>
								Payload<span lang="fa"> های </span>Meterpreter , CobaltStrike<span lang="fa"> صحبت می کنیم و روش
								</span>RC4<span lang="fa"> را بررسی می کنیم
								</span></font></b></li>
							</ul>
							</li>
							<li><b><font face="Tahoma" color="#000080" size="2">
							<a href="mk:@MSITStore:J:/Contents/Bypassing%20AVs%20by%20Csharp%20Programming%20v2.chm::/Chapter%201/Chapter1.3.htm">
							<span style="TEXT-DECORATION: none">
							<font color="#000080">1.3 Encryption and Decryption 
							for Payload of Suspended Thread via XOR</font></span></a></font></b><font face="Tahoma" size="2">
							</font>
							<ul>
								<li><b><font face="Tahoma" size="2">
								<span lang="fa">در این بخش 3 از فصل 1 ما بر روی 
								روش </span>Xor<span lang="fa"> کار می کنیم برای
								</span>Encryption <span lang="fa">و این روش
								</span>XOR<span lang="fa"> در بیشتر فصل های کتاب 
								از آن استفاده می شود و همچنین با توابع </span>
								</font></b><b style="MARGIN: 0px">
								<font style="MARGIN: 0px" face="Tahoma" color="#008000" size="2">
								VirtualAllocExNuma</font></b><b><font face="Tahoma" color="#808080" size="2"> 
								, </font>
								<font face="Tahoma" color="#008000" size="2"> 
								VirtualAlloc2</font><font face="Tahoma" color="#808080" size="2"> 
								</font>
								<font face="Tahoma" size="2"><span lang="fa">
								آشنا می شویم که می توان بجای </span>VirtualAlloc<span lang="fa"> 
								استفاده کرد در این بخش یک نمونه مثال زده می شود 
								که چگونه می توان یک </span>Thread<span lang="fa"> 
								را در حالت </span>Suspend<span lang="fa"> ایجاد&nbsp; 
								کرد سپس موارد داخل آن را </span>Encrypt/Decrypt<span lang="fa"> 
								کرد بخش بخش سپس دوباره آن </span>Thread
								<span lang="fa">را </span>Resume<span lang="fa"> 
								کرد .در این بخش همچنین با تابع </span>
								<font color="#008000">VirtualProtectEx</font><span lang="fa"> 
								آشنا می شویم.</span></font></b></li>
							</ul>
							</li>
						</ul>
						</td>
					</tr>
					<tr>
						<td vAlign="center" width="1%" rowSpan="2">
						<font face="Arial">
						<img height="1" alt="" width="1" border="0"></font></td>
						<td class="b24-toc1" vAlign="top" noWrap width="9%" rowSpan="2">
						<b><font face="Arial" color="#666633" size="2">
						<span style="TEXT-DECORATION: none">Chapter 2</span></font></b></td>
						<td align="middle" width="1%" rowSpan="2">
						<font face="Arial" size="2">-</font></td>
						<td style="BORDER-TOP: 1px solid" width="61%">
						<p dir="ltr" align="right"><b>
						<font face="Tahoma" size="2">Executing Native Codes in 
						Local Process</font></b></td>
					</tr>
					<tr>
						<td style="BORDER-BOTTOM: 1px solid" width="61%">
						<ul>
							<li><b style="MARGIN: 0px">
							<font style="MARGIN: 0px" face="Tahoma" color="#000080" size="2">
							<a href="mk:@MSITStore:J:/Contents/Bypassing%20AVs%20by%20Csharp%20Programming%20v2.chm::/Chapter%202/Chapter2.1.htm">
							<span style="TEXT-DECORATION: none">
							<font color="#000080">2.1 Local Thread Injection 
							Classic Method and Indirect/Direct Technique D</font></span></a></font></b><font face="Tahoma" size="2">
							</font>
							<ul>
								<li><b><font face="Tahoma" size="2">
								<span lang="fa">در این بخش </span>1<span lang="fa"> 
								از فصل </span>2 <span lang="fa">ما تکنیکی جدید 
								را در سی شارپ بررسی می کنیم بنام </span>
								<font color="#008000">Technique D</font><span lang="fa"> 
								و در این روش شما به عنوان </span>Pentester,<span lang="fa">
								</span>RedTeamer<span lang="fa"> با موردی جدید 
								آشنا می شوید برای </span>Bypass<span lang="fa"> 
								کردن آنتی ویروسهایی مانند </span>Kaspersky , 
								Defender<span lang="fa"> . این روش را می توان 
								بصورت </span>Direct<span lang="fa"> اجرا کرد
								</span>In-memory<span lang="fa"> اما تکنیک جدید 
								دیگری را با آن آشنا خواهید شد که بصورت غیره 
								مستقیم کد </span>In-memory<span lang="fa"> اجرا 
								می شود و<font color="#008000"> </font></span>
								Indirect Technique D<span lang="fa"> نام گذاری 
								شده توسط من . در ایجا شما با هر دو نوع </span>
								<font color="#008000">Direct/Indirect<span lang="fa">
								</span>Technique D</font><span lang="fa"> آشنا 
								می شوید. در این فصل شما با روشهای جدید آشنا می 
								شوید که بدون استفاده از توابع ویندوز می توان کدی 
								در </span>Csharp<span lang="fa"> نوشت که نتیجه 
								یکسان داشته باشد.</span></font></b></li>
							</ul>
							</li>
							<li><b><font face="Tahoma" color="#000080" size="2">
							<span style="TEXT-DECORATION: none">
							<a href="mk:@MSITStore:J:/Contents/Bypassing%20AVs%20by%20Csharp%20Programming%20v2.chm::/Chapter%202/Chapter2.2.htm">
							<span style="TEXT-DECORATION: none">
							<font color="#000080">2</font></span></a></span></font></b><a href="mk:@MSITStore:J:/Contents/Bypassing%20AVs%20by%20Csharp%20Programming%20v2.chm::/Chapter%202/Chapter2.2.htm"><b style="MARGIN: 0px"><font style="MARGIN: 0px" face="Tahoma" color="#000080" size="2"><span style="TEXT-DECORATION: none">.2
							</span></font></b>
							<font face="Tahoma" color="#000080" size="2"><b>
							<span style="TEXT-DECORATION: none">QueueUserAPC API 
							Methods and Indirect/Direct Technique D</span></b></font></a><font face="Tahoma" size="2">
							</font>
							<ul>
								<li><b><font face="Tahoma" size="2">
								<span lang="fa">در این بخش </span>2<span lang="fa"> 
								از فصل </span>2 <span lang="fa">روش اجرای کد 
								توسط تابع </span><font color="#008000">
								QueueUserAPC</font><span lang="fa"> را بررسی می 
								کنیم و نتیجه استفاده از آن را بر روی </span>
								Technique D<span lang="fa"> مرور می کنیم که 
								چگونه آنتی ویروس هایی مانند </span>Kaspersky<span lang="fa">
								</span>, Defender<span lang="fa"> توسط این روش
								</span>Bypass<span lang="fa"> می شوند</span></font></b></li>
							</ul>
							</li>
							<li>
							<a href="mk:@MSITStore:J:/Contents/Bypassing%20AVs%20by%20Csharp%20Programming%20v2.chm::/Chapter%202/Chapter2.3.htm">
							<b><font face="Tahoma" color="#000080" size="2">
							<span style="TEXT-DECORATION: none">2</span></font></b><font style="MARGIN: 0px" face="Tahoma" color="#000080" size="2"><span style="TEXT-DECORATION: none"><b style="MARGIN: 0px">.3 
							QueueUserAPC Classic Method</b></span></font></a><font face="Tahoma" size="2">
							</font>
							<ul>
								<li><b><font face="Tahoma" size="2">
								<span lang="fa">در این بخش </span>3<span lang="fa"> 
								از فصل </span>2 <span lang="fa">روش</span>
								<span lang="fa">استفاده از </span>API Monitor<span lang="fa"> 
								را برای کار در زمان </span>Research<span lang="fa"> 
								کردن را بررسی می کنیم همچنین از این ابزار برای 
								بررسی تکنیک </span>Classic<span lang="fa"> مربوط 
								به </span>QueueUserAPC<span lang="fa"> استفاده 
								می کنیم و با تابع جدید </span>
								</font>
								<font face="Tahoma" size="2" color="#008000">
								NtQueueApcThread<span lang="fa"> </span></font>
								<span lang="fa"><font face="Tahoma" size="2">
								آشنا می شویم.</font></span></b></li>
							</ul>
							</li>
						</ul>
						</td>
					</tr>
					<tr>
						<td vAlign="center" width="1%" rowSpan="2">
						<font face="Arial">
						<img height="1" alt="" width="1" border="0"></font></td>
						<td class="b24-toc1" vAlign="top" noWrap width="9%" rowSpan="2">
						<b><font face="Arial" color="#666633" size="2">
						<span style="TEXT-DECORATION: none">Chapter 3</span></font></b></td>
						<td align="middle" width="1%" rowSpan="2">
						<font face="Arial" size="2">-</font></td>
						<td style="BORDER-TOP: 1px solid" width="61%">
						<p dir="ltr" align="right"><b>
						<font face="Tahoma" size="2">Executing Native Codes in 
						Local Process (Part2)</font></b></td>
					</tr>
					<tr>
						<td style="BORDER-BOTTOM: 1px solid" width="61%">
						<ul>
							<li><b style="MARGIN: 0px">
							<font style="MARGIN: 0px" face="Tahoma" color="#000080" size="2">
							<a href="mk:@MSITStore:J:/Contents/Bypassing%20AVs%20by%20Csharp%20Programming%20v2.chm::/Chapter%203/Chapter3.1.htm">
							<span style="TEXT-DECORATION: none">
							<font color="#000080">3.1 Simple Method for Execute 
							Native Code in Memory + JMP Method1</font></span></a></font></b><font face="Tahoma" size="2">
							</font>
							<ul>
								<li><b>
								<font face="Tahoma" size="2"><span lang="fa">
								در این بخش اول فصل 
								3 یک Trick خیلی ساده را با هم کار می کنیم که به
								<font color="#008000">Jump</font> معروف می باشد 
								و یا همان پرش <br>
								از بخشی از کد در Memory به بخشی دیگر</span>
								<span lang="fa">در </span>Memory<span lang="fa"> 
								این کار می تواند موجب گیج شدن برخی آنتی ویروس ها 
								شود و برای دور زدن<br>
								آنها می تواند مفید باشد</span>
								<span lang="fa">مانند </span>Defender.<span lang="fa">
								</span></font></b> </li>
							</ul>
							</li>
							<li><b style="MARGIN: 0px">
							<font style="MARGIN: 0px" face="Tahoma" color="#000080" size="2">
							<a href="mk:@MSITStore:J:/Contents/Bypassing%20AVs%20by%20Csharp%20Programming%20v2.chm::/Chapter%203/Chapter3.2.htm">
							<font color="#000080">
							<span style="TEXT-DECORATION: none">3.2 Simple 
							Method for Execute Native Code in Memory + Delegate 
							Method + JMP Method1</span></font></a></font></b><ul>
								<li><b><font face="Tahoma" size="2">
								<span lang="fa">در این بخش </span>2<span lang="fa"> 
								از فصل 3&nbsp; ما همان روش بخش قبلی را استفاده 
								می کنیم اما با تکنیکی دیگر برای اجرا </span>Jump<span lang="fa"> 
								کد خود و بجای </span>CreateThread<span lang="fa"> 
								از روش </span>Technique D<span lang="fa"> کمک می 
								گیریم برای اجرای غیره مستقیم کدهای </span>Jump<span lang="fa"> 
								خود</span>. </font></b> 
								</li>
							</ul>
							</li>
							<li><b style="MARGIN: 0px">
							<font style="MARGIN: 0px" face="Tahoma" color="#000080" size="2">
							<a href="mk:@MSITStore:J:/Contents/Bypassing%20AVs%20by%20Csharp%20Programming%20v2.chm::/Chapter%203/Chapter3.3.htm">
							<font color="#000080">
							<span style="TEXT-DECORATION: none">3.3 Simple 
							Method for Execute Native Code in Memory + Delegate 
							Method + JMP Method1-Part2</span></font></a></font></b><ul>
								<li><b><font face="Tahoma" size="2">
								<span lang="fa">در این بخش </span>3
								<span lang="fa">از فصل 3 که در ادامه بخش قبلی می 
								باشد</span>
								<span lang="fa">روشی جدید را برای
								</span>Write<span lang="fa"> کردن در </span>
								Memory<span lang="fa"> را بررسی می کنیم و استفاده از </span>
								<font color="#008000">Marshal.writebyte</font><span lang="fa"> 
								را بجای </span><font color="#008000">
								Marshal.copy</font><span lang="fa"> بررسی می 
								کنیم.</span></font></b></li>
							</ul>
							</li>
							<li><b style="MARGIN: 0px">
							<font style="MARGIN: 0px" face="Tahoma" color="#000080" size="2">
							<a href="mk:@MSITStore:J:/Contents/Bypassing%20AVs%20by%20Csharp%20Programming%20v2.chm::/Chapter%203/Chapter3.4.htm">
							<font color="#000080">
							<span style="TEXT-DECORATION: none">3.4 Indirect 
							Call C# Methods in Memory via Reflection.Emit Jump 
							Method </span></font></a></font></b>
							<ul>
								<li><b><font face="Tahoma" size="2">
								<span lang="fa">در این بخش چهارم از فصل سوم ما</span>
								<span lang="fa">روش جدیدی را کار خواهیم کرد برای 
								Jump کردن به آدرس شروع یک C# Method بدون استفاده
								<br>
								کردن از کدهای Asm بر روی Source Code در نتیجه 
								بصورت غیره مستقیم یک C# Method بر روی حافظه اجرا 
								می شود یا In-memory اجرا <br>
								می شود بدون آنکه ما در کد آن C# Method را Call 
								کنیم. در نتیجه این روش جدید
								<font color="#008000">Indirect Call C# Methods 
								in-memory </font>نام دارد . <br>
								در این روش جدید ما از بایتهای اسمبلی برای </span>
								Jump<span lang="fa">استفاده نمی کنیم بلکه بجای 
								آن ازامکان Reflection.Emit که یک Class در csharp 
								می باشد استفاده می کنیم و در آخر </span>Bypass<span lang="fa"> 
								کردن آنتی ویروس </span>Defender<span lang="fa"> 
								را خواهیم داشت.</span></font></b></li>
							</ul>
							</li>
							<li><b><font face="Tahoma" color="#000080" size="2">
							<a href="mk:@MSITStore:J:/Contents/Bypassing%20AVs%20by%20Csharp%20Programming%20v2.chm::/Chapter%203/Chapter3.5.htm">
							<font color="#000080">
							<span style="TEXT-DECORATION: none">3.5 Running C# 
							Managed Codes in Memory via CreateThread API</span></font></a></font></b><font face="Tahoma" size="2">
							</font>
							<ul>
								<li><b><font face="Tahoma" size="2">
								<span lang="fa">در این بخش پنجم از فصل سوم یک 
								تکنیک برای اجرای کد Managed توسط CreateThread 
								API را بررسی می کنیم . <br>
								تا اینجا همانطور که در فصلهای قبلی مشاهده کردید 
								ما از تابع CreateThread استفاده می کردیم برای 
								اجرای کدهای Native یا Unmanaged Code که همان&nbsp; 
								کدهای Shell ما بیشتر می بود یا برای اجرای یک 
								Jump Method اما شما می توانید از CreateThread 
								برای اجرای کدهای Managed نیز استفاده کنید. این 
								Managed Code شما می تواند یک FunctionPointer 
								باشد که اشاره می کند به یک C# Delegate و</span></font></b></li>
								<li><b><font face="Tahoma" size="2">
								<span lang="fa">&nbsp;یا یک C# Method . </span> </font></b></li>
							</ul>
							</li>
						</ul>
						</td>
					</tr>
					<tr>
						<td vAlign="center" width="1%" rowSpan="2">
						<font face="Arial">
						<img height="1" alt="" width="1" border="0"></font></td>
						<td class="b24-toc1" vAlign="top" noWrap width="9%" rowSpan="2">
						<b><font face="Arial" color="#666633" size="2">
						<span style="TEXT-DECORATION: none">Chapter 4</span></font></b></td>
						<td align="middle" width="1%" rowSpan="2">
						<font face="Arial" size="2">-</font></td>
						<td style="BORDER-TOP: 1px solid" width="61%">
						<p dir="ltr" align="right"><b>
						<font face="Tahoma" size="2">Executing Native Codes in 
						Local Process (Part3)</font></b></td>
					</tr>
					<tr>
						<td style="BORDER-BOTTOM: 1px solid" width="61%">
						<ul>
							<li><b><font face="Tahoma" color="#000080" size="2">
							<a href="mk:@MSITStore:J:/Contents/Bypassing%20AVs%20by%20Csharp%20Programming%20v2.chm::/Chapter%204/Chapter4.1.htm">
							<font color="#000080">
							<span style="TEXT-DECORATION: none">4.1 New Approach 
							with New APIs to Execute Payloads in Memory + Async 
							Method and Bypassing Kaspersky</span></font></a></font></b><font face="Tahoma" size="2">
							</font>
							<ul>
								<li><b><font face="Tahoma" size="2">
								<span lang="fa">در این فصل 4 که ادامه فصل 2 و 3 
								می باشد ما مواردی دیگر را برای اجرای کد Native 
								بر روی Local Process را بررسی می کنیم <br>
								اما در فصل 4 رویکرد ما در کد برای اجرا با کدهای 
								فصلهای 2 و 3 متفاوت می باشد به همین دلیل مطالب 
								این فصل از فصلهای 2 و 3 جدا شده منظور از رویکرد 
								متفاوت در اینجا استفاده از روش های جدید برای 
								اجرای کد می باشد و سعی بر اینکه کد ها جدید تر 
								باشد <br>
								برای مثال وقتی شما می خواهید مقداری همانند یک 
								Byte Array را در حافظه قرار دهید در کدها ما از 
								VirtualAlloc استفاده می کردیم <br>
								این رویکردی می باشد که در همه کدها تقریبا وجود 
								داشت و شما آن را نیز در کد های Public هم مشاهده 
								می کردید که <br>
								معمولا تمامی Red Teamer ها و Pentester ها از 
								توابعی همانند آن استفاده می کردند و این موجب شده 
								بود تا تمامی آنتی ویروس ها <br>
								بر روی این توابع حساس شوند توابعی همانند 
								VirtualAlloc یا WriteProcessMemory و یا 
								CreateThread و ... <br>
								رویکرد جدید در اینجا یعنی انجام دادن همان 
								کارهایی که این کد ها و توابع برای ما انجام می 
								دادند بدون استفاده از آنها <br>
								و استفاده کردن از توابع جدید که کاری مشابه آنها 
								را انجام می دهند و یا استفاده از تکنیک هایی که 
								موجب می شود <br>
								شما نتیجه مشابه بگیرید اما کد شما متفاوت باشد در 
								نتیجه رفتار کد متفاوت می شود و Signature کد 
								همینطور و شما <br>
								با این رویکرد جدید می توانید آنتی ویروس ها را 
								Bypass کنید </span> </font></b> 
								</li>
							</ul>
							</li>
							<li><b>
							<a href="mk:@MSITStore:J:/Contents/Bypassing%20AVs%20by%20Csharp%20Programming%20v2.chm::/Chapter%204/Chapter4.2.htm">
							<font face="Tahoma" color="#000080" size="2">
							<span style="TEXT-DECORATION: none">4.2 Indirect 
							Invoke C# Delegate + JMP Method2</span></font></a></b><font face="Tahoma" size="2">
							</font>
							<ul>
								<li><b><font face="Tahoma" size="2">
								<span lang="fa">در این فصل 4 که بخش 2 روشی جدید 
								را برای Jump کردن را با کمک روش Technique D اجرا 
								می کنیم و شما مشاهده <br>
								خواهید کرد که چگونه Kaspersky v21 و Windows 
								Defender با این روش Bypass می شوند . <br>
								در این تکنیک جدید من از VirtualAlloc استفاده 
								کرده ام اما بعد تست کد با آن این تابع را به
								<font color="#008000">Marshal.AllocHGlobal</font> 
								تغییر می دهیم <br>
								در نتیجه ما 2 ورژن از این کد خواهیم داشت یکی با 
								VirtualAlloc و دیگری با رویکرد جدید ما با توابعی 
								جدید که کار یکسان را انجام <br>
								می دهند.</span></font></b></li>
							</ul>
							</li>
							<li><b><font face="Tahoma" color="#000080" size="2">
							<a href="mk:@MSITStore:J:/Contents/Bypassing%20AVs%20by%20Csharp%20Programming%20v2.chm::/Chapter%204/Chapter4.3.htm">
							<font color="#000080">
							<span style="TEXT-DECORATION: none">4.3 Chunking 
							CobaltStrike Payloads + Jump Method and Bypassing 
							Kaspersky</span></font></a></font><font face="Tahoma" size="2">
							</font> </b>
							<ul>
								<li><b><font face="Tahoma" size="2">
								<span lang="fa">در این بخش 3 از فصل چهارم تکنیکی 
								را بررسی می کنیم برای Chunk کردن Payload ها یا 
								جدا کردن Payload ها را بررسی می کنیم. <br>
								با کمک این روش جداکردن Payload در Memory شما 
								مشاهده خواهید کرد که چگونه Kaspersky دورزده می 
								شود . </span> </font></b> 
								</li>
							</ul>
							</li>
						</ul>
						</td>
					</tr>
					<tr>
						<td vAlign="center" width="1%" rowSpan="2">
						<font face="Arial">
						<img height="1" alt="" width="1" border="0"></font></td>
						<td class="b24-toc1" vAlign="top" noWrap width="9%" rowSpan="2">
						<b><font face="Arial" color="#666633" size="2">
						<span style="TEXT-DECORATION: none">Chapter 5</span></font></b></td>
						<td align="middle" width="1%" rowSpan="2">
						<font face="Arial" size="2">-</font></td>
						<td style="BORDER-TOP: 1px solid" width="61%"><b>
						<font face="Tahoma" size="2">Executing Native Code in 
						Remote Process</font></b></td>
					</tr>
					<tr>
						<td style="BORDER-BOTTOM: 1px solid" width="61%">
						<ul>
							<li><b style="MARGIN: 0px">
							<font style="MARGIN: 0px" face="Tahoma" color="#000080" size="2">
							<span style="TEXT-DECORATION: none">
							<a href="mk:@MSITStore:J:/Contents/Bypassing%20AVs%20by%20Csharp%20Programming%20v2.chm::/Chapter%205/Chapter5.1.htm">
							<font color="#000080">
							<span style="TEXT-DECORATION: none">5.1 Remote 
							Thread Injection Classic</span></font></a></span></font></b><font face="Tahoma" size="2">
							</font>
							<ul>
								<li><b><font face="Tahoma" size="2">
								<span lang="fa">در این فصل 5 ما بر روی Remote 
								Thread Injection کار خواهیم کرد در این بخش 1 ما 
								اول باید <br>
								روش Classic این تکنیک را یاد بگیریم که بسیار مهم 
								می باشد حتی اگر کد قدیمی باشد و الان دیگر ممکن 
								می باشد <br>
								بر روی برخی آنتی ویروس ها کارایی نداشته باشد اما 
								به عنوان Pentester /Red-Blue Teamer شما باید این 
								روش <br>
								را یاد بگیربد بدلیل اینکه کاربردی می باشد با 
								اینکه ممکن می باشد کد قدیمی باشد و بیشتر AV ها 
								آن را شناسایی کنند. </span> </font></b> 
								</li>
							</ul>
							</li>
							<li><b style="MARGIN: 0px">
							<font style="MARGIN: 0px" face="Tahoma" color="#000080" size="2">
							<span style="TEXT-DECORATION: none">
							<font color="#000080">
							<a href="mk:@MSITStore:J:/Contents/Bypassing%20AVs%20by%20Csharp%20Programming%20v2.chm::/Chapter%205/Chapter5.2.htm">
							<font color="#000080">
							<span style="TEXT-DECORATION: none">5.2</span></font></a></font></span></font></b><b><a href="mk:@MSITStore:J:/Contents/Bypassing%20AVs%20by%20Csharp%20Programming%20v2.chm::/Chapter%205/Chapter5.2.htm"><font face="Tahoma" color="#000080" size="2"><font color="#000080"><span style="TEXT-DECORATION: none"> 
							Remote Thread Injection + Delegate Method </span>
							</font><span style="TEXT-DECORATION: none">and 
							bypassing Defender</span></font></a></b><font face="Tahoma" size="2">
							</font>
							<ul>
								<li><b><font face="Tahoma" size="2">
								<span lang="fa">در بخش 2 از فصل پنجم ما در مورد 
								روش استفاده از Function Pointer و Delegate در 
								Csharp را بررسی می کنیم <br>
								توسط این روش بدون Import کردن توابعی مثل 
								VirtualAllocEx /WriteProcessMemory / 
								CreateRemoteThread شما می توانید <br>
								در کد از آنها استفاده کنید و این کمک می کند به 
								شما برای Bypass کردن آنتی ویروس ها همانند 
								Windows Defender </span></font></b></li>
							</ul>
							</li>
							<li><b><font face="Tahoma" color="#000080" size="2">
							<span style="TEXT-DECORATION: none">
							<font color="#000080">
							<a href="mk:@MSITStore:J:/Contents/Bypassing%20AVs%20by%20Csharp%20Programming%20v2.chm::/Chapter%205/Chapter5.3.htm">
							<font color="#000080">
							<span style="TEXT-DECORATION: none">5.3 Remote 
							Thread Injection + Jump Method and Bypassing 
							Kaspersky + Defender</span></font></a></font></span></font></b><font face="Tahoma" size="2">
							</font>
							<ul>
								<li><b><font face="Tahoma" size="2">
								<span lang="fa">در بخش 3 از فصل پنجم از روش 
								Classic استفاده می کنیم تا یک New Thread ایجاد 
								کنیم <br>
								اما Paylaod درون این New Thread ما یک Jump کد می 
								باشد به یک آدرس A دیگر در حافظه که <br>
								در آن آدرس A ما یک Jump code دیگر داریم که اشاره 
								می کند به آدرس B که همان CobaltStrike Paylaod ما 
								می باشد <br>
								در نتیجه مشاهده می کنید که توسط این تکنیک ما 
								بصورت Indirect کد مربوط به CobaltStrike Payload 
								را اجرا می کنیم <br>
								در نتیجه ما از CreateRemoteThread استفاده کرده 
								ایم در کد اما به دلیل اینکه در کد ما این تابع 
								قرار می باشد یک Jump code <br>
								را اجرا کند و نه یک Payload برای CobaltStrike را 
								در نتیجه توسط آنتی ویروس کد شناسایی نمی شود </span> </font></b> 
								</li>
							</ul>
							</li>
						</ul>
						</td>
					</tr>
					<tr>
						<td vAlign="center" width="1%" rowSpan="2">
						<font face="Arial">
						<img height="1" alt="" width="1" border="0"></font></td>
						<td class="b24-toc1" vAlign="top" noWrap width="9%" rowSpan="2">
						<b><font face="Arial" color="#666633" size="2">
						<span style="TEXT-DECORATION: none">Chapter 6</span></font></b></td>
						<td align="middle" width="1%" rowSpan="2">
						<font face="Arial" size="2">-</font></td>
						<td style="BORDER-TOP: 1px solid" width="61%">
						<p dir="ltr" align="right"><b>
						<font face="Tahoma" size="2">[X technique] via Extension 
						Methods in C#</font></b></td>
					</tr>
					<tr>
						<td style="BORDER-BOTTOM: 1px solid" width="61%">
						<ul>
							<li><b style="MARGIN: 0px">
							<font style="MARGIN: 0px" face="Tahoma" color="#000080" size="2">
							<a href="mk:@MSITStore:J:/Contents/Bypassing%20AVs%20by%20Csharp%20Programming%20v2.chm::/Chapter%206/Chapter6.1.htm">
							<font color="#000080">
							<span style="TEXT-DECORATION: none">6.1 X Technique, 
							Changing Codes via Extension Method</span></font></a></font></b><font face="Tahoma" size="2">
							</font>
							<ul>
								<li><b><font face="Tahoma" size="2">
								<span lang="fa">در فصل 6 روشی را معرفی می کنم که 
								توسط آن شما می توانید کد سی شارپ خود را تغییر 
								بدهید تا دارای یک Signature جدید <br>
								بشود و به شما کمک می کند در Bypass کردن آنتی 
								ویروس ها مخصوصا در زمانی که کد شما را بر روی 
								Harddisk شناسایی می کنند <br>
								من نام این روش را که برای اولین بار در نسخه 1.0 
								همین کتاب معرفی شده X Technique نام گذاری کرده 
								ام . در واقع من توسط این روش جدید سعی کرده ام با 
								کمک Extension ها در Csharp کد هایی که معمولا بر 
								روی هاردیسک شناسایی می شوند را جوری تغییر بدهم 
								که Signature کد تغییر کند و رفتار کد کمی تغییر 
								کند اما نتیجه کد یکسان باشد با زمان قبل از تغییر 
								کد در نتیجه این روش یکجور پیچیده کردن کد می توان 
								نام برد اما شاید پیچیده برای آنتی ویروس ها و نه 
								برای برنامه نویسان در نتیجه شما به عنوان برنامه 
								نویس کد می توانید آن را متوجه شوید . </span> </font></b> 
								</li>
							</ul>
							</li>
						</ul>
						</td>
					</tr>
					<tr>
						<td vAlign="center" width="1%" rowSpan="2">
						<font face="Arial">
						<img height="1" alt="" width="1" border="0"></font></td>
						<td class="b24-toc1" vAlign="top" noWrap width="9%" rowSpan="2">
						<b><font face="Arial" color="#666633" size="2">
						<span style="TEXT-DECORATION: none">Chapter 7</span></font></b></td>
						<td align="middle" width="1%" rowSpan="2">
						<font face="Arial" size="2">-</font></td>
						<td style="BORDER-TOP: 1px solid" width="61%"><b>
						<font face="Tahoma" size="2">Sliver C2 and your Csharp 
						Codes</font></b></td>
					</tr>
					<tr>
						<td style="BORDER-BOTTOM: 1px solid" width="61%">
						<ul>
							<li><b style="MARGIN: 0px">
							<font style="MARGIN: 0px" face="Tahoma" color="#000080" size="2">
							<a href="mk:@MSITStore:J:/Contents/Bypassing%20AVs%20by%20Csharp%20Programming%20v2.chm::/Chapter%207/Chapter7.1.htm">
							<font color="#000080">
							<span style="TEXT-DECORATION: none">7.1 When Sliver 
							C2 Payloads is Good to Use , When is not</span></font></a></font></b><a href="mk:@MSITStore:J:/Contents/Bypassing%20AVs%20by%20Csharp%20Programming%20v2.chm::/Chapter%207/Chapter7.1.htm"><b><font face="Tahoma" size="2" color="#000080"><span style="text-decoration: none">
							</span></font></b></a><font face="Tahoma" size="2">
							&nbsp;</font><ul>
								<li><b><font face="Tahoma" size="2">
								<span lang="fa">در فصل 7 من فقط در مورد روشهای 
								استفاده از Sliver-C2 صحبت می کنم و نه Csharp 
								codes.در این کتاب از فصل 1 تا 6 من از Sliver_C2 
								استفاده نکرده ام که باید بگم این C2 Server بسیار 
								مفید و تکنیکی می باشد و از نظر من بهتر از 
								CobaltStrike می باشد به یک دلیل ساده و آن اینکه 
								Open-source و FREE می باشد. </span> </font></b> </li>
							</ul>
							</li>
							<li><b style="MARGIN: 0px">
							<font style="MARGIN: 0px" face="Tahoma" color="#000080" size="2">
							<a href="mk:@MSITStore:J:/Contents/Bypassing%20AVs%20by%20Csharp%20Programming%20v2.chm::/Chapter%207/Chapter7.2.htm">
							<span style="TEXT-DECORATION: none">
							<font color="#000080">7.2 Sliver-C2 Beacon with mTLS 
							Payloads</font></span></a></font></b><font face="Tahoma" size="2">
							</font>
							<ul>
								<li><b><font face="Tahoma" size="2">
								<span lang="fa">در این بخش 2 من روشی ساده برای 
								ایجاد Beacon توسط mTLS را بر روی Sliver-C2 مثال 
								می زنم و روش استفاده <br>
								از آن با کمک کد سی شارپ </span> </font></b> </li>
							</ul>
							</li>
							<li><b style="MARGIN: 0px">
							<font style="MARGIN: 0px" face="Tahoma" color="#000080" size="2">
							<a href="mk:@MSITStore:J:/Contents/Bypassing%20AVs%20by%20Csharp%20Programming%20v2.chm::/Chapter%207/Chapter7.3.htm">
							<font color="#000080">
							<span style="TEXT-DECORATION: none">7.3 Sliver-C2 
							Beacon with Https Payloads</span></font></a></font></b><font face="Tahoma" size="2">
							</font>
							<ul>
								<li><b><font face="Tahoma" size="2">
								<span lang="fa">در این بخش 3 استفاده از </span>
								Beacon<span lang="fa"> را برای ترافیک </span>
								HTTP<span lang="fa">/</span>S<span lang="fa"> بر 
								روی </span>Sliver-c2<span lang="fa"> توسط</span> 
								Csharp <span lang="fa">را بررسی می کنیم</span></font></b></li>
							</ul>
							</li>
							<li><b style="MARGIN: 0px">
							<font style="MARGIN: 0px" face="Tahoma" color="#000080" size="2">
							<a href="mk:@MSITStore:J:/Contents/Bypassing%20AVs%20by%20Csharp%20Programming%20v2.chm::/Chapter%207/Chapter7.4.htm">
							<font color="#000080">
							<span style="TEXT-DECORATION: none">7.4 Using 
							Resource for Hardcoding Big Sliver-C2 Payloads</span></font></a></font></b><font face="Tahoma" size="2">
							</font>
							<p><b><font face="Tahoma" size="2"><span lang="fa">
							یکی از مواردی که Sliver-C2 payload را با 
							CobaltStrike Paylaod متفاوت می کند Size آنها می باشد
							<br>
							در این بخش 4 از فصل 7 من یک روش ساده و بسیار مفید را 
							برای شما شرح می دهم تا بتوانید Payload های Sliver-c2
							<br>
							براحتی در کد استفاده کنید به عنوان Resource و البته 
							در این روش حجم Exe شما بزرگ می شود بدلیل اینکه 
							Payload شما <br>
							بعنوان Resource در فایل Exe بصورت HardCode شده می 
							باشد و شما می توانید برای جلوگیری کردن از شناسایی 
							Payload در <br>
							فایل Exe آن را با Xor بصورت Encrypt کنید و سپس 
							Hardcode کنید که این روش Xor کردن فایلهای Bin را در 
							بخش بعدی شرح خواهم داد <br>
							اما در این بخش روش ایجاد Resource و اضافه کردن فایل 
							Bin را با هم بررسی می کنیم . </span></font></b>
							</li>
							<li><b style="MARGIN: 0px">
							<font style="MARGIN: 0px" face="Tahoma" color="#000080" size="2">
							<a href="mk:@MSITStore:J:/Contents/Bypassing%20AVs%20by%20Csharp%20Programming%20v2.chm::/Chapter%207/Chapter7.5.htm">
							<font color="#000080">
							<span style="TEXT-DECORATION: none">7.5 C# Code for 
							Encrypting Sliver-C2 Bin Files</span></font></a></font></b><font face="Tahoma" size="2">
							</font>
							<ul>
								<li><b><font face="Tahoma" size="2">
								<span lang="fa">در</span> <span lang="fa">ادامه 
								بخش 4 در این بخش پنجم روشی ساده برای Encrypt 
								کردن Bin فایلهای Sliver-c2 را بررسی می کنیم <br>
								که توسط Xor انجام می شود و یک Key و این مورد 
								بشما کمک می کند اگر خواستید فایل Bin را بر روی 
								Harddisk قرار دهید <br>
								و یا اینکه بر روی Exe فایل بعنوان یک Resource 
								بصورت HardCode داشته باشید در حالت Encrypt شده 
								باشد تا امکان شناسایی آن بسیار <br>
								کم شود و ریسک کار پایین باشد</span>.</font></b></li>
							</ul>
							</li>
							<li><b><font face="Tahoma" color="#000080" size="2">
							<a href="mk:@MSITStore:J:/Contents/Bypassing%20AVs%20by%20Csharp%20Programming%20v2.chm::/Chapter%207/Chapter7.6.htm">
							<span style="TEXT-DECORATION: none">
							<font color="#000080">7.6 Beacon Connections and 
							Active Connections in Sliver-C2</font></span></a></font></b><font face="Tahoma" size="2">
							</font>
							<ul>
								<li><b><font face="Tahoma" size="2">
								<span lang="fa">در</span> <span lang="fa">این 
								بخش 6 از فصل هفتم انواع Conecction های Sliver-C2 
								را بررسی می کنیم که نوع اول Beacon Mode می باشد
								<br>
								و نوع دوم Connection هایی می باشد که دیگر مانند 
								Beacon Mode نمی باشند یعنی دارای یک Network 
								Connection در حالت ثابت می باشند </span> </font></b> </li>
							</ul>
							</li>
							<li><b>
							<a href="mk:@MSITStore:J:/Contents/Bypassing%20AVs%20by%20Csharp%20Programming%20v2.chm::/Chapter%207/Chapter7.7.htm">
							<font face="Tahoma" color="#000080" size="2">
							<span style="TEXT-DECORATION: none">7.7 Bypassing 
							ETW and Execute .NET Assembly Codes</span></font></a></b><font face="Tahoma" size="2">
							</font>
							<ul>
								<li><b><font face="Tahoma" size="2">
								<span lang="fa">در این بخش 7 از فصل هفتم یک روش 
								ساده برای اجرای کدهای Dotnet در دررون Sliver 
								Process را بررسی می کنیم <br>
								شما با چیزی مانند این روش در فصل Chapter 3.4 
								آشنا شده اید در اینجا ما همان روش را در 
								Sliver-C2 توسط دستورات آن <br>
								بررسی می کنیم اما موردی که اینجا بیشتر بر روی آن 
								تمرکز می کنیم روشی می باشد برای از کار انداختن 
								ETW بر روی <br>
								Sliver Process یا همان Process هایی که Payload 
								مربوط به Sliver-c2 بر روی آنها اجرا شده . </span> </font></b> 
								</li>
							</ul>
							</li>
						</ul>
						</td>
					</tr>
					<tr>
						<td vAlign="center" width="1%" rowSpan="2">
						<font face="Arial">
						<img height="1" alt="" width="1" border="0"></font></td>
						<td class="b24-toc1" vAlign="top" noWrap width="9%" rowSpan="2">
						<b><font face="Arial" color="#666633" size="2">
						<span style="TEXT-DECORATION: none">Chapter 8</span></font></b></td>
						<td align="middle" width="1%" rowSpan="2">
						<font face="Arial" size="2">-</font></td>
						<td style="BORDER-TOP: 1px solid" width="61%">
						<p dir="ltr" align="right"><b>
						<font face="Tahoma" size="2">Native CallBack Functions by 
						C#</font></b></td>
					</tr>
					<tr>
						<td style="BORDER-BOTTOM: 1px solid" width="61%">
						<ul>
							<li><b style="MARGIN: 0px">
							<font style="MARGIN: 0px" face="Tahoma" color="#000080" size="2">
							<a href="mk:@MSITStore:J:/Contents/Bypassing%20AVs%20by%20Csharp%20Programming%20v2.chm::/Chapter%208/Chapter8.1.htm">
							<font color="#000080">
							<span style="TEXT-DECORATION: none">8.1 Native 
							CallBack Functions by Csharp</span></font></a></font></b><font face="Tahoma" size="2">
							</font>
							<ul>
								<li><b><font face="Tahoma" size="2">
								<span lang="fa">در فصل 8 ما با Callback 
								Functions آشنا می شویم و روش کار با آنها بر روی 
								Csharp. <br>
								در فصل های گذشته ما با مواردی همچون CreateThread 
								/ CreateRemoteThread / FunctionPointers آشنا 
								شدیم برای اجرای <br>
								کدها و بایتهای خود در Memory در این فصل تکنیکهای 
								جدیدی را برای اجرای Byte های خود در Memory را 
								بررسی <br>
								می کنیم که همانند توابع قبلی به ما کمک می کند 
								برای انجام این کار .</span></font></b></li>
							</ul>
							</li>
						</ul>
						</td>
					</tr>
					<tr>
						<td vAlign="center" width="1%" rowSpan="2">
						<font face="Arial">
						<img height="1" alt="" width="1" border="0"></font></td>
						<td class="b24-toc1" vAlign="top" noWrap width="9%" rowSpan="2">
						<b><font face="Arial" color="#666633" size="2">
						<span style="TEXT-DECORATION: none">Chapter 9</span></font></b></td>
						<td align="middle" width="1%" rowSpan="2">
						<font face="Arial" size="2">-</font></td>
						<td style="BORDER-TOP: 1px solid" width="61%">
						<p dir="ltr" align="right"><b>
						<font face="Tahoma" size="2">Compiling and Running 
						Managed Codes In-Memory by C#</font></b></td>
					</tr>
					<tr>
						<td style="BORDER-BOTTOM: 1px solid" width="61%">
						<ul>
							<li><b style="MARGIN: 0px">
							<font style="MARGIN: 0px" face="Tahoma" color="#000080" size="2">
							<a href="mk:@MSITStore:J:/Contents/Bypassing%20AVs%20by%20Csharp%20Programming%20v2.chm::/Chapter%209/Chapter9.1.htm">
							<span style="TEXT-DECORATION: none">
							<font color="#000080">9.1 Running C# Managed Codes 
							In-Memory by Csharp</font></span></a></font></b><font face="Tahoma" size="2">
							</font>
							<ul>
								<li><b><font face="Tahoma" size="2">
								<span lang="fa">در</span> <span lang="fa">فصل 9 مواردی بر روی 
								Csharp را بررسی می کنیم که بیشتر به NameSpace 
								System.Reflection بر می گردد و برای
								مواردی همچون&nbsp;
</span>Compiling C# Codes in-memory<span lang="fa">&nbsp;  کاربرد دارند و همچنین اجرای کدها و Exe های Dotnet که در اصطلاح به آنها Assembly گفته می شود در
 Dotnet و دلیل استفاده از این روشها و تکنیکها در Dotnet برای Red-teaming این می باشد که کدهای شما در Memory اجرا می شوند بصورت Dynamic بدون آنکه شناسایی بشوند بر روی Harddisk و این بسیار مهم می باشد در Bypass کردن برخی آنتی ویروسها. در این بخش اول از
 فصل 9 من یک نمونه کد بسیار ساده و بسیار مهم را معرفی می کنم که بسیار کاربرد دارد در Red-teaming و همچنین در نوشتن کدهای مانند C2 Server و یک نمونه مثال را با هم بررسی می کنیم که چگونه از این کد می توان در C2 Server هایی که با Dotnet و Csharp نوشته شده اند
 استفاده کرد.
</span></font></b></li>
							</ul>
							</li>
							<li><b style="MARGIN: 0px">
							<font style="MARGIN: 0px" face="Tahoma" color="#000080" size="2">
							<a href="mk:@MSITStore:J:/Contents/Bypassing%20AVs%20by%20Csharp%20Programming%20v2.chm::/Chapter%209/Chapter9.2.htm">
							<span style="TEXT-DECORATION: none">
							<font color="#000080">9.2 Running C# Managed Codes 
							In-Memory by C# , Part2</font></span></a></font></b><font face="Tahoma" size="2">
							</font>
							<ul>
								<li><b><font face="Tahoma" size="2">
								<span lang="fa">در فصل 9 بخش 2 ادامه 
								موارد فصل 9.1 را بررسی می کنیم و در اینجا چند 
								Trick ساده اما کاربردی برای Encrypt کردن <br>Exe فایل هایی که می خواهیم آنها را توسط تکنیکی 
								که در InMemoryRun وجود داشت اجرا کنیم بررسی می 
								کنیم و همچنین <br>روش گرفتن Exe فایلها از طریق شبکه و ترافیک Web 
								بجای خواندن Exe فایلها از روی Harddisk. </span></font>
								</b></li>
							</ul></li>
							<li><b><font face="Tahoma" color="#000080" size="2">
							<a href="mk:@MSITStore:J:/Contents/Bypassing%20AVs%20by%20Csharp%20Programming%20v2.chm::/Chapter%209/Chapter9.3.htm">
							<font color="#000080">
							<span style="TEXT-DECORATION: none">9.3 Compiling C# 
							Source Codes In-Memory by Csharp</span></font></a></font></b><font face="Tahoma" size="2">
							</font>
							<ul>
								<li><b><font face="Tahoma" size="2">
								<span lang="fa">در فصل 9 بخش 3 روشی را 
								بررسی می کنیم که بسیار قدیمی می باشد اما بسیار 
								کاربردی در Red Teaming. <br>در این روش شما می توانید بجای اجرای Exe فایل در 
								Memory یک C# Source Code را در In-Memory اول <br>آن را Compile کنید سپس اجرا کنید . در نتیجه در 
								این روش ما فقط یک Text فایل داریم یا یک سری Text 
								به عنوان <br>کد برای اجرا در Memory . درنتیجه شناسایی آنها در 
								Memory بسیار سخت می باشد برای آنتی ویروس ها .
								</span> </font></b></li>
							</ul></li>
						</ul>
						</td>
					</tr>
					<tr>
						<td vAlign="center" width="1%" rowSpan="2">
						<font face="Arial">
						<img height="1" alt="" width="1" border="0"></font></td>
						<td class="b24-toc1" vAlign="top" noWrap width="9%" rowSpan="2">
						<b><font face="Arial" color="#666633" size="2">
						<span style="TEXT-DECORATION: none">Chapter 10</span></font></b></td>
						<td align="middle" width="1%" rowSpan="2">
						<font face="Arial" size="2">-</font></td>
						<td style="BORDER-TOP: 1px solid" width="61%">
						<p dir="ltr" align="right"><b>
						<font face="Tahoma" size="2">Detecting Memory Allocation 
						in-memory via ETW Events (Blue team)</font></b></td>
					</tr>
					<tr>
						<td style="BORDER-BOTTOM: 1px solid" width="61%">
						<ul>
							<li><b style="MARGIN: 0px">
							<font style="MARGIN: 0px" face="Tahoma" color="#000080" size="2">
							<a href="mk:@MSITStore:J:/Contents/Bypassing%20AVs%20by%20Csharp%20Programming%20v2.chm::/Chapter%2010/Chapter10.1.htm">
							<font color="#000080">
							<span style="TEXT-DECORATION: none">10.1 ETW and 
							VirtualMemAlloc Events</span></font></a></font></b><font face="Tahoma" size="2">
							</font>
							<ul>
								<li><b><font face="Tahoma" size="2">
								در فصل 10 در بخش اول بر روی ETW Event Trace for 
								Windows کار می کنیم که بسیار مهم می باشد برای 
								Detection <br>
								مخصوصا برای تیم آبی در<span lang="fa">این فصل 10
								هدف من بیشتر بر روی Detection می باشد برای افراد
								<font color="#008000">Blue team</font> و به عنوان Pentester <br>
								و یا Red teamer شما باید بدانید یکی از هدفهای 
								کار ما کمک به افراد تیم آبی می باشد برای بهتر 
								شدن کار تیم آبی و کمک به آنها <br>
								در شناسایی خطرات در شبکه و این کمک کردن به تیم 
								آبی در واقع فلسفه وجود تیم قرمز می باشد. در این 
								فصل من بیشتر تمرکز می کنم بر روی مواردی همچون 
								برنامه نویسی برای افراد تیم آبی و نوشتن کد برای 
								Detect کردن برخی از کدهای که در همین کتاب آنها 
								را بررسی کردیم .</span>  <span lang="fa">در این 
								فصل روش استفاده از دو ابزار </span>ETWProcessMon 
								v1.1<span lang="fa"> و </span>VirtualMemAllocMon 
								v1.1<span lang="fa"> را بررسی می کنیم و آشنا می 
								شوید با رویکرد استفاده از </span>ETW Events<span lang="fa">&nbsp; 
								در این دو ابزار قدم به قدم برای </span>Detect<span lang="fa"> 
								کردن </span><font color="#008000">Jump Byte</font><span lang="fa"> 
								ها در حافظه و همچنین چگونگی استفاده از این دو 
								ابزار و استفاده از&nbsp; </span>ETW 
								VirtualMemAlloc Events<span lang="fa"> برای 
								شناسایی بایتهای مربوط به </span>Payload<span lang="fa"> 
								های </span><font color="#008000">CobaltStrike</font> 
								, <font color="#008000">Sliver-c2</font><span lang="fa"> 
								وشناسایی برخی از بایتهای مرتبط به </span>Payload<span lang="fa"> 
								های 
								این دو </span>C2 Server<span lang="fa"> در
								</span>Memory<span lang="fa"> و ...</span></font></b></li>
							</ul>
							</li>
						</ul>
						<ul>
							<li><b style="margin: 0">
							<font face="Tahoma" size="2" color="#000080" style="margin: 0">
							<a href="Chapter%2010/Chapter10.2.htm">
							<font color="#000080">
							<span style="text-decoration: none">10.2 ETW and VirtualMemAlloc Events , Part2</span></font></a></font></b><ul>
								<li><b><font face="Tahoma" size="2">
								در فصل 10 در بخش <span lang="fa">دوم که ادامه 
								بخش یک می باشد بر روی کدهای سی شارپ ابزار </span>
								ETWProcessMon v1.1 <span lang="fa">بیشتر تمرکز 
								می کنیم و هدف این می باشد که شما با </span>
								Background <span lang="fa">کد بیشتر آشنا شوید.</span></font></b></li>
							</ul></li>
							<li><b style="margin: 0">
							<font face="Tahoma" size="2" color="#000080" style="margin: 0">
							<a href="Chapter%2010/Chapter10.3.htm">
							<font color="#000080">
							<span style="text-decoration: none">10.3 ETW and VirtualMemAlloc Events , Part3</span></font></a></font></b><ul>
								<li><b><font face="Tahoma" size="2">
								در فصل 10 در بخش <span lang="fa">سوم&nbsp; که 
								ادامه بخشهای 1 و 2&nbsp; می باشد بر روی کدهای سی 
								شارپ ابزار </span>VirtualMemAllocMon v1.1
								<span lang="fa">بیشتر تمرکز می کنیم و هدف این می 
								باشد که شما با </span>Background <span lang="fa">
								کد در این </span>Memory Scanner<span lang="fa"> 
								که با </span>ETW Events<span lang="fa"> 
								کار می کند 
								بیشتر آشنا شوید.</span></font></b></li>
							</ul></li>
						</ul>
						</td>
					</tr>
					<tr>
						<td vAlign="center" width="1%" rowSpan="2">
						<font face="Arial">
						<img height="1" alt="" width="1" border="0"></font></td>
						<td class="b24-toc1" vAlign="top" noWrap width="9%" rowSpan="2">
						<b><font face="Arial" color="#666633" size="2">
						<span style="TEXT-DECORATION: none">Chapter 11</span></font></b></td>
						<td align="middle" width="1%" rowSpan="2">
						<font face="Arial" size="2">-</font></td>
						<td style="BORDER-TOP: 1px solid" width="61%">
						<p dir="ltr" align="right"><b><font face="Arial" size="2">Detecting Threats in-memory via other ETW Events (Blue team)</font></b></td>
					</tr>
					<tr>
						<td style="BORDER-BOTTOM: 1px solid" width="61%">
				<ul>
					<li><b style="margin: 0">
					<font face="Tahoma" size="2" color="#000080" style="margin: 0">
					<a href="Chapter%2011/Chapter11.1.htm"><font color="#000080">
					<span style="text-decoration: none">11.1 ETW ImageLoads and TCPIP Events for Detecting Threats In-Memory</span></font></a></font></b><ul>
						<li><b>
						<font face="Tahoma" size="2"><span lang="fa">در فصل 11 
						در بخش 1 روش های دیگر استفاده از </span>ETW<span lang="fa"> 
						برای </span>Detection<span lang="fa"> را بررسی می کنیم</span></font></b>
						<b><span lang="fa"><font face="Tahoma" size="2">در بخش 
						یک فصل 11 تکنیکی بسیار ساده اما کاربردی را برای شناسایی
						</font></span><font face="Tahoma" size="2">Process<span lang="fa"> 
						هایی که توسط </span>Sliver-c2<span lang="fa"> آلوده شده 
						اند</span></font><span lang="fa"><font face="Tahoma" size="2"> 
						و یا </font></span><font face="Tahoma" size="2">Payload<span lang="fa"> 
						مربوط به </span>Sliver-c2<span lang="fa"> به آنها </span>
						Inject<span lang="fa"> شده را بررسی می کنیم و آن روش 
						استفاده از</span>ETW<span lang="fa"> </span>Event
						<span lang="fa">های </span>ImageLoads<span lang="fa"> و
						</span>TCPIP Send<span lang="fa"> می باشد برای شناسایی
						</span>Process<span lang="fa"> های آلوده. در اینجا کد
						</span>ETWProcessMon v1.2<span lang="fa"> را که جدید می 
						باشد بررسی می کنیم.</span></font></b></li>
					</ul></li>
					<li><b style="margin: 0">
					<font face="Tahoma" size="2" color="#000080" style="margin: 0">
					<a href="Chapter%2011/Chapter11.2.htm"><font color="#000080">
					<span style="text-decoration: none">11.2 Detecting Remote Thread Injection and Monitoring Windows Events Log by Csharp</span></font></a></font></b><ul>
						<li><b>
						<font face="Tahoma" size="2"><span lang="fa">در فصل 11 
						در بخش 2 روش استفاده از </span>ETW ThreadStart Events<span lang="fa"> 
						را برای </span>Detect<span lang="fa"> کردن </span>
						<font color="#008000">Remote Thread Injection</font><span lang="fa"><font color="#008000">
						</font>را بررسی می کنیم و تمرکز ما بر روی کد جدید </span>
						ETWProcessMon v1.3<span lang="fa"> می باشد و همچنین روش 
						ذخیره کردن </span>ETW Events<span lang="fa"> را بر روی
						</span>Windows Event logs<span lang="fa"> را کار خواهیم 
						کرد که می تواند بسیار به افراد تیم آبی کمک کند در 
						استفاده از </span>ETW Events<span lang="fa"> برای انتقال
						</span>ETW Event Records<span lang="fa"> به دیگر ابزار 
						های دفاعی خود در بخش </span>SOC<span lang="fa"> و ...</span>
						<span lang="fa">و یک نمونه مثال از چگونگی </span>Monitor<span lang="fa"> 
						کردن </span>Windows Event Logs<span lang="fa"> توسط
						</span>Csharp<span lang="fa"> را بررسی می کنیم و ...</span></font></b></li>
					</ul></li>
				</ul>
						</td>
					</tr>
					<tr>
						<td vAlign="center" width="1%">
						<font face="Arial">
						<img height="1" alt="" width="1" border="0"></font></td>
					</tr>
					<tr>
						<td vAlign="center" width="1%">
						<font face="Arial">
						<img height="1" alt="" width="1" border="0"></font></td>
					</tr>
					<tr>
						<td vAlign="center" width="1%">
						<font face="Arial">
						<img height="1" alt="" width="1" border="0"></font></td>
					</tr>
					<tr>
						<td vAlign="center" width="1%">
						<font face="Arial">
						<img height="1" alt="" width="1" border="0"></font></td>
					</tr>
					<tr>
						<td vAlign="center" width="1%">
						<font face="Arial">
						<img height="1" alt="" width="1" border="0"></font></td>
					</tr>
					<tr>
						<td vAlign="center" width="1%">
						<font face="Arial">
						<img height="1" alt="" width="1" border="0"></font></td>
					</tr>
					<tr>
						<td vAlign="center" width="1%" rowSpan="2">
						<font face="Arial">
						<img height="1" alt="" width="1" border="0"></font></td>
					</tr>
					<tr>
						<td vAlign="center" width="1%" rowSpan="2">
						<font face="Arial">
						<img height="1" alt="" width="1" border="0"></font></td>
					</tr>
					<tr>
						<td vAlign="center" width="1%" rowSpan="2">
						<font face="Arial">
						<img height="1" alt="" width="1" border="0"></font></td>
					</tr>
					<tr>
						<td vAlign="center" width="1%" rowSpan="2">
						<font face="Arial">
						<img height="1" alt="" width="1" border="0"></font></td>
					</tr>
					</table>
				</td>
			</tr>
		</table>
		<p>&nbsp;</td>
	</tr>
	<tr>
		<td>
		&nbsp;</td>
	</tr>
	<tr>
		<td>
		&nbsp;</td>
	</tr>
	<tr>
		<td>
		&nbsp;</td>
	</tr>
	<tr>
		<td>
		&nbsp;</td>
	</tr>
	<tr>
		<td>
		&nbsp;</td>
	</tr>
	<tr>
		<td>
		&nbsp;</td>
	</tr>
	<tr>
		<td>
		&nbsp;</td>
	</tr>
	<tr>
		<td>
		<p align="left" dir="ltr"><b><font face="Tahoma" size="2">eBook: 
		Bypassing Anti viruses by C# Programming </font>
		<font face="Tahoma" size="1">v2.0</font></b></td>
	</tr>
	<tr>
		<td>
		<p align="left" dir="ltr"><b><font face="Tahoma" size="2">Last Updated: 
		2023 Jul 1<span lang="fa">4</span></font></b></td>
	</tr>
	</table>
	
</body>

</html>