<!DOCTYPE html>
<html>
<style>
/* CSS for image gallery */
#gallery {
    display: left;
    flex-wrap: wrap;
    justify-content: left	;
    gap: 20px;
    margin: 50px;
}

#gallery img {
    width: 600px;
    height: 300px;
    object-fit: cover;
    cursor: pointer;
}

#gallery p {
    margin: 10px 0 0;
    text-align: left;
    font-size: 18px;
    
}

/* CSS for modal */
.modal {
    display: none; /* hide the modal by default */
    position: left;
    z-index: 1;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    overflow: auto;
    background-color: rgba(0,0,0,0.9);
    padding-top: 100px;
}

.modal-content {
    display: block;
    margin: auto;
    max-width: 80%;
    max-height: 80%;
}

.modal-text {
    color: white;
    display: block;
    margin: 20px auto;
    width: 80%;
    text-align: left;
    font-size: 16px;
}
</style>
<head>
	<title>Research History</title>
	<style>
		img {
			width: 120px;
			height: 120px;
			margin: 10px;
			border: 1px solid black;
		}
	</style>
</head>
<body>
	<h1>Research History</h1>
	<div id="gallery"></div>

	<script>
		// script for image gallery functionality
var modal = document.getElementById("modal");
var modalImg = document.getElementById("modal-image");
var modalText = document.getElementById("modal-text");

var images = [
  { image: "1.jpeg", text: "[18/03/2017] , Meterpreter_Payload_Detection.exe v1.06 (Test version) , Checking Memory Realtime by Monitoring Threads (ETW) and Detecting Meterpreter Payloads ;-) , time to Fix bugs and Using New Signatures for (Empire)." },
  { image: "2.jpeg", text: "[26/04/2017] , Meterpreter ReverseTcp x64 Payloads via image Pixels ;D, Article: https://lnkd.in/gJdRgZT i had a lot bug for this , finally i made this i hope fixing these bugs very soon ;) , i know idea for transferring payloads by Images is not new but i want to check this one with AVS by my techniques .... , i will try to fix bad bugs for my code then i will publish source code ......" },
  { image: "3.jpeg", text: "[19/05/2017] , Now McAfee Tested by this technique and bypassed too like these tools :  Eset , Kaspersky and Malwarebytes , test Finished" },
  { image: "4.jpeg", text: "[22/05/2017] , Sysmon log file : i don't know why but the log file generated by this sysmon tool was not enough for Detecting Injected Thread ID TID for Notepad Process in this case 2472 with Start-address: 0x0 , did you see something wrong somewhere for my sysmon log (is this tool used etw ?) ? , unfortunately in sysmon log records you can't find any record about Event : New Thread Created in Notepad Process with TID 2472 so i think C# code with ETW is better also useful for detecting this type of threat , watch ETW Picture for detecting Meterpreter Payload in memory , MPD inegrated with ETW old Picture in this link : https://lnkd.in/fg_BZd8 , i will check for Detecting this Injection attack by MPD [Test ver] i will share my result very soon , but in this case i think Sysmon tool test failed ;( . , you can see MPD integrated with ETW v1.0.6r Result for this type of attack in this link : https://lnkd.in/fHTF9uG" },
  { image: "5.jpeg", text: "[24/05/2017] , Now with MPD v1.0.6 (Test version) and ETW you can Find Injected Threads to other Process as i said like Real-Time Monitoring Tool , you can see in this picture Meterpreter Injected to Mspaint Process PID: 1948 by TID: 2800 with Start-address 0x0 also you can see MPD detected Infected Process also TID 2800 with Status W:Executive , so we have Not Result like this by sysmon tool unfortunately ;( , you can see sysmon tool failed result in this link: https://lnkd.in/f2wVeZH this is ETW powerful ;) as i said in my previous Article this injection Technique currently will not detect by AVs like Kaspersky, ESET and McAfee or malwarebytes , etc Signature Based AVs , Article link: https://lnkd.in/fHzCxgN" },
  { image: "6.jpeg", text: "[12/07/2017] , Bypassing Anti-viruses By Exfiltration Method via Infecting Target Process Memory , in this case your Malware/Backdoor behavior is different because this Malware/backdoor try to Scanning Memory and Dumping Some Parts of your Windows Process Memory probably just one time so in this case this Backdoor will Work Very Quietly and you should check this Technique for Bypassing Signature-Based AVS and this method is very simple because an attacker can do this by MITM attack over Http and Https then your Firefox or IE and Chrome Process Memory will Infect by this method and finally Backdoor can dump these Bytes from These Process Memory very simple etc . i will make Article for this But C# source code and other things about this method you will see in my Udemy C# Course only ;) , this some part of my Course in udemy Bypassing Anti-viruses by C# Programming Video link https://lnkd.in/gX4X2KF" },  
  { image: "7.jpeg", text: "[01/08/2017] , Payload hiding Method via Infecting Target Process Memory this article blocked in Linkedin so i made this in my Github. in this article i tlaked about how attackers can Hide their Payloads in your Target Process Memory etc ,you can see this article in my github account also you can download this Article with (PDF , HTML) formats and in peerlyst you can find my Article. Github : https://lnkd.in/fSgZkys" },
  { image: "8.jpeg", text: "[06/08/2017] , Payload hiding Method via Infecting Target Process Memory this is POC for Dumping Payloads from Target Process Memory Runtime/Executing and Getting Meterpreter Session ! in this case an attacker will infect your Target Process ONLY by REM command in cmd.exe or Creating Variables in Powershell.exe (Target Processes) Then these Target Process are kind of Temporary location for your Malware Payloads ;) so this backdoor very simple will dump these bytes from Target Process Memory Directly. finally BINGO!" },
  { image: "9.jpeg", text: "[07/08/2017] , this is talking about where you can Hiding Payloads , AVAST bypassing , Payload hiding Method via Infecting Target Process Memory this is POC in Win7x64SP1 for Dumping Payloads from Target Process Memory Runtime/Executing and Getting Meterpreter Session ! in this case an attacker will infect your Target Process ONLY by REM command in cmd.exe or Creating Variables in Powershell.exe (Target Processes) Then these Target Process are kind of Temporary location for your Malware Payloads ;) so this backdoor very simple will dump these bytes from Target Process Memory Directly. finally BINGO!" },
  { image: "10.jpeg", text: "[08/08/2017] , this is talking about where you can Hiding Payloads also Hiding your Source Codes too in this Case C# codes , AVs bypassing , Payload hiding Method via Infecting Target Process Memory as you can see attacker can do this by injecting C# codes to Target Process Memory in this case CMD.EXE with PID 2532 by REM Command then these C# Source codes Dumped from cmd:2532 by Backdoor and in Memory Compiled and Executed too ... in this case our Backdoor has 2 sections :1.Section one is our Code for Dumping Target Process Memory also in this section we have C# Codes for Compiling Section 2 Codes . 2.Section two is our C# Code for Executing Meterpreter Payload or Malware Payload in Memory , so in this Technique this Section Will Inject to Target Process Memory in this case our Target Process is CMD.EXE so by REM command we can injecting our Codes to CMD.EXE Process Memory and this Section will dump by Section one finally Codes in Section two Compiled by Section one in Memory and Executed too.for more information please read my Post in Peerlyst.com for this : https://lnkd.in/f7CChxA , video link : https://lnkd.in/fqex_3y" },
  { image: "11.jpeg", text: "[11/09/2017] , Kaspersky bypassed by this technique too ;) in this case our Backdoor has 2 sections : 1.Section one is our Code for Dumping Target Process Memory also in this section we have C# Codes for Compiling Section 2 Codes. 2.Section two is our C# Code for Executing Meterpreter Payload or Malware Payload in Memory , so in this Technique this Section Will Inject to Target Process Memory in this case our Target Process is CMD.EXE so by REM command we can injecting our Codes to CMD.EXE Process Memory and this Section will dump by Section one finally Codes in Section two Compiled by Section one in Memory and Executed too." },

  { image: "12.jpeg", text: "[18/10/2017] , code for exfiltration/uploading DATA to DNS server by PTR request is ready , i will publish this Code in github by new Code soon ;). with exf switch you can send these Data to DNS Server with Random Time and with Reading DNS Log file you can get these Data very simple . Article and Code Published : https://lnkd.in/d8GftsW" },
  { image: "13.jpeg", text: "[25/10/2017] , Dnsmasq log reader tool for dumping Exfiltrated Data by PTR Records now is ready i will publish article about this in this week also i will explain these C# codes too . as you can see these green text are Exfiltrated DATA behind these DNS logs for PTR Records , Article and Code Published : https://lnkd.in/d8GftsW and https://www.linkedin.com/feed/update/urn:li:activity:6326957568291799040 , chapter 5 of ebook => https://damonmohammadbagher.github.io/Posts/ebookBypassingAVsByCsharpProgramming/index.htm?page=Chapter%205.html" },
  { image: "14.jpeg", text: "[04/11/2017] , Exfil and Uploading DATA via IPv6 AAAA records Request to Fake DNS server or Udp Port 53 Listener ;) after IPv4 now IPv6 ... C# code published and i will make article for this: https://lnkd.in/e5x2mCR , Video : https://lnkd.in/dZz8j4w and https://www.linkedin.com/feed/update/urn:li:activity:6339996691781025792 , Chapter7 of ebook => https://damonmohammadbagher.github.io/Posts/ebookBypassingAVsByCsharpProgramming/index.htm?page=Chapter%207.html and pdf/article => https://github.com/DamonMohammadbagher/eBook-BypassingAVsByCSharp/tree/master/CH7" },
  { image: "15.jpeg", text: "3.txt" },  
  { image: "16.jpeg", text: "3.txt" },
  { image: "17.jpeg", text: "3.txt" },
  { image: "18.jpeg", text: "3.txt" },
  { image: "19.jpeg", text: "3.txt" },
  { image: "20.jpeg", text: "3.txt" },

  { image: "21.jpeg", text: "3.txt" },
  { image: "22.jpeg", text: "3.txt" },
  { image: "23.jpeg", text: "3.txt" },
  { image: "24.jpeg", text: "3.txt" },  
  { image: "25.jpeg", text: "3.txt" },
  { image: "26.jpeg", text: "3.txt" },
  { image: "27.jpeg", text: "3.txt" },
  { image: "28.jpeg", text: "3.txt" },
  { image: "29.jpeg", text: "3.txt" },

  { image: "30.jpeg", text: "3.txt" },
  { image: "31.jpeg", text: "3.txt" },
  { image: "32.jpeg", text: "3.txt" },
  { image: "33.jpeg", text: "3.txt" },  
  { image: "34.jpeg", text: "3.txt" },
  { image: "35.jpeg", text: "3.txt" },
  { image: "36.jpeg", text: "3.txt" },
  { image: "37.jpeg", text: "3.txt" },
  { image: "38.jpeg", text: "3.txt" },

];

var gallery = document.getElementById("gallery");
for (var i = 37; i < images.length; i--) {
  gallery.appendChild(document.createElement("p"));
  var img = document.createElement("img");
  img.src = "ResearchHistory/" + images[i].image;
  img.alt = images[i].text;
  img.title = images[i].text;
  var txt = document.createElement("p");
  var txt2 = document.createElement("p");
  txt.textContent =  " " + i + ": "  + images[i].text ;
  
  gallery.appendChild(txt2)
  gallery.appendChild(img);
  gallery.appendChild(txt);
  gallery.appendChild(txt2)
  gallery.append("_____________________________________________________________________________")
  img.addEventListener("click", function() {
    modal.style.display = "block"; // display the modal
    modalImg.src = this.src; // set the source of the modal image to the clicked image
    modalText.textContent = this.alt; // set the text of the modal to the alt text of the clicked image
  });
}

// close the modal by clicking on it
modal.addEventListener("click", function() {
  modal.style.display = "none";
});
		
	</script>
</body>
</html>

